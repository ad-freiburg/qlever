
// Generated from SparqlAutomatic.g4 by ANTLR 4.11.1

#include "SparqlAutomaticParser.h"

#include "SparqlAutomaticListener.h"
#include "SparqlAutomaticVisitor.h"

using namespace antlrcpp;

using namespace antlr4;

namespace {

struct SparqlAutomaticParserStaticData final {
  SparqlAutomaticParserStaticData(std::vector<std::string> ruleNames,
                                  std::vector<std::string> literalNames,
                                  std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)),
        literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  SparqlAutomaticParserStaticData(const SparqlAutomaticParserStaticData&) =
      delete;
  SparqlAutomaticParserStaticData(SparqlAutomaticParserStaticData&&) = delete;
  SparqlAutomaticParserStaticData& operator=(
      const SparqlAutomaticParserStaticData&) = delete;
  SparqlAutomaticParserStaticData& operator=(
      SparqlAutomaticParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag sparqlautomaticParserOnceFlag;
SparqlAutomaticParserStaticData* sparqlautomaticParserStaticData = nullptr;

void sparqlautomaticParserInitialize() {
  assert(sparqlautomaticParserStaticData == nullptr);
  auto staticData = std::make_unique<SparqlAutomaticParserStaticData>(
      std::vector<std::string>{
          "queryOrUpdate",
          "query",
          "prologue",
          "baseDecl",
          "prefixDecl",
          "selectQuery",
          "subSelect",
          "selectClause",
          "varOrAlias",
          "alias",
          "aliasWithoutBrackets",
          "constructQuery",
          "describeQuery",
          "askQuery",
          "datasetClause",
          "defaultGraphClause",
          "namedGraphClause",
          "sourceSelector",
          "whereClause",
          "solutionModifier",
          "groupClause",
          "groupCondition",
          "havingClause",
          "havingCondition",
          "orderClause",
          "orderCondition",
          "limitOffsetClauses",
          "limitClause",
          "offsetClause",
          "textLimitClause",
          "valuesClause",
          "update",
          "update1",
          "load",
          "clear",
          "drop",
          "create",
          "add",
          "move",
          "copy",
          "insertData",
          "deleteData",
          "deleteWhere",
          "modify",
          "deleteClause",
          "insertClause",
          "usingClause",
          "graphOrDefault",
          "graphRef",
          "graphRefAll",
          "quadPattern",
          "quadData",
          "quads",
          "quadsNotTriples",
          "triplesTemplate",
          "groupGraphPattern",
          "groupGraphPatternSub",
          "graphPatternNotTriplesAndMaybeTriples",
          "triplesBlock",
          "graphPatternNotTriples",
          "optionalGraphPattern",
          "graphGraphPattern",
          "serviceGraphPattern",
          "bind",
          "inlineData",
          "dataBlock",
          "inlineDataOneVar",
          "inlineDataFull",
          "dataBlockSingle",
          "dataBlockValue",
          "minusGraphPattern",
          "groupOrUnionGraphPattern",
          "filterR",
          "constraint",
          "functionCall",
          "argList",
          "expressionList",
          "constructTemplate",
          "constructTriples",
          "triplesSameSubject",
          "propertyList",
          "propertyListNotEmpty",
          "verb",
          "objectList",
          "objectR",
          "triplesSameSubjectPath",
          "propertyListPath",
          "propertyListPathNotEmpty",
          "verbPath",
          "verbSimple",
          "tupleWithoutPath",
          "tupleWithPath",
          "verbPathOrSimple",
          "objectListPath",
          "objectPath",
          "path",
          "pathAlternative",
          "pathSequence",
          "pathElt",
          "pathEltOrInverse",
          "pathMod",
          "pathPrimary",
          "pathNegatedPropertySet",
          "pathOneInPropertySet",
          "integer",
          "triplesNode",
          "blankNodePropertyList",
          "triplesNodePath",
          "blankNodePropertyListPath",
          "collection",
          "collectionPath",
          "graphNode",
          "graphNodePath",
          "varOrTerm",
          "varOrIri",
          "var",
          "graphTerm",
          "expression",
          "conditionalOrExpression",
          "conditionalAndExpression",
          "valueLogical",
          "relationalExpression",
          "numericExpression",
          "additiveExpression",
          "multiplicativeExpressionWithSign",
          "plusSubexpression",
          "minusSubexpression",
          "multiplicativeExpressionWithLeadingSignButNoSpace",
          "multiplicativeExpression",
          "multiplyOrDivideExpression",
          "multiplyExpression",
          "divideExpression",
          "unaryExpression",
          "primaryExpression",
          "brackettedExpression",
          "builtInCall",
          "regexExpression",
          "langExpression",
          "substringExpression",
          "strReplaceExpression",
          "existsFunc",
          "notExistsFunc",
          "aggregate",
          "iriOrFunction",
          "rdfLiteral",
          "numericLiteral",
          "numericLiteralUnsigned",
          "numericLiteralPositive",
          "numericLiteralNegative",
          "booleanLiteral",
          "string",
          "iri",
          "prefixedName",
          "blankNode",
          "iriref",
          "pnameLn",
          "pnameNs"},
      std::vector<std::string>{"",     "'*'",  "'('",  "')'",    "'{'",
                               "'}'",  "';'",  "'.'",  "','",    "'a'",
                               "'|'",  "'/'",  "'^'",  "'+'",    "'\\u003F'",
                               "'!'",  "'['",  "']'",  "'||'",   "'&&'",
                               "'='",  "'!='", "'<'",  "'>'",    "'<='",
                               "'>='", "'-'",  "'^^'", "'true'", "'false'"},
      std::vector<std::string>{"",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "BASE",
                               "PREFIX",
                               "SELECT",
                               "DISTINCT",
                               "REDUCED",
                               "AS",
                               "CONSTRUCT",
                               "WHERE",
                               "DESCRIBE",
                               "ASK",
                               "FROM",
                               "NAMED",
                               "GROUPBY",
                               "GROUP_CONCAT",
                               "HAVING",
                               "ORDERBY",
                               "INTERNALSORTBY",
                               "ASC",
                               "DESC",
                               "LIMIT",
                               "OFFSET",
                               "TEXTLIMIT",
                               "VALUES",
                               "LOAD",
                               "SILENT",
                               "INTO",
                               "CLEAR",
                               "DROP",
                               "CREATE",
                               "ADD",
                               "TO",
                               "DATA",
                               "MOVE",
                               "COPY",
                               "INSERT",
                               "DELETE",
                               "WITH",
                               "USING",
                               "DEFAULT",
                               "GRAPH",
                               "ALL",
                               "OPTIONAL",
                               "SERVICE",
                               "BIND",
                               "UNDEF",
                               "MINUS",
                               "UNION",
                               "FILTER",
                               "NOT",
                               "IN",
                               "STR",
                               "LANG",
                               "LANGMATCHES",
                               "DATATYPE",
                               "BOUND",
                               "IRI",
                               "URI",
                               "BNODE",
                               "RAND",
                               "ABS",
                               "CEIL",
                               "FLOOR",
                               "ROUND",
                               "CONCAT",
                               "STRLEN",
                               "UCASE",
                               "LCASE",
                               "ENCODE_FOR_URI",
                               "FOR",
                               "CONTAINS",
                               "STRSTARTS",
                               "STRENDS",
                               "STRBEFORE",
                               "STRAFTER",
                               "YEAR",
                               "MONTH",
                               "DAY",
                               "HOURS",
                               "MINUTES",
                               "SECONDS",
                               "TIMEZONE",
                               "TZ",
                               "NOW",
                               "UUID",
                               "STRUUID",
                               "SHA1",
                               "SHA256",
                               "SHA384",
                               "SHA512",
                               "MD5",
                               "COALESCE",
                               "IF",
                               "STRLANG",
                               "STRDT",
                               "SAMETERM",
                               "ISIRI",
                               "ISURI",
                               "ISBLANK",
                               "ISLITERAL",
                               "ISNUMERIC",
                               "REGEX",
                               "SUBSTR",
                               "REPLACE",
                               "EXISTS",
                               "COUNT",
                               "SUM",
                               "MIN",
                               "MAX",
                               "AVG",
                               "STDEV",
                               "SAMPLE",
                               "SEPARATOR",
                               "IRI_REF",
                               "PNAME_NS",
                               "PNAME_LN",
                               "BLANK_NODE_LABEL",
                               "VAR1",
                               "VAR2",
                               "LANGTAG",
                               "PREFIX_LANGTAG",
                               "INTEGER",
                               "DECIMAL",
                               "DOUBLE",
                               "INTEGER_POSITIVE",
                               "DECIMAL_POSITIVE",
                               "DOUBLE_POSITIVE",
                               "INTEGER_NEGATIVE",
                               "DECIMAL_NEGATIVE",
                               "DOUBLE_NEGATIVE",
                               "EXPONENT",
                               "STRING_LITERAL1",
                               "STRING_LITERAL2",
                               "STRING_LITERAL_LONG1",
                               "STRING_LITERAL_LONG2",
                               "ECHAR",
                               "NIL",
                               "ANON",
                               "PN_CHARS_U",
                               "VARNAME",
                               "PN_PREFIX",
                               "PN_LOCAL",
                               "PLX",
                               "PERCENT",
                               "HEX",
                               "PN_LOCAL_ESC",
                               "WS",
                               "COMMENTS"});
  static const int32_t serializedATNSegment[] = {
      4,    1,    176,  1670, 2,    0,    7,    0,    2,    1,    7,    1,
      2,    2,    7,    2,    2,    3,    7,    3,    2,    4,    7,    4,
      2,    5,    7,    5,    2,    6,    7,    6,    2,    7,    7,    7,
      2,    8,    7,    8,    2,    9,    7,    9,    2,    10,   7,    10,
      2,    11,   7,    11,   2,    12,   7,    12,   2,    13,   7,    13,
      2,    14,   7,    14,   2,    15,   7,    15,   2,    16,   7,    16,
      2,    17,   7,    17,   2,    18,   7,    18,   2,    19,   7,    19,
      2,    20,   7,    20,   2,    21,   7,    21,   2,    22,   7,    22,
      2,    23,   7,    23,   2,    24,   7,    24,   2,    25,   7,    25,
      2,    26,   7,    26,   2,    27,   7,    27,   2,    28,   7,    28,
      2,    29,   7,    29,   2,    30,   7,    30,   2,    31,   7,    31,
      2,    32,   7,    32,   2,    33,   7,    33,   2,    34,   7,    34,
      2,    35,   7,    35,   2,    36,   7,    36,   2,    37,   7,    37,
      2,    38,   7,    38,   2,    39,   7,    39,   2,    40,   7,    40,
      2,    41,   7,    41,   2,    42,   7,    42,   2,    43,   7,    43,
      2,    44,   7,    44,   2,    45,   7,    45,   2,    46,   7,    46,
      2,    47,   7,    47,   2,    48,   7,    48,   2,    49,   7,    49,
      2,    50,   7,    50,   2,    51,   7,    51,   2,    52,   7,    52,
      2,    53,   7,    53,   2,    54,   7,    54,   2,    55,   7,    55,
      2,    56,   7,    56,   2,    57,   7,    57,   2,    58,   7,    58,
      2,    59,   7,    59,   2,    60,   7,    60,   2,    61,   7,    61,
      2,    62,   7,    62,   2,    63,   7,    63,   2,    64,   7,    64,
      2,    65,   7,    65,   2,    66,   7,    66,   2,    67,   7,    67,
      2,    68,   7,    68,   2,    69,   7,    69,   2,    70,   7,    70,
      2,    71,   7,    71,   2,    72,   7,    72,   2,    73,   7,    73,
      2,    74,   7,    74,   2,    75,   7,    75,   2,    76,   7,    76,
      2,    77,   7,    77,   2,    78,   7,    78,   2,    79,   7,    79,
      2,    80,   7,    80,   2,    81,   7,    81,   2,    82,   7,    82,
      2,    83,   7,    83,   2,    84,   7,    84,   2,    85,   7,    85,
      2,    86,   7,    86,   2,    87,   7,    87,   2,    88,   7,    88,
      2,    89,   7,    89,   2,    90,   7,    90,   2,    91,   7,    91,
      2,    92,   7,    92,   2,    93,   7,    93,   2,    94,   7,    94,
      2,    95,   7,    95,   2,    96,   7,    96,   2,    97,   7,    97,
      2,    98,   7,    98,   2,    99,   7,    99,   2,    100,  7,    100,
      2,    101,  7,    101,  2,    102,  7,    102,  2,    103,  7,    103,
      2,    104,  7,    104,  2,    105,  7,    105,  2,    106,  7,    106,
      2,    107,  7,    107,  2,    108,  7,    108,  2,    109,  7,    109,
      2,    110,  7,    110,  2,    111,  7,    111,  2,    112,  7,    112,
      2,    113,  7,    113,  2,    114,  7,    114,  2,    115,  7,    115,
      2,    116,  7,    116,  2,    117,  7,    117,  2,    118,  7,    118,
      2,    119,  7,    119,  2,    120,  7,    120,  2,    121,  7,    121,
      2,    122,  7,    122,  2,    123,  7,    123,  2,    124,  7,    124,
      2,    125,  7,    125,  2,    126,  7,    126,  2,    127,  7,    127,
      2,    128,  7,    128,  2,    129,  7,    129,  2,    130,  7,    130,
      2,    131,  7,    131,  2,    132,  7,    132,  2,    133,  7,    133,
      2,    134,  7,    134,  2,    135,  7,    135,  2,    136,  7,    136,
      2,    137,  7,    137,  2,    138,  7,    138,  2,    139,  7,    139,
      2,    140,  7,    140,  2,    141,  7,    141,  2,    142,  7,    142,
      2,    143,  7,    143,  2,    144,  7,    144,  2,    145,  7,    145,
      2,    146,  7,    146,  2,    147,  7,    147,  2,    148,  7,    148,
      2,    149,  7,    149,  2,    150,  7,    150,  2,    151,  7,    151,
      2,    152,  7,    152,  2,    153,  7,    153,  2,    154,  7,    154,
      2,    155,  7,    155,  2,    156,  7,    156,  1,    0,    1,    0,
      3,    0,    317,  8,    0,    1,    0,    1,    0,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    3,    1,    326,  8,    1,
      1,    1,    1,    1,    1,    2,    1,    2,    5,    2,    332,  8,
      2,    10,   2,    12,   2,    335,  9,    2,    1,    3,    1,    3,
      1,    3,    1,    4,    1,    4,    1,    4,    1,    4,    1,    5,
      1,    5,    5,    5,    346,  8,    5,    10,   5,    12,   5,    349,
      9,    5,    1,    5,    1,    5,    1,    5,    1,    6,    1,    6,
      1,    6,    1,    6,    1,    6,    1,    7,    1,    7,    3,    7,
      361,  8,    7,    1,    7,    4,    7,    364,  8,    7,    11,   7,
      12,   7,    365,  1,    7,    3,    7,    369,  8,    7,    1,    8,
      1,    8,    3,    8,    373,  8,    8,    1,    9,    1,    9,    1,
      9,    1,    9,    1,    10,   1,    10,   1,    10,   1,    10,   1,
      11,   1,    11,   1,    11,   5,    11,   386,  8,    11,   10,   11,
      12,   11,   389,  9,    11,   1,    11,   1,    11,   1,    11,   1,
      11,   5,    11,   395,  8,    11,   10,   11,   12,   11,   398,  9,
      11,   1,    11,   1,    11,   1,    11,   3,    11,   403,  8,    11,
      1,    11,   1,    11,   3,    11,   407,  8,    11,   1,    12,   1,
      12,   4,    12,   411,  8,    12,   11,   12,   12,   12,   412,  1,
      12,   3,    12,   416,  8,    12,   1,    12,   5,    12,   419,  8,
      12,   10,   12,   12,   12,   422,  9,    12,   1,    12,   3,    12,
      425,  8,    12,   1,    12,   1,    12,   1,    13,   1,    13,   5,
      13,   431,  8,    13,   10,   13,   12,   13,   434,  9,    13,   1,
      13,   1,    13,   1,    13,   1,    14,   1,    14,   1,    14,   3,
      14,   442,  8,    14,   1,    15,   1,    15,   1,    16,   1,    16,
      1,    16,   1,    17,   1,    17,   1,    18,   3,    18,   452,  8,
      18,   1,    18,   1,    18,   1,    19,   3,    19,   457,  8,    19,
      1,    19,   3,    19,   460,  8,    19,   1,    19,   3,    19,   463,
      8,    19,   1,    19,   3,    19,   466,  8,    19,   1,    20,   1,
      20,   4,    20,   470,  8,    20,   11,   20,   12,   20,   471,  1,
      21,   1,    21,   1,    21,   1,    21,   1,    21,   1,    21,   3,
      21,   480,  8,    21,   1,    21,   1,    21,   1,    21,   3,    21,
      485,  8,    21,   1,    22,   1,    22,   4,    22,   489,  8,    22,
      11,   22,   12,   22,   490,  1,    23,   1,    23,   1,    24,   1,
      24,   3,    24,   497,  8,    24,   1,    24,   4,    24,   500,  8,
      24,   11,   24,   12,   24,   501,  1,    25,   1,    25,   1,    25,
      1,    25,   3,    25,   508,  8,    25,   3,    25,   510,  8,    25,
      1,    26,   1,    26,   3,    26,   514,  8,    26,   1,    26,   3,
      26,   517,  8,    26,   1,    26,   1,    26,   3,    26,   521,  8,
      26,   1,    26,   3,    26,   524,  8,    26,   1,    26,   1,    26,
      3,    26,   528,  8,    26,   1,    26,   3,    26,   531,  8,    26,
      1,    26,   1,    26,   3,    26,   535,  8,    26,   1,    26,   3,
      26,   538,  8,    26,   1,    26,   1,    26,   3,    26,   542,  8,
      26,   1,    26,   3,    26,   545,  8,    26,   1,    26,   1,    26,
      3,    26,   549,  8,    26,   1,    26,   3,    26,   552,  8,    26,
      3,    26,   554,  8,    26,   1,    27,   1,    27,   1,    27,   1,
      28,   1,    28,   1,    28,   1,    29,   1,    29,   1,    29,   1,
      30,   1,    30,   3,    30,   567,  8,    30,   1,    31,   1,    31,
      1,    31,   1,    31,   1,    31,   1,    31,   5,    31,   575,  8,
      31,   10,   31,   12,   31,   578,  9,    31,   1,    31,   1,    31,
      3,    31,   582,  8,    31,   3,    31,   584,  8,    31,   1,    32,
      1,    32,   1,    32,   1,    32,   1,    32,   1,    32,   1,    32,
      1,    32,   1,    32,   1,    32,   1,    32,   3,    32,   597,  8,
      32,   1,    33,   1,    33,   3,    33,   601,  8,    33,   1,    33,
      1,    33,   1,    33,   3,    33,   606,  8,    33,   1,    34,   1,
      34,   3,    34,   610,  8,    34,   1,    34,   1,    34,   1,    35,
      1,    35,   3,    35,   616,  8,    35,   1,    35,   1,    35,   1,
      36,   1,    36,   3,    36,   622,  8,    36,   1,    36,   1,    36,
      1,    37,   1,    37,   3,    37,   628,  8,    37,   1,    37,   1,
      37,   1,    37,   1,    37,   1,    38,   1,    38,   3,    38,   636,
      8,    38,   1,    38,   1,    38,   1,    38,   1,    38,   1,    39,
      1,    39,   3,    39,   644,  8,    39,   1,    39,   1,    39,   1,
      39,   1,    39,   1,    40,   1,    40,   1,    40,   1,    40,   1,
      41,   1,    41,   1,    41,   1,    41,   1,    42,   1,    42,   1,
      42,   1,    42,   1,    43,   1,    43,   3,    43,   664,  8,    43,
      1,    43,   1,    43,   3,    43,   668,  8,    43,   1,    43,   3,
      43,   671,  8,    43,   1,    43,   5,    43,   674,  8,    43,   10,
      43,   12,   43,   677,  9,    43,   1,    43,   1,    43,   1,    43,
      1,    44,   1,    44,   1,    44,   1,    45,   1,    45,   1,    45,
      1,    46,   1,    46,   1,    46,   1,    46,   3,    46,   692,  8,
      46,   1,    47,   1,    47,   3,    47,   696,  8,    47,   1,    47,
      3,    47,   699,  8,    47,   1,    48,   1,    48,   1,    48,   1,
      49,   1,    49,   1,    49,   1,    49,   3,    49,   708,  8,    49,
      1,    50,   1,    50,   1,    50,   1,    50,   1,    51,   1,    51,
      1,    51,   1,    51,   1,    52,   3,    52,   719,  8,    52,   1,
      52,   1,    52,   3,    52,   723,  8,    52,   1,    52,   3,    52,
      726,  8,    52,   5,    52,   728,  8,    52,   10,   52,   12,   52,
      731,  9,    52,   1,    53,   1,    53,   1,    53,   1,    53,   3,
      53,   737,  8,    53,   1,    53,   1,    53,   1,    54,   1,    54,
      1,    54,   5,    54,   744,  8,    54,   10,   54,   12,   54,   747,
      9,    54,   1,    54,   3,    54,   750,  8,    54,   1,    55,   1,
      55,   1,    55,   3,    55,   755,  8,    55,   1,    55,   1,    55,
      1,    56,   3,    56,   760,  8,    56,   1,    56,   5,    56,   763,
      8,    56,   10,   56,   12,   56,   766,  9,    56,   1,    57,   1,
      57,   3,    57,   770,  8,    57,   1,    57,   3,    57,   773,  8,
      57,   1,    58,   1,    58,   1,    58,   3,    58,   778,  8,    58,
      3,    58,   780,  8,    58,   1,    59,   1,    59,   1,    59,   1,
      59,   1,    59,   1,    59,   1,    59,   1,    59,   3,    59,   790,
      8,    59,   1,    60,   1,    60,   1,    60,   1,    61,   1,    61,
      1,    61,   1,    61,   1,    62,   1,    62,   3,    62,   801,  8,
      62,   1,    62,   1,    62,   1,    62,   1,    63,   1,    63,   1,
      63,   1,    63,   1,    63,   1,    63,   1,    63,   1,    64,   1,
      64,   1,    64,   1,    65,   1,    65,   3,    65,   818,  8,    65,
      1,    66,   1,    66,   1,    66,   5,    66,   823,  8,    66,   10,
      66,   12,   66,   826,  9,    66,   1,    66,   1,    66,   1,    67,
      1,    67,   1,    67,   5,    67,   833,  8,    67,   10,   67,   12,
      67,   836,  9,    67,   1,    67,   3,    67,   839,  8,    67,   1,
      67,   1,    67,   5,    67,   843,  8,    67,   10,   67,   12,   67,
      846,  9,    67,   1,    67,   1,    67,   1,    68,   1,    68,   5,
      68,   852,  8,    68,   10,   68,   12,   68,   855,  9,    68,   1,
      68,   1,    68,   3,    68,   859,  8,    68,   1,    69,   1,    69,
      1,    69,   1,    69,   1,    69,   3,    69,   866,  8,    69,   1,
      70,   1,    70,   1,    70,   1,    71,   1,    71,   1,    71,   5,
      71,   874,  8,    71,   10,   71,   12,   71,   877,  9,    71,   1,
      72,   1,    72,   1,    72,   1,    73,   1,    73,   1,    73,   3,
      73,   885,  8,    73,   1,    74,   1,    74,   1,    74,   1,    75,
      1,    75,   1,    75,   3,    75,   893,  8,    75,   1,    75,   1,
      75,   1,    75,   5,    75,   898,  8,    75,   10,   75,   12,   75,
      901,  9,    75,   1,    75,   1,    75,   3,    75,   905,  8,    75,
      1,    76,   1,    76,   1,    76,   1,    76,   1,    76,   5,    76,
      912,  8,    76,   10,   76,   12,   76,   915,  9,    76,   1,    76,
      1,    76,   3,    76,   919,  8,    76,   1,    77,   1,    77,   3,
      77,   923,  8,    77,   1,    77,   1,    77,   1,    78,   1,    78,
      1,    78,   3,    78,   930,  8,    78,   3,    78,   932,  8,    78,
      1,    79,   1,    79,   1,    79,   1,    79,   1,    79,   1,    79,
      3,    79,   940,  8,    79,   1,    80,   3,    80,   943,  8,    80,
      1,    81,   1,    81,   1,    81,   1,    81,   1,    81,   1,    81,
      3,    81,   951,  8,    81,   5,    81,   953,  8,    81,   10,   81,
      12,   81,   956,  9,    81,   1,    82,   1,    82,   3,    82,   960,
      8,    82,   1,    83,   1,    83,   1,    83,   5,    83,   965,  8,
      83,   10,   83,   12,   83,   968,  9,    83,   1,    84,   1,    84,
      1,    85,   1,    85,   1,    85,   1,    85,   1,    85,   1,    85,
      3,    85,   978,  8,    85,   1,    86,   3,    86,   981,  8,    86,
      1,    87,   1,    87,   1,    87,   3,    87,   986,  8,    87,   5,
      87,   988,  8,    87,   10,   87,   12,   87,   991,  9,    87,   1,
      88,   1,    88,   1,    89,   1,    89,   1,    90,   1,    90,   1,
      90,   1,    91,   1,    91,   1,    91,   1,    92,   1,    92,   3,
      92,   1005, 8,    92,   1,    93,   1,    93,   1,    93,   5,    93,
      1010, 8,    93,   10,   93,   12,   93,   1013, 9,    93,   1,    94,
      1,    94,   1,    95,   1,    95,   1,    96,   1,    96,   1,    96,
      5,    96,   1022, 8,    96,   10,   96,   12,   96,   1025, 9,    96,
      1,    97,   1,    97,   1,    97,   5,    97,   1030, 8,    97,   10,
      97,   12,   97,   1033, 9,    97,   1,    98,   1,    98,   3,    98,
      1037, 8,    98,   1,    99,   1,    99,   1,    99,   3,    99,   1042,
      8,    99,   1,    100,  1,    100,  1,    101,  1,    101,  1,    101,
      1,    101,  1,    101,  1,    101,  1,    101,  1,    101,  3,    101,
      1054, 8,    101,  1,    102,  1,    102,  1,    102,  1,    102,  1,
      102,  5,    102,  1061, 8,    102,  10,   102,  12,   102,  1064, 9,
      102,  3,    102,  1066, 8,    102,  1,    102,  3,    102,  1069, 8,
      102,  1,    103,  1,    103,  1,    103,  1,    103,  1,    103,  3,
      103,  1076, 8,    103,  3,    103,  1078, 8,    103,  1,    104,  1,
      104,  1,    105,  1,    105,  3,    105,  1084, 8,    105,  1,    106,
      1,    106,  1,    106,  1,    106,  1,    107,  1,    107,  3,    107,
      1092, 8,    107,  1,    108,  1,    108,  1,    108,  1,    108,  1,
      109,  1,    109,  4,    109,  1100, 8,    109,  11,   109,  12,   109,
      1101, 1,    109,  1,    109,  1,    110,  1,    110,  4,    110,  1108,
      8,    110,  11,   110,  12,   110,  1109, 1,    110,  1,    110,  1,
      111,  1,    111,  3,    111,  1116, 8,    111,  1,    112,  1,    112,
      3,    112,  1120, 8,    112,  1,    113,  1,    113,  3,    113,  1124,
      8,    113,  1,    114,  1,    114,  3,    114,  1128, 8,    114,  1,
      115,  1,    115,  1,    116,  1,    116,  1,    116,  1,    116,  1,
      116,  1,    116,  3,    116,  1138, 8,    116,  1,    117,  1,    117,
      1,    118,  1,    118,  1,    118,  5,    118,  1145, 8,    118,  10,
      118,  12,   118,  1148, 9,    118,  1,    119,  1,    119,  1,    119,
      5,    119,  1153, 8,    119,  10,   119,  12,   119,  1156, 9,    119,
      1,    120,  1,    120,  1,    121,  1,    121,  1,    121,  1,    121,
      1,    121,  1,    121,  1,    121,  1,    121,  1,    121,  1,    121,
      1,    121,  1,    121,  1,    121,  1,    121,  1,    121,  1,    121,
      1,    121,  1,    121,  3,    121,  1178, 8,    121,  1,    122,  1,
      122,  1,    123,  1,    123,  5,    123,  1184, 8,    123,  10,   123,
      12,   123,  1187, 9,    123,  1,    124,  1,    124,  1,    124,  1,
      124,  1,    124,  3,    124,  1194, 8,    124,  1,    125,  1,    125,
      1,    126,  1,    126,  1,    127,  1,    127,  3,    127,  1202, 8,
      127,  1,    127,  5,    127,  1205, 8,    127,  10,   127,  12,   127,
      1208, 9,    127,  1,    128,  1,    128,  5,    128,  1212, 8,    128,
      10,   128,  12,   128,  1215, 9,    128,  1,    129,  1,    129,  3,
      129,  1219, 8,    129,  1,    130,  1,    130,  1,    130,  1,    131,
      1,    131,  1,    131,  1,    132,  1,    132,  1,    132,  1,    132,
      1,    132,  1,    132,  1,    132,  3,    132,  1234, 8,    132,  1,
      133,  1,    133,  1,    133,  1,    133,  1,    133,  1,    133,  1,
      133,  3,    133,  1243, 8,    133,  1,    134,  1,    134,  1,    134,
      1,    134,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,
      1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,
      1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,
      1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,
      1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,
      1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,
      1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  3,    135,
      1289, 8,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  1,    135,  1,    135,  1,
      135,  1,    135,  1,    135,  1,    135,  3,    135,  1503, 8,    135,
      1,    136,  1,    136,  1,    136,  1,    136,  1,    136,  1,    136,
      1,    136,  3,    136,  1512, 8,    136,  1,    136,  1,    136,  1,
      137,  1,    137,  1,    137,  1,    137,  1,    137,  1,    138,  1,
      138,  1,    138,  1,    138,  1,    138,  1,    138,  1,    138,  3,
      138,  1528, 8,    138,  1,    138,  1,    138,  1,    139,  1,    139,
      1,    139,  1,    139,  1,    139,  1,    139,  1,    139,  1,    139,
      1,    139,  3,    139,  1541, 8,    139,  1,    139,  1,    139,  1,
      140,  1,    140,  1,    140,  1,    141,  1,    141,  1,    141,  1,
      141,  1,    142,  1,    142,  1,    142,  3,    142,  1555, 8,    142,
      1,    142,  1,    142,  3,    142,  1559, 8,    142,  1,    142,  1,
      142,  1,    142,  1,    142,  3,    142,  1565, 8,    142,  1,    142,
      1,    142,  1,    142,  1,    142,  1,    142,  1,    142,  3,    142,
      1573, 8,    142,  1,    142,  1,    142,  1,    142,  1,    142,  1,
      142,  1,    142,  3,    142,  1581, 8,    142,  1,    142,  1,    142,
      1,    142,  1,    142,  1,    142,  1,    142,  3,    142,  1589, 8,
      142,  1,    142,  1,    142,  1,    142,  1,    142,  1,    142,  1,
      142,  3,    142,  1597, 8,    142,  1,    142,  1,    142,  1,    142,
      1,    142,  1,    142,  1,    142,  3,    142,  1605, 8,    142,  1,
      142,  1,    142,  1,    142,  1,    142,  1,    142,  1,    142,  3,
      142,  1613, 8,    142,  1,    142,  1,    142,  1,    142,  1,    142,
      1,    142,  3,    142,  1620, 8,    142,  1,    142,  1,    142,  3,
      142,  1624, 8,    142,  1,    143,  1,    143,  3,    143,  1628, 8,
      143,  1,    144,  1,    144,  1,    144,  1,    144,  3,    144,  1634,
      8,    144,  1,    145,  1,    145,  1,    145,  3,    145,  1639, 8,
      145,  1,    146,  1,    146,  1,    147,  1,    147,  1,    148,  1,
      148,  1,    149,  1,    149,  1,    150,  1,    150,  1,    151,  3,
      151,  1652, 8,    151,  1,    151,  1,    151,  3,    151,  1656, 8,
      151,  1,    152,  1,    152,  3,    152,  1660, 8,    152,  1,    153,
      1,    153,  1,    154,  1,    154,  1,    155,  1,    155,  1,    156,
      1,    156,  1,    156,  0,    0,    157,  0,    2,    4,    6,    8,
      10,   12,   14,   16,   18,   20,   22,   24,   26,   28,   30,   32,
      34,   36,   38,   40,   42,   44,   46,   48,   50,   52,   54,   56,
      58,   60,   62,   64,   66,   68,   70,   72,   74,   76,   78,   80,
      82,   84,   86,   88,   90,   92,   94,   96,   98,   100,  102,  104,
      106,  108,  110,  112,  114,  116,  118,  120,  122,  124,  126,  128,
      130,  132,  134,  136,  138,  140,  142,  144,  146,  148,  150,  152,
      154,  156,  158,  160,  162,  164,  166,  168,  170,  172,  174,  176,
      178,  180,  182,  184,  186,  188,  190,  192,  194,  196,  198,  200,
      202,  204,  206,  208,  210,  212,  214,  216,  218,  220,  222,  224,
      226,  228,  230,  232,  234,  236,  238,  240,  242,  244,  246,  248,
      250,  252,  254,  256,  258,  260,  262,  264,  266,  268,  270,  272,
      274,  276,  278,  280,  282,  284,  286,  288,  290,  292,  294,  296,
      298,  300,  302,  304,  306,  308,  310,  312,  0,    10,   1,    0,
      33,   34,   1,    0,    47,   48,   2,    0,    1,    1,    13,   14,
      1,    0,    146,  147,  1,    0,    150,  152,  1,    0,    153,  155,
      1,    0,    156,  158,  1,    0,    28,   29,   1,    0,    160,  163,
      2,    0,    145,  145,  166,  166,  1788, 0,    316,  1,    0,    0,
      0,    2,    320,  1,    0,    0,    0,    4,    333,  1,    0,    0,
      0,    6,    336,  1,    0,    0,    0,    8,    339,  1,    0,    0,
      0,    10,   343,  1,    0,    0,    0,    12,   353,  1,    0,    0,
      0,    14,   358,  1,    0,    0,    0,    16,   372,  1,    0,    0,
      0,    18,   374,  1,    0,    0,    0,    20,   378,  1,    0,    0,
      0,    22,   382,  1,    0,    0,    0,    24,   408,  1,    0,    0,
      0,    26,   428,  1,    0,    0,    0,    28,   438,  1,    0,    0,
      0,    30,   443,  1,    0,    0,    0,    32,   445,  1,    0,    0,
      0,    34,   448,  1,    0,    0,    0,    36,   451,  1,    0,    0,
      0,    38,   456,  1,    0,    0,    0,    40,   467,  1,    0,    0,
      0,    42,   484,  1,    0,    0,    0,    44,   486,  1,    0,    0,
      0,    46,   492,  1,    0,    0,    0,    48,   496,  1,    0,    0,
      0,    50,   509,  1,    0,    0,    0,    52,   553,  1,    0,    0,
      0,    54,   555,  1,    0,    0,    0,    56,   558,  1,    0,    0,
      0,    58,   561,  1,    0,    0,    0,    60,   566,  1,    0,    0,
      0,    62,   568,  1,    0,    0,    0,    64,   596,  1,    0,    0,
      0,    66,   598,  1,    0,    0,    0,    68,   607,  1,    0,    0,
      0,    70,   613,  1,    0,    0,    0,    72,   619,  1,    0,    0,
      0,    74,   625,  1,    0,    0,    0,    76,   633,  1,    0,    0,
      0,    78,   641,  1,    0,    0,    0,    80,   649,  1,    0,    0,
      0,    82,   653,  1,    0,    0,    0,    84,   657,  1,    0,    0,
      0,    86,   663,  1,    0,    0,    0,    88,   681,  1,    0,    0,
      0,    90,   684,  1,    0,    0,    0,    92,   687,  1,    0,    0,
      0,    94,   698,  1,    0,    0,    0,    96,   700,  1,    0,    0,
      0,    98,   707,  1,    0,    0,    0,    100,  709,  1,    0,    0,
      0,    102,  713,  1,    0,    0,    0,    104,  718,  1,    0,    0,
      0,    106,  732,  1,    0,    0,    0,    108,  740,  1,    0,    0,
      0,    110,  751,  1,    0,    0,    0,    112,  759,  1,    0,    0,
      0,    114,  767,  1,    0,    0,    0,    116,  774,  1,    0,    0,
      0,    118,  789,  1,    0,    0,    0,    120,  791,  1,    0,    0,
      0,    122,  794,  1,    0,    0,    0,    124,  798,  1,    0,    0,
      0,    126,  805,  1,    0,    0,    0,    128,  812,  1,    0,    0,
      0,    130,  817,  1,    0,    0,    0,    132,  819,  1,    0,    0,
      0,    134,  838,  1,    0,    0,    0,    136,  858,  1,    0,    0,
      0,    138,  865,  1,    0,    0,    0,    140,  867,  1,    0,    0,
      0,    142,  870,  1,    0,    0,    0,    144,  878,  1,    0,    0,
      0,    146,  884,  1,    0,    0,    0,    148,  886,  1,    0,    0,
      0,    150,  904,  1,    0,    0,    0,    152,  918,  1,    0,    0,
      0,    154,  920,  1,    0,    0,    0,    156,  926,  1,    0,    0,
      0,    158,  939,  1,    0,    0,    0,    160,  942,  1,    0,    0,
      0,    162,  944,  1,    0,    0,    0,    164,  959,  1,    0,    0,
      0,    166,  961,  1,    0,    0,    0,    168,  969,  1,    0,    0,
      0,    170,  977,  1,    0,    0,    0,    172,  980,  1,    0,    0,
      0,    174,  982,  1,    0,    0,    0,    176,  992,  1,    0,    0,
      0,    178,  994,  1,    0,    0,    0,    180,  996,  1,    0,    0,
      0,    182,  999,  1,    0,    0,    0,    184,  1004, 1,    0,    0,
      0,    186,  1006, 1,    0,    0,    0,    188,  1014, 1,    0,    0,
      0,    190,  1016, 1,    0,    0,    0,    192,  1018, 1,    0,    0,
      0,    194,  1026, 1,    0,    0,    0,    196,  1034, 1,    0,    0,
      0,    198,  1041, 1,    0,    0,    0,    200,  1043, 1,    0,    0,
      0,    202,  1053, 1,    0,    0,    0,    204,  1068, 1,    0,    0,
      0,    206,  1077, 1,    0,    0,    0,    208,  1079, 1,    0,    0,
      0,    210,  1083, 1,    0,    0,    0,    212,  1085, 1,    0,    0,
      0,    214,  1091, 1,    0,    0,    0,    216,  1093, 1,    0,    0,
      0,    218,  1097, 1,    0,    0,    0,    220,  1105, 1,    0,    0,
      0,    222,  1115, 1,    0,    0,    0,    224,  1119, 1,    0,    0,
      0,    226,  1123, 1,    0,    0,    0,    228,  1127, 1,    0,    0,
      0,    230,  1129, 1,    0,    0,    0,    232,  1137, 1,    0,    0,
      0,    234,  1139, 1,    0,    0,    0,    236,  1141, 1,    0,    0,
      0,    238,  1149, 1,    0,    0,    0,    240,  1157, 1,    0,    0,
      0,    242,  1159, 1,    0,    0,    0,    244,  1179, 1,    0,    0,
      0,    246,  1181, 1,    0,    0,    0,    248,  1193, 1,    0,    0,
      0,    250,  1195, 1,    0,    0,    0,    252,  1197, 1,    0,    0,
      0,    254,  1201, 1,    0,    0,    0,    256,  1209, 1,    0,    0,
      0,    258,  1218, 1,    0,    0,    0,    260,  1220, 1,    0,    0,
      0,    262,  1223, 1,    0,    0,    0,    264,  1233, 1,    0,    0,
      0,    266,  1242, 1,    0,    0,    0,    268,  1244, 1,    0,    0,
      0,    270,  1502, 1,    0,    0,    0,    272,  1504, 1,    0,    0,
      0,    274,  1515, 1,    0,    0,    0,    276,  1520, 1,    0,    0,
      0,    278,  1531, 1,    0,    0,    0,    280,  1544, 1,    0,    0,
      0,    282,  1547, 1,    0,    0,    0,    284,  1623, 1,    0,    0,
      0,    286,  1625, 1,    0,    0,    0,    288,  1629, 1,    0,    0,
      0,    290,  1638, 1,    0,    0,    0,    292,  1640, 1,    0,    0,
      0,    294,  1642, 1,    0,    0,    0,    296,  1644, 1,    0,    0,
      0,    298,  1646, 1,    0,    0,    0,    300,  1648, 1,    0,    0,
      0,    302,  1651, 1,    0,    0,    0,    304,  1659, 1,    0,    0,
      0,    306,  1661, 1,    0,    0,    0,    308,  1663, 1,    0,    0,
      0,    310,  1665, 1,    0,    0,    0,    312,  1667, 1,    0,    0,
      0,    314,  317,  3,    2,    1,    0,    315,  317,  3,    62,   31,
      0,    316,  314,  1,    0,    0,    0,    316,  315,  1,    0,    0,
      0,    317,  318,  1,    0,    0,    0,    318,  319,  5,    0,    0,
      1,    319,  1,    1,    0,    0,    0,    320,  325,  3,    4,    2,
      0,    321,  326,  3,    10,   5,    0,    322,  326,  3,    22,   11,
      0,    323,  326,  3,    24,   12,   0,    324,  326,  3,    26,   13,
      0,    325,  321,  1,    0,    0,    0,    325,  322,  1,    0,    0,
      0,    325,  323,  1,    0,    0,    0,    325,  324,  1,    0,    0,
      0,    326,  327,  1,    0,    0,    0,    327,  328,  3,    60,   30,
      0,    328,  3,    1,    0,    0,    0,    329,  332,  3,    6,    3,
      0,    330,  332,  3,    8,    4,    0,    331,  329,  1,    0,    0,
      0,    331,  330,  1,    0,    0,    0,    332,  335,  1,    0,    0,
      0,    333,  331,  1,    0,    0,    0,    333,  334,  1,    0,    0,
      0,    334,  5,    1,    0,    0,    0,    335,  333,  1,    0,    0,
      0,    336,  337,  5,    30,   0,    0,    337,  338,  3,    308,  154,
      0,    338,  7,    1,    0,    0,    0,    339,  340,  5,    31,   0,
      0,    340,  341,  5,    143,  0,    0,    341,  342,  3,    308,  154,
      0,    342,  9,    1,    0,    0,    0,    343,  347,  3,    14,   7,
      0,    344,  346,  3,    28,   14,   0,    345,  344,  1,    0,    0,
      0,    346,  349,  1,    0,    0,    0,    347,  345,  1,    0,    0,
      0,    347,  348,  1,    0,    0,    0,    348,  350,  1,    0,    0,
      0,    349,  347,  1,    0,    0,    0,    350,  351,  3,    36,   18,
      0,    351,  352,  3,    38,   19,   0,    352,  11,   1,    0,    0,
      0,    353,  354,  3,    14,   7,    0,    354,  355,  3,    36,   18,
      0,    355,  356,  3,    38,   19,   0,    356,  357,  3,    60,   30,
      0,    357,  13,   1,    0,    0,    0,    358,  360,  5,    32,   0,
      0,    359,  361,  7,    0,    0,    0,    360,  359,  1,    0,    0,
      0,    360,  361,  1,    0,    0,    0,    361,  368,  1,    0,    0,
      0,    362,  364,  3,    16,   8,    0,    363,  362,  1,    0,    0,
      0,    364,  365,  1,    0,    0,    0,    365,  363,  1,    0,    0,
      0,    365,  366,  1,    0,    0,    0,    366,  369,  1,    0,    0,
      0,    367,  369,  5,    1,    0,    0,    368,  363,  1,    0,    0,
      0,    368,  367,  1,    0,    0,    0,    369,  15,   1,    0,    0,
      0,    370,  373,  3,    230,  115,  0,    371,  373,  3,    18,   9,
      0,    372,  370,  1,    0,    0,    0,    372,  371,  1,    0,    0,
      0,    373,  17,   1,    0,    0,    0,    374,  375,  5,    2,    0,
      0,    375,  376,  3,    20,   10,   0,    376,  377,  5,    3,    0,
      0,    377,  19,   1,    0,    0,    0,    378,  379,  3,    234,  117,
      0,    379,  380,  5,    35,   0,    0,    380,  381,  3,    230,  115,
      0,    381,  21,   1,    0,    0,    0,    382,  406,  5,    36,   0,
      0,    383,  387,  3,    154,  77,   0,    384,  386,  3,    28,   14,
      0,    385,  384,  1,    0,    0,    0,    386,  389,  1,    0,    0,
      0,    387,  385,  1,    0,    0,    0,    387,  388,  1,    0,    0,
      0,    388,  390,  1,    0,    0,    0,    389,  387,  1,    0,    0,
      0,    390,  391,  3,    36,   18,   0,    391,  392,  3,    38,   19,
      0,    392,  407,  1,    0,    0,    0,    393,  395,  3,    28,   14,
      0,    394,  393,  1,    0,    0,    0,    395,  398,  1,    0,    0,
      0,    396,  394,  1,    0,    0,    0,    396,  397,  1,    0,    0,
      0,    397,  399,  1,    0,    0,    0,    398,  396,  1,    0,    0,
      0,    399,  400,  5,    37,   0,    0,    400,  402,  5,    4,    0,
      0,    401,  403,  3,    108,  54,   0,    402,  401,  1,    0,    0,
      0,    402,  403,  1,    0,    0,    0,    403,  404,  1,    0,    0,
      0,    404,  405,  5,    5,    0,    0,    405,  407,  3,    38,   19,
      0,    406,  383,  1,    0,    0,    0,    406,  396,  1,    0,    0,
      0,    407,  23,   1,    0,    0,    0,    408,  415,  5,    38,   0,
      0,    409,  411,  3,    228,  114,  0,    410,  409,  1,    0,    0,
      0,    411,  412,  1,    0,    0,    0,    412,  410,  1,    0,    0,
      0,    412,  413,  1,    0,    0,    0,    413,  416,  1,    0,    0,
      0,    414,  416,  5,    1,    0,    0,    415,  410,  1,    0,    0,
      0,    415,  414,  1,    0,    0,    0,    416,  420,  1,    0,    0,
      0,    417,  419,  3,    28,   14,   0,    418,  417,  1,    0,    0,
      0,    419,  422,  1,    0,    0,    0,    420,  418,  1,    0,    0,
      0,    420,  421,  1,    0,    0,    0,    421,  424,  1,    0,    0,
      0,    422,  420,  1,    0,    0,    0,    423,  425,  3,    36,   18,
      0,    424,  423,  1,    0,    0,    0,    424,  425,  1,    0,    0,
      0,    425,  426,  1,    0,    0,    0,    426,  427,  3,    38,   19,
      0,    427,  25,   1,    0,    0,    0,    428,  432,  5,    39,   0,
      0,    429,  431,  3,    28,   14,   0,    430,  429,  1,    0,    0,
      0,    431,  434,  1,    0,    0,    0,    432,  430,  1,    0,    0,
      0,    432,  433,  1,    0,    0,    0,    433,  435,  1,    0,    0,
      0,    434,  432,  1,    0,    0,    0,    435,  436,  3,    36,   18,
      0,    436,  437,  3,    38,   19,   0,    437,  27,   1,    0,    0,
      0,    438,  441,  5,    40,   0,    0,    439,  442,  3,    30,   15,
      0,    440,  442,  3,    32,   16,   0,    441,  439,  1,    0,    0,
      0,    441,  440,  1,    0,    0,    0,    442,  29,   1,    0,    0,
      0,    443,  444,  3,    34,   17,   0,    444,  31,   1,    0,    0,
      0,    445,  446,  5,    41,   0,    0,    446,  447,  3,    34,   17,
      0,    447,  33,   1,    0,    0,    0,    448,  449,  3,    302,  151,
      0,    449,  35,   1,    0,    0,    0,    450,  452,  5,    37,   0,
      0,    451,  450,  1,    0,    0,    0,    451,  452,  1,    0,    0,
      0,    452,  453,  1,    0,    0,    0,    453,  454,  3,    110,  55,
      0,    454,  37,   1,    0,    0,    0,    455,  457,  3,    40,   20,
      0,    456,  455,  1,    0,    0,    0,    456,  457,  1,    0,    0,
      0,    457,  459,  1,    0,    0,    0,    458,  460,  3,    44,   22,
      0,    459,  458,  1,    0,    0,    0,    459,  460,  1,    0,    0,
      0,    460,  462,  1,    0,    0,    0,    461,  463,  3,    48,   24,
      0,    462,  461,  1,    0,    0,    0,    462,  463,  1,    0,    0,
      0,    463,  465,  1,    0,    0,    0,    464,  466,  3,    52,   26,
      0,    465,  464,  1,    0,    0,    0,    465,  466,  1,    0,    0,
      0,    466,  39,   1,    0,    0,    0,    467,  469,  5,    42,   0,
      0,    468,  470,  3,    42,   21,   0,    469,  468,  1,    0,    0,
      0,    470,  471,  1,    0,    0,    0,    471,  469,  1,    0,    0,
      0,    471,  472,  1,    0,    0,    0,    472,  41,   1,    0,    0,
      0,    473,  485,  3,    270,  135,  0,    474,  485,  3,    148,  74,
      0,    475,  476,  5,    2,    0,    0,    476,  479,  3,    234,  117,
      0,    477,  478,  5,    35,   0,    0,    478,  480,  3,    230,  115,
      0,    479,  477,  1,    0,    0,    0,    479,  480,  1,    0,    0,
      0,    480,  481,  1,    0,    0,    0,    481,  482,  5,    3,    0,
      0,    482,  485,  1,    0,    0,    0,    483,  485,  3,    230,  115,
      0,    484,  473,  1,    0,    0,    0,    484,  474,  1,    0,    0,
      0,    484,  475,  1,    0,    0,    0,    484,  483,  1,    0,    0,
      0,    485,  43,   1,    0,    0,    0,    486,  488,  5,    44,   0,
      0,    487,  489,  3,    46,   23,   0,    488,  487,  1,    0,    0,
      0,    489,  490,  1,    0,    0,    0,    490,  488,  1,    0,    0,
      0,    490,  491,  1,    0,    0,    0,    491,  45,   1,    0,    0,
      0,    492,  493,  3,    146,  73,   0,    493,  47,   1,    0,    0,
      0,    494,  497,  5,    45,   0,    0,    495,  497,  5,    46,   0,
      0,    496,  494,  1,    0,    0,    0,    496,  495,  1,    0,    0,
      0,    497,  499,  1,    0,    0,    0,    498,  500,  3,    50,   25,
      0,    499,  498,  1,    0,    0,    0,    500,  501,  1,    0,    0,
      0,    501,  499,  1,    0,    0,    0,    501,  502,  1,    0,    0,
      0,    502,  49,   1,    0,    0,    0,    503,  504,  7,    1,    0,
      0,    504,  510,  3,    268,  134,  0,    505,  508,  3,    146,  73,
      0,    506,  508,  3,    230,  115,  0,    507,  505,  1,    0,    0,
      0,    507,  506,  1,    0,    0,    0,    508,  510,  1,    0,    0,
      0,    509,  503,  1,    0,    0,    0,    509,  507,  1,    0,    0,
      0,    510,  51,   1,    0,    0,    0,    511,  513,  3,    54,   27,
      0,    512,  514,  3,    56,   28,   0,    513,  512,  1,    0,    0,
      0,    513,  514,  1,    0,    0,    0,    514,  516,  1,    0,    0,
      0,    515,  517,  3,    58,   29,   0,    516,  515,  1,    0,    0,
      0,    516,  517,  1,    0,    0,    0,    517,  554,  1,    0,    0,
      0,    518,  520,  3,    54,   27,   0,    519,  521,  3,    58,   29,
      0,    520,  519,  1,    0,    0,    0,    520,  521,  1,    0,    0,
      0,    521,  523,  1,    0,    0,    0,    522,  524,  3,    56,   28,
      0,    523,  522,  1,    0,    0,    0,    523,  524,  1,    0,    0,
      0,    524,  554,  1,    0,    0,    0,    525,  527,  3,    56,   28,
      0,    526,  528,  3,    54,   27,   0,    527,  526,  1,    0,    0,
      0,    527,  528,  1,    0,    0,    0,    528,  530,  1,    0,    0,
      0,    529,  531,  3,    58,   29,   0,    530,  529,  1,    0,    0,
      0,    530,  531,  1,    0,    0,    0,    531,  554,  1,    0,    0,
      0,    532,  534,  3,    56,   28,   0,    533,  535,  3,    58,   29,
      0,    534,  533,  1,    0,    0,    0,    534,  535,  1,    0,    0,
      0,    535,  537,  1,    0,    0,    0,    536,  538,  3,    54,   27,
      0,    537,  536,  1,    0,    0,    0,    537,  538,  1,    0,    0,
      0,    538,  554,  1,    0,    0,    0,    539,  541,  3,    58,   29,
      0,    540,  542,  3,    56,   28,   0,    541,  540,  1,    0,    0,
      0,    541,  542,  1,    0,    0,    0,    542,  544,  1,    0,    0,
      0,    543,  545,  3,    54,   27,   0,    544,  543,  1,    0,    0,
      0,    544,  545,  1,    0,    0,    0,    545,  554,  1,    0,    0,
      0,    546,  548,  3,    58,   29,   0,    547,  549,  3,    54,   27,
      0,    548,  547,  1,    0,    0,    0,    548,  549,  1,    0,    0,
      0,    549,  551,  1,    0,    0,    0,    550,  552,  3,    56,   28,
      0,    551,  550,  1,    0,    0,    0,    551,  552,  1,    0,    0,
      0,    552,  554,  1,    0,    0,    0,    553,  511,  1,    0,    0,
      0,    553,  518,  1,    0,    0,    0,    553,  525,  1,    0,    0,
      0,    553,  532,  1,    0,    0,    0,    553,  539,  1,    0,    0,
      0,    553,  546,  1,    0,    0,    0,    554,  53,   1,    0,    0,
      0,    555,  556,  5,    49,   0,    0,    556,  557,  3,    208,  104,
      0,    557,  55,   1,    0,    0,    0,    558,  559,  5,    50,   0,
      0,    559,  560,  3,    208,  104,  0,    560,  57,   1,    0,    0,
      0,    561,  562,  5,    51,   0,    0,    562,  563,  3,    208,  104,
      0,    563,  59,   1,    0,    0,    0,    564,  565,  5,    52,   0,
      0,    565,  567,  3,    130,  65,   0,    566,  564,  1,    0,    0,
      0,    566,  567,  1,    0,    0,    0,    567,  61,   1,    0,    0,
      0,    568,  583,  3,    4,    2,    0,    569,  576,  3,    64,   32,
      0,    570,  571,  5,    6,    0,    0,    571,  572,  3,    4,    2,
      0,    572,  573,  3,    64,   32,   0,    573,  575,  1,    0,    0,
      0,    574,  570,  1,    0,    0,    0,    575,  578,  1,    0,    0,
      0,    576,  574,  1,    0,    0,    0,    576,  577,  1,    0,    0,
      0,    577,  581,  1,    0,    0,    0,    578,  576,  1,    0,    0,
      0,    579,  580,  5,    6,    0,    0,    580,  582,  3,    4,    2,
      0,    581,  579,  1,    0,    0,    0,    581,  582,  1,    0,    0,
      0,    582,  584,  1,    0,    0,    0,    583,  569,  1,    0,    0,
      0,    583,  584,  1,    0,    0,    0,    584,  63,   1,    0,    0,
      0,    585,  597,  3,    66,   33,   0,    586,  597,  3,    68,   34,
      0,    587,  597,  3,    70,   35,   0,    588,  597,  3,    74,   37,
      0,    589,  597,  3,    76,   38,   0,    590,  597,  3,    78,   39,
      0,    591,  597,  3,    72,   36,   0,    592,  597,  3,    80,   40,
      0,    593,  597,  3,    82,   41,   0,    594,  597,  3,    84,   42,
      0,    595,  597,  3,    86,   43,   0,    596,  585,  1,    0,    0,
      0,    596,  586,  1,    0,    0,    0,    596,  587,  1,    0,    0,
      0,    596,  588,  1,    0,    0,    0,    596,  589,  1,    0,    0,
      0,    596,  590,  1,    0,    0,    0,    596,  591,  1,    0,    0,
      0,    596,  592,  1,    0,    0,    0,    596,  593,  1,    0,    0,
      0,    596,  594,  1,    0,    0,    0,    596,  595,  1,    0,    0,
      0,    597,  65,   1,    0,    0,    0,    598,  600,  5,    53,   0,
      0,    599,  601,  5,    54,   0,    0,    600,  599,  1,    0,    0,
      0,    600,  601,  1,    0,    0,    0,    601,  602,  1,    0,    0,
      0,    602,  605,  3,    302,  151,  0,    603,  604,  5,    55,   0,
      0,    604,  606,  3,    96,   48,   0,    605,  603,  1,    0,    0,
      0,    605,  606,  1,    0,    0,    0,    606,  67,   1,    0,    0,
      0,    607,  609,  5,    56,   0,    0,    608,  610,  5,    54,   0,
      0,    609,  608,  1,    0,    0,    0,    609,  610,  1,    0,    0,
      0,    610,  611,  1,    0,    0,    0,    611,  612,  3,    98,   49,
      0,    612,  69,   1,    0,    0,    0,    613,  615,  5,    57,   0,
      0,    614,  616,  5,    54,   0,    0,    615,  614,  1,    0,    0,
      0,    615,  616,  1,    0,    0,    0,    616,  617,  1,    0,    0,
      0,    617,  618,  3,    98,   49,   0,    618,  71,   1,    0,    0,
      0,    619,  621,  5,    58,   0,    0,    620,  622,  5,    54,   0,
      0,    621,  620,  1,    0,    0,    0,    621,  622,  1,    0,    0,
      0,    622,  623,  1,    0,    0,    0,    623,  624,  3,    96,   48,
      0,    624,  73,   1,    0,    0,    0,    625,  627,  5,    59,   0,
      0,    626,  628,  5,    54,   0,    0,    627,  626,  1,    0,    0,
      0,    627,  628,  1,    0,    0,    0,    628,  629,  1,    0,    0,
      0,    629,  630,  3,    94,   47,   0,    630,  631,  5,    60,   0,
      0,    631,  632,  3,    94,   47,   0,    632,  75,   1,    0,    0,
      0,    633,  635,  5,    62,   0,    0,    634,  636,  5,    54,   0,
      0,    635,  634,  1,    0,    0,    0,    635,  636,  1,    0,    0,
      0,    636,  637,  1,    0,    0,    0,    637,  638,  3,    94,   47,
      0,    638,  639,  5,    60,   0,    0,    639,  640,  3,    94,   47,
      0,    640,  77,   1,    0,    0,    0,    641,  643,  5,    63,   0,
      0,    642,  644,  5,    54,   0,    0,    643,  642,  1,    0,    0,
      0,    643,  644,  1,    0,    0,    0,    644,  645,  1,    0,    0,
      0,    645,  646,  3,    94,   47,   0,    646,  647,  5,    60,   0,
      0,    647,  648,  3,    94,   47,   0,    648,  79,   1,    0,    0,
      0,    649,  650,  5,    64,   0,    0,    650,  651,  5,    61,   0,
      0,    651,  652,  3,    102,  51,   0,    652,  81,   1,    0,    0,
      0,    653,  654,  5,    65,   0,    0,    654,  655,  5,    61,   0,
      0,    655,  656,  3,    102,  51,   0,    656,  83,   1,    0,    0,
      0,    657,  658,  5,    65,   0,    0,    658,  659,  5,    37,   0,
      0,    659,  660,  3,    100,  50,   0,    660,  85,   1,    0,    0,
      0,    661,  662,  5,    66,   0,    0,    662,  664,  3,    302,  151,
      0,    663,  661,  1,    0,    0,    0,    663,  664,  1,    0,    0,
      0,    664,  670,  1,    0,    0,    0,    665,  667,  3,    88,   44,
      0,    666,  668,  3,    90,   45,   0,    667,  666,  1,    0,    0,
      0,    667,  668,  1,    0,    0,    0,    668,  671,  1,    0,    0,
      0,    669,  671,  3,    90,   45,   0,    670,  665,  1,    0,    0,
      0,    670,  669,  1,    0,    0,    0,    671,  675,  1,    0,    0,
      0,    672,  674,  3,    92,   46,   0,    673,  672,  1,    0,    0,
      0,    674,  677,  1,    0,    0,    0,    675,  673,  1,    0,    0,
      0,    675,  676,  1,    0,    0,    0,    676,  678,  1,    0,    0,
      0,    677,  675,  1,    0,    0,    0,    678,  679,  5,    37,   0,
      0,    679,  680,  3,    110,  55,   0,    680,  87,   1,    0,    0,
      0,    681,  682,  5,    65,   0,    0,    682,  683,  3,    100,  50,
      0,    683,  89,   1,    0,    0,    0,    684,  685,  5,    64,   0,
      0,    685,  686,  3,    100,  50,   0,    686,  91,   1,    0,    0,
      0,    687,  691,  5,    67,   0,    0,    688,  692,  3,    302,  151,
      0,    689,  690,  5,    41,   0,    0,    690,  692,  3,    302,  151,
      0,    691,  688,  1,    0,    0,    0,    691,  689,  1,    0,    0,
      0,    692,  93,   1,    0,    0,    0,    693,  699,  5,    68,   0,
      0,    694,  696,  5,    69,   0,    0,    695,  694,  1,    0,    0,
      0,    695,  696,  1,    0,    0,    0,    696,  697,  1,    0,    0,
      0,    697,  699,  3,    302,  151,  0,    698,  693,  1,    0,    0,
      0,    698,  695,  1,    0,    0,    0,    699,  95,   1,    0,    0,
      0,    700,  701,  5,    69,   0,    0,    701,  702,  3,    302,  151,
      0,    702,  97,   1,    0,    0,    0,    703,  708,  3,    96,   48,
      0,    704,  708,  5,    68,   0,    0,    705,  708,  5,    41,   0,
      0,    706,  708,  5,    70,   0,    0,    707,  703,  1,    0,    0,
      0,    707,  704,  1,    0,    0,    0,    707,  705,  1,    0,    0,
      0,    707,  706,  1,    0,    0,    0,    708,  99,   1,    0,    0,
      0,    709,  710,  5,    4,    0,    0,    710,  711,  3,    104,  52,
      0,    711,  712,  5,    5,    0,    0,    712,  101,  1,    0,    0,
      0,    713,  714,  5,    4,    0,    0,    714,  715,  3,    104,  52,
      0,    715,  716,  5,    5,    0,    0,    716,  103,  1,    0,    0,
      0,    717,  719,  3,    108,  54,   0,    718,  717,  1,    0,    0,
      0,    718,  719,  1,    0,    0,    0,    719,  729,  1,    0,    0,
      0,    720,  722,  3,    106,  53,   0,    721,  723,  5,    7,    0,
      0,    722,  721,  1,    0,    0,    0,    722,  723,  1,    0,    0,
      0,    723,  725,  1,    0,    0,    0,    724,  726,  3,    108,  54,
      0,    725,  724,  1,    0,    0,    0,    725,  726,  1,    0,    0,
      0,    726,  728,  1,    0,    0,    0,    727,  720,  1,    0,    0,
      0,    728,  731,  1,    0,    0,    0,    729,  727,  1,    0,    0,
      0,    729,  730,  1,    0,    0,    0,    730,  105,  1,    0,    0,
      0,    731,  729,  1,    0,    0,    0,    732,  733,  5,    69,   0,
      0,    733,  734,  3,    228,  114,  0,    734,  736,  5,    4,    0,
      0,    735,  737,  3,    108,  54,   0,    736,  735,  1,    0,    0,
      0,    736,  737,  1,    0,    0,    0,    737,  738,  1,    0,    0,
      0,    738,  739,  5,    5,    0,    0,    739,  107,  1,    0,    0,
      0,    740,  745,  3,    158,  79,   0,    741,  742,  5,    7,    0,
      0,    742,  744,  3,    158,  79,   0,    743,  741,  1,    0,    0,
      0,    744,  747,  1,    0,    0,    0,    745,  743,  1,    0,    0,
      0,    745,  746,  1,    0,    0,    0,    746,  749,  1,    0,    0,
      0,    747,  745,  1,    0,    0,    0,    748,  750,  5,    7,    0,
      0,    749,  748,  1,    0,    0,    0,    749,  750,  1,    0,    0,
      0,    750,  109,  1,    0,    0,    0,    751,  754,  5,    4,    0,
      0,    752,  755,  3,    12,   6,    0,    753,  755,  3,    112,  56,
      0,    754,  752,  1,    0,    0,    0,    754,  753,  1,    0,    0,
      0,    755,  756,  1,    0,    0,    0,    756,  757,  5,    5,    0,
      0,    757,  111,  1,    0,    0,    0,    758,  760,  3,    116,  58,
      0,    759,  758,  1,    0,    0,    0,    759,  760,  1,    0,    0,
      0,    760,  764,  1,    0,    0,    0,    761,  763,  3,    114,  57,
      0,    762,  761,  1,    0,    0,    0,    763,  766,  1,    0,    0,
      0,    764,  762,  1,    0,    0,    0,    764,  765,  1,    0,    0,
      0,    765,  113,  1,    0,    0,    0,    766,  764,  1,    0,    0,
      0,    767,  769,  3,    118,  59,   0,    768,  770,  5,    7,    0,
      0,    769,  768,  1,    0,    0,    0,    769,  770,  1,    0,    0,
      0,    770,  772,  1,    0,    0,    0,    771,  773,  3,    116,  58,
      0,    772,  771,  1,    0,    0,    0,    772,  773,  1,    0,    0,
      0,    773,  115,  1,    0,    0,    0,    774,  779,  3,    170,  85,
      0,    775,  777,  5,    7,    0,    0,    776,  778,  3,    116,  58,
      0,    777,  776,  1,    0,    0,    0,    777,  778,  1,    0,    0,
      0,    778,  780,  1,    0,    0,    0,    779,  775,  1,    0,    0,
      0,    779,  780,  1,    0,    0,    0,    780,  117,  1,    0,    0,
      0,    781,  790,  3,    142,  71,   0,    782,  790,  3,    120,  60,
      0,    783,  790,  3,    140,  70,   0,    784,  790,  3,    122,  61,
      0,    785,  790,  3,    124,  62,   0,    786,  790,  3,    144,  72,
      0,    787,  790,  3,    126,  63,   0,    788,  790,  3,    128,  64,
      0,    789,  781,  1,    0,    0,    0,    789,  782,  1,    0,    0,
      0,    789,  783,  1,    0,    0,    0,    789,  784,  1,    0,    0,
      0,    789,  785,  1,    0,    0,    0,    789,  786,  1,    0,    0,
      0,    789,  787,  1,    0,    0,    0,    789,  788,  1,    0,    0,
      0,    790,  119,  1,    0,    0,    0,    791,  792,  5,    71,   0,
      0,    792,  793,  3,    110,  55,   0,    793,  121,  1,    0,    0,
      0,    794,  795,  5,    69,   0,    0,    795,  796,  3,    228,  114,
      0,    796,  797,  3,    110,  55,   0,    797,  123,  1,    0,    0,
      0,    798,  800,  5,    72,   0,    0,    799,  801,  5,    54,   0,
      0,    800,  799,  1,    0,    0,    0,    800,  801,  1,    0,    0,
      0,    801,  802,  1,    0,    0,    0,    802,  803,  3,    228,  114,
      0,    803,  804,  3,    110,  55,   0,    804,  125,  1,    0,    0,
      0,    805,  806,  5,    73,   0,    0,    806,  807,  5,    2,    0,
      0,    807,  808,  3,    234,  117,  0,    808,  809,  5,    35,   0,
      0,    809,  810,  3,    230,  115,  0,    810,  811,  5,    3,    0,
      0,    811,  127,  1,    0,    0,    0,    812,  813,  5,    52,   0,
      0,    813,  814,  3,    130,  65,   0,    814,  129,  1,    0,    0,
      0,    815,  818,  3,    132,  66,   0,    816,  818,  3,    134,  67,
      0,    817,  815,  1,    0,    0,    0,    817,  816,  1,    0,    0,
      0,    818,  131,  1,    0,    0,    0,    819,  820,  3,    230,  115,
      0,    820,  824,  5,    4,    0,    0,    821,  823,  3,    138,  69,
      0,    822,  821,  1,    0,    0,    0,    823,  826,  1,    0,    0,
      0,    824,  822,  1,    0,    0,    0,    824,  825,  1,    0,    0,
      0,    825,  827,  1,    0,    0,    0,    826,  824,  1,    0,    0,
      0,    827,  828,  5,    5,    0,    0,    828,  133,  1,    0,    0,
      0,    829,  839,  5,    165,  0,    0,    830,  834,  5,    2,    0,
      0,    831,  833,  3,    230,  115,  0,    832,  831,  1,    0,    0,
      0,    833,  836,  1,    0,    0,    0,    834,  832,  1,    0,    0,
      0,    834,  835,  1,    0,    0,    0,    835,  837,  1,    0,    0,
      0,    836,  834,  1,    0,    0,    0,    837,  839,  5,    3,    0,
      0,    838,  829,  1,    0,    0,    0,    838,  830,  1,    0,    0,
      0,    839,  840,  1,    0,    0,    0,    840,  844,  5,    4,    0,
      0,    841,  843,  3,    136,  68,   0,    842,  841,  1,    0,    0,
      0,    843,  846,  1,    0,    0,    0,    844,  842,  1,    0,    0,
      0,    844,  845,  1,    0,    0,    0,    845,  847,  1,    0,    0,
      0,    846,  844,  1,    0,    0,    0,    847,  848,  5,    5,    0,
      0,    848,  135,  1,    0,    0,    0,    849,  853,  5,    2,    0,
      0,    850,  852,  3,    138,  69,   0,    851,  850,  1,    0,    0,
      0,    852,  855,  1,    0,    0,    0,    853,  851,  1,    0,    0,
      0,    853,  854,  1,    0,    0,    0,    854,  856,  1,    0,    0,
      0,    855,  853,  1,    0,    0,    0,    856,  859,  5,    3,    0,
      0,    857,  859,  5,    165,  0,    0,    858,  849,  1,    0,    0,
      0,    858,  857,  1,    0,    0,    0,    859,  137,  1,    0,    0,
      0,    860,  866,  3,    302,  151,  0,    861,  866,  3,    288,  144,
      0,    862,  866,  3,    290,  145,  0,    863,  866,  3,    298,  149,
      0,    864,  866,  5,    74,   0,    0,    865,  860,  1,    0,    0,
      0,    865,  861,  1,    0,    0,    0,    865,  862,  1,    0,    0,
      0,    865,  863,  1,    0,    0,    0,    865,  864,  1,    0,    0,
      0,    866,  139,  1,    0,    0,    0,    867,  868,  5,    75,   0,
      0,    868,  869,  3,    110,  55,   0,    869,  141,  1,    0,    0,
      0,    870,  875,  3,    110,  55,   0,    871,  872,  5,    76,   0,
      0,    872,  874,  3,    110,  55,   0,    873,  871,  1,    0,    0,
      0,    874,  877,  1,    0,    0,    0,    875,  873,  1,    0,    0,
      0,    875,  876,  1,    0,    0,    0,    876,  143,  1,    0,    0,
      0,    877,  875,  1,    0,    0,    0,    878,  879,  5,    77,   0,
      0,    879,  880,  3,    146,  73,   0,    880,  145,  1,    0,    0,
      0,    881,  885,  3,    268,  134,  0,    882,  885,  3,    270,  135,
      0,    883,  885,  3,    148,  74,   0,    884,  881,  1,    0,    0,
      0,    884,  882,  1,    0,    0,    0,    884,  883,  1,    0,    0,
      0,    885,  147,  1,    0,    0,    0,    886,  887,  3,    302,  151,
      0,    887,  888,  3,    150,  75,   0,    888,  149,  1,    0,    0,
      0,    889,  905,  5,    165,  0,    0,    890,  892,  5,    2,    0,
      0,    891,  893,  5,    33,   0,    0,    892,  891,  1,    0,    0,
      0,    892,  893,  1,    0,    0,    0,    893,  894,  1,    0,    0,
      0,    894,  899,  3,    234,  117,  0,    895,  896,  5,    8,    0,
      0,    896,  898,  3,    234,  117,  0,    897,  895,  1,    0,    0,
      0,    898,  901,  1,    0,    0,    0,    899,  897,  1,    0,    0,
      0,    899,  900,  1,    0,    0,    0,    900,  902,  1,    0,    0,
      0,    901,  899,  1,    0,    0,    0,    902,  903,  5,    3,    0,
      0,    903,  905,  1,    0,    0,    0,    904,  889,  1,    0,    0,
      0,    904,  890,  1,    0,    0,    0,    905,  151,  1,    0,    0,
      0,    906,  919,  5,    165,  0,    0,    907,  908,  5,    2,    0,
      0,    908,  913,  3,    234,  117,  0,    909,  910,  5,    8,    0,
      0,    910,  912,  3,    234,  117,  0,    911,  909,  1,    0,    0,
      0,    912,  915,  1,    0,    0,    0,    913,  911,  1,    0,    0,
      0,    913,  914,  1,    0,    0,    0,    914,  916,  1,    0,    0,
      0,    915,  913,  1,    0,    0,    0,    916,  917,  5,    3,    0,
      0,    917,  919,  1,    0,    0,    0,    918,  906,  1,    0,    0,
      0,    918,  907,  1,    0,    0,    0,    919,  153,  1,    0,    0,
      0,    920,  922,  5,    4,    0,    0,    921,  923,  3,    156,  78,
      0,    922,  921,  1,    0,    0,    0,    922,  923,  1,    0,    0,
      0,    923,  924,  1,    0,    0,    0,    924,  925,  5,    5,    0,
      0,    925,  155,  1,    0,    0,    0,    926,  931,  3,    158,  79,
      0,    927,  929,  5,    7,    0,    0,    928,  930,  3,    156,  78,
      0,    929,  928,  1,    0,    0,    0,    929,  930,  1,    0,    0,
      0,    930,  932,  1,    0,    0,    0,    931,  927,  1,    0,    0,
      0,    931,  932,  1,    0,    0,    0,    932,  157,  1,    0,    0,
      0,    933,  934,  3,    226,  113,  0,    934,  935,  3,    162,  81,
      0,    935,  940,  1,    0,    0,    0,    936,  937,  3,    210,  105,
      0,    937,  938,  3,    160,  80,   0,    938,  940,  1,    0,    0,
      0,    939,  933,  1,    0,    0,    0,    939,  936,  1,    0,    0,
      0,    940,  159,  1,    0,    0,    0,    941,  943,  3,    162,  81,
      0,    942,  941,  1,    0,    0,    0,    942,  943,  1,    0,    0,
      0,    943,  161,  1,    0,    0,    0,    944,  945,  3,    164,  82,
      0,    945,  954,  3,    166,  83,   0,    946,  950,  5,    6,    0,
      0,    947,  948,  3,    164,  82,   0,    948,  949,  3,    166,  83,
      0,    949,  951,  1,    0,    0,    0,    950,  947,  1,    0,    0,
      0,    950,  951,  1,    0,    0,    0,    951,  953,  1,    0,    0,
      0,    952,  946,  1,    0,    0,    0,    953,  956,  1,    0,    0,
      0,    954,  952,  1,    0,    0,    0,    954,  955,  1,    0,    0,
      0,    955,  163,  1,    0,    0,    0,    956,  954,  1,    0,    0,
      0,    957,  960,  3,    228,  114,  0,    958,  960,  5,    9,    0,
      0,    959,  957,  1,    0,    0,    0,    959,  958,  1,    0,    0,
      0,    960,  165,  1,    0,    0,    0,    961,  966,  3,    168,  84,
      0,    962,  963,  5,    8,    0,    0,    963,  965,  3,    168,  84,
      0,    964,  962,  1,    0,    0,    0,    965,  968,  1,    0,    0,
      0,    966,  964,  1,    0,    0,    0,    966,  967,  1,    0,    0,
      0,    967,  167,  1,    0,    0,    0,    968,  966,  1,    0,    0,
      0,    969,  970,  3,    222,  111,  0,    970,  169,  1,    0,    0,
      0,    971,  972,  3,    226,  113,  0,    972,  973,  3,    174,  87,
      0,    973,  978,  1,    0,    0,    0,    974,  975,  3,    214,  107,
      0,    975,  976,  3,    172,  86,   0,    976,  978,  1,    0,    0,
      0,    977,  971,  1,    0,    0,    0,    977,  974,  1,    0,    0,
      0,    978,  171,  1,    0,    0,    0,    979,  981,  3,    174,  87,
      0,    980,  979,  1,    0,    0,    0,    980,  981,  1,    0,    0,
      0,    981,  173,  1,    0,    0,    0,    982,  989,  3,    182,  91,
      0,    983,  985,  5,    6,    0,    0,    984,  986,  3,    180,  90,
      0,    985,  984,  1,    0,    0,    0,    985,  986,  1,    0,    0,
      0,    986,  988,  1,    0,    0,    0,    987,  983,  1,    0,    0,
      0,    988,  991,  1,    0,    0,    0,    989,  987,  1,    0,    0,
      0,    989,  990,  1,    0,    0,    0,    990,  175,  1,    0,    0,
      0,    991,  989,  1,    0,    0,    0,    992,  993,  3,    190,  95,
      0,    993,  177,  1,    0,    0,    0,    994,  995,  3,    230,  115,
      0,    995,  179,  1,    0,    0,    0,    996,  997,  3,    184,  92,
      0,    997,  998,  3,    166,  83,   0,    998,  181,  1,    0,    0,
      0,    999,  1000, 3,    184,  92,   0,    1000, 1001, 3,    186,  93,
      0,    1001, 183,  1,    0,    0,    0,    1002, 1005, 3,    176,  88,
      0,    1003, 1005, 3,    178,  89,   0,    1004, 1002, 1,    0,    0,
      0,    1004, 1003, 1,    0,    0,    0,    1005, 185,  1,    0,    0,
      0,    1006, 1011, 3,    188,  94,   0,    1007, 1008, 5,    8,    0,
      0,    1008, 1010, 3,    188,  94,   0,    1009, 1007, 1,    0,    0,
      0,    1010, 1013, 1,    0,    0,    0,    1011, 1009, 1,    0,    0,
      0,    1011, 1012, 1,    0,    0,    0,    1012, 187,  1,    0,    0,
      0,    1013, 1011, 1,    0,    0,    0,    1014, 1015, 3,    224,  112,
      0,    1015, 189,  1,    0,    0,    0,    1016, 1017, 3,    192,  96,
      0,    1017, 191,  1,    0,    0,    0,    1018, 1023, 3,    194,  97,
      0,    1019, 1020, 5,    10,   0,    0,    1020, 1022, 3,    194,  97,
      0,    1021, 1019, 1,    0,    0,    0,    1022, 1025, 1,    0,    0,
      0,    1023, 1021, 1,    0,    0,    0,    1023, 1024, 1,    0,    0,
      0,    1024, 193,  1,    0,    0,    0,    1025, 1023, 1,    0,    0,
      0,    1026, 1031, 3,    198,  99,   0,    1027, 1028, 5,    11,   0,
      0,    1028, 1030, 3,    198,  99,   0,    1029, 1027, 1,    0,    0,
      0,    1030, 1033, 1,    0,    0,    0,    1031, 1029, 1,    0,    0,
      0,    1031, 1032, 1,    0,    0,    0,    1032, 195,  1,    0,    0,
      0,    1033, 1031, 1,    0,    0,    0,    1034, 1036, 3,    202,  101,
      0,    1035, 1037, 3,    200,  100,  0,    1036, 1035, 1,    0,    0,
      0,    1036, 1037, 1,    0,    0,    0,    1037, 197,  1,    0,    0,
      0,    1038, 1042, 3,    196,  98,   0,    1039, 1040, 5,    12,   0,
      0,    1040, 1042, 3,    196,  98,   0,    1041, 1038, 1,    0,    0,
      0,    1041, 1039, 1,    0,    0,    0,    1042, 199,  1,    0,    0,
      0,    1043, 1044, 7,    2,    0,    0,    1044, 201,  1,    0,    0,
      0,    1045, 1054, 3,    302,  151,  0,    1046, 1054, 5,    9,    0,
      0,    1047, 1048, 5,    15,   0,    0,    1048, 1054, 3,    204,  102,
      0,    1049, 1050, 5,    2,    0,    0,    1050, 1051, 3,    190,  95,
      0,    1051, 1052, 5,    3,    0,    0,    1052, 1054, 1,    0,    0,
      0,    1053, 1045, 1,    0,    0,    0,    1053, 1046, 1,    0,    0,
      0,    1053, 1047, 1,    0,    0,    0,    1053, 1049, 1,    0,    0,
      0,    1054, 203,  1,    0,    0,    0,    1055, 1069, 3,    206,  103,
      0,    1056, 1065, 5,    2,    0,    0,    1057, 1062, 3,    206,  103,
      0,    1058, 1059, 5,    10,   0,    0,    1059, 1061, 3,    206,  103,
      0,    1060, 1058, 1,    0,    0,    0,    1061, 1064, 1,    0,    0,
      0,    1062, 1060, 1,    0,    0,    0,    1062, 1063, 1,    0,    0,
      0,    1063, 1066, 1,    0,    0,    0,    1064, 1062, 1,    0,    0,
      0,    1065, 1057, 1,    0,    0,    0,    1065, 1066, 1,    0,    0,
      0,    1066, 1067, 1,    0,    0,    0,    1067, 1069, 5,    3,    0,
      0,    1068, 1055, 1,    0,    0,    0,    1068, 1056, 1,    0,    0,
      0,    1069, 205,  1,    0,    0,    0,    1070, 1078, 3,    302,  151,
      0,    1071, 1078, 5,    9,    0,    0,    1072, 1075, 5,    12,   0,
      0,    1073, 1076, 3,    302,  151,  0,    1074, 1076, 5,    9,    0,
      0,    1075, 1073, 1,    0,    0,    0,    1075, 1074, 1,    0,    0,
      0,    1076, 1078, 1,    0,    0,    0,    1077, 1070, 1,    0,    0,
      0,    1077, 1071, 1,    0,    0,    0,    1077, 1072, 1,    0,    0,
      0,    1078, 207,  1,    0,    0,    0,    1079, 1080, 5,    150,  0,
      0,    1080, 209,  1,    0,    0,    0,    1081, 1084, 3,    218,  109,
      0,    1082, 1084, 3,    212,  106,  0,    1083, 1081, 1,    0,    0,
      0,    1083, 1082, 1,    0,    0,    0,    1084, 211,  1,    0,    0,
      0,    1085, 1086, 5,    16,   0,    0,    1086, 1087, 3,    162,  81,
      0,    1087, 1088, 5,    17,   0,    0,    1088, 213,  1,    0,    0,
      0,    1089, 1092, 3,    220,  110,  0,    1090, 1092, 3,    216,  108,
      0,    1091, 1089, 1,    0,    0,    0,    1091, 1090, 1,    0,    0,
      0,    1092, 215,  1,    0,    0,    0,    1093, 1094, 5,    16,   0,
      0,    1094, 1095, 3,    174,  87,   0,    1095, 1096, 5,    17,   0,
      0,    1096, 217,  1,    0,    0,    0,    1097, 1099, 5,    2,    0,
      0,    1098, 1100, 3,    222,  111,  0,    1099, 1098, 1,    0,    0,
      0,    1100, 1101, 1,    0,    0,    0,    1101, 1099, 1,    0,    0,
      0,    1101, 1102, 1,    0,    0,    0,    1102, 1103, 1,    0,    0,
      0,    1103, 1104, 5,    3,    0,    0,    1104, 219,  1,    0,    0,
      0,    1105, 1107, 5,    2,    0,    0,    1106, 1108, 3,    224,  112,
      0,    1107, 1106, 1,    0,    0,    0,    1108, 1109, 1,    0,    0,
      0,    1109, 1107, 1,    0,    0,    0,    1109, 1110, 1,    0,    0,
      0,    1110, 1111, 1,    0,    0,    0,    1111, 1112, 5,    3,    0,
      0,    1112, 221,  1,    0,    0,    0,    1113, 1116, 3,    226,  113,
      0,    1114, 1116, 3,    210,  105,  0,    1115, 1113, 1,    0,    0,
      0,    1115, 1114, 1,    0,    0,    0,    1116, 223,  1,    0,    0,
      0,    1117, 1120, 3,    226,  113,  0,    1118, 1120, 3,    214,  107,
      0,    1119, 1117, 1,    0,    0,    0,    1119, 1118, 1,    0,    0,
      0,    1120, 225,  1,    0,    0,    0,    1121, 1124, 3,    230,  115,
      0,    1122, 1124, 3,    232,  116,  0,    1123, 1121, 1,    0,    0,
      0,    1123, 1122, 1,    0,    0,    0,    1124, 227,  1,    0,    0,
      0,    1125, 1128, 3,    230,  115,  0,    1126, 1128, 3,    302,  151,
      0,    1127, 1125, 1,    0,    0,    0,    1127, 1126, 1,    0,    0,
      0,    1128, 229,  1,    0,    0,    0,    1129, 1130, 7,    3,    0,
      0,    1130, 231,  1,    0,    0,    0,    1131, 1138, 3,    302,  151,
      0,    1132, 1138, 3,    288,  144,  0,    1133, 1138, 3,    290,  145,
      0,    1134, 1138, 3,    298,  149,  0,    1135, 1138, 3,    306,  153,
      0,    1136, 1138, 5,    165,  0,    0,    1137, 1131, 1,    0,    0,
      0,    1137, 1132, 1,    0,    0,    0,    1137, 1133, 1,    0,    0,
      0,    1137, 1134, 1,    0,    0,    0,    1137, 1135, 1,    0,    0,
      0,    1137, 1136, 1,    0,    0,    0,    1138, 233,  1,    0,    0,
      0,    1139, 1140, 3,    236,  118,  0,    1140, 235,  1,    0,    0,
      0,    1141, 1146, 3,    238,  119,  0,    1142, 1143, 5,    18,   0,
      0,    1143, 1145, 3,    238,  119,  0,    1144, 1142, 1,    0,    0,
      0,    1145, 1148, 1,    0,    0,    0,    1146, 1144, 1,    0,    0,
      0,    1146, 1147, 1,    0,    0,    0,    1147, 237,  1,    0,    0,
      0,    1148, 1146, 1,    0,    0,    0,    1149, 1154, 3,    240,  120,
      0,    1150, 1151, 5,    19,   0,    0,    1151, 1153, 3,    240,  120,
      0,    1152, 1150, 1,    0,    0,    0,    1153, 1156, 1,    0,    0,
      0,    1154, 1152, 1,    0,    0,    0,    1154, 1155, 1,    0,    0,
      0,    1155, 239,  1,    0,    0,    0,    1156, 1154, 1,    0,    0,
      0,    1157, 1158, 3,    242,  121,  0,    1158, 241,  1,    0,    0,
      0,    1159, 1177, 3,    244,  122,  0,    1160, 1161, 5,    20,   0,
      0,    1161, 1178, 3,    244,  122,  0,    1162, 1163, 5,    21,   0,
      0,    1163, 1178, 3,    244,  122,  0,    1164, 1165, 5,    22,   0,
      0,    1165, 1178, 3,    244,  122,  0,    1166, 1167, 5,    23,   0,
      0,    1167, 1178, 3,    244,  122,  0,    1168, 1169, 5,    24,   0,
      0,    1169, 1178, 3,    244,  122,  0,    1170, 1171, 5,    25,   0,
      0,    1171, 1178, 3,    244,  122,  0,    1172, 1173, 5,    79,   0,
      0,    1173, 1178, 3,    152,  76,   0,    1174, 1175, 5,    78,   0,
      0,    1175, 1176, 5,    79,   0,    0,    1176, 1178, 3,    152,  76,
      0,    1177, 1160, 1,    0,    0,    0,    1177, 1162, 1,    0,    0,
      0,    1177, 1164, 1,    0,    0,    0,    1177, 1166, 1,    0,    0,
      0,    1177, 1168, 1,    0,    0,    0,    1177, 1170, 1,    0,    0,
      0,    1177, 1172, 1,    0,    0,    0,    1177, 1174, 1,    0,    0,
      0,    1177, 1178, 1,    0,    0,    0,    1178, 243,  1,    0,    0,
      0,    1179, 1180, 3,    246,  123,  0,    1180, 245,  1,    0,    0,
      0,    1181, 1185, 3,    256,  128,  0,    1182, 1184, 3,    248,  124,
      0,    1183, 1182, 1,    0,    0,    0,    1184, 1187, 1,    0,    0,
      0,    1185, 1183, 1,    0,    0,    0,    1185, 1186, 1,    0,    0,
      0,    1186, 247,  1,    0,    0,    0,    1187, 1185, 1,    0,    0,
      0,    1188, 1189, 5,    13,   0,    0,    1189, 1194, 3,    250,  125,
      0,    1190, 1191, 5,    26,   0,    0,    1191, 1194, 3,    252,  126,
      0,    1192, 1194, 3,    254,  127,  0,    1193, 1188, 1,    0,    0,
      0,    1193, 1190, 1,    0,    0,    0,    1193, 1192, 1,    0,    0,
      0,    1194, 249,  1,    0,    0,    0,    1195, 1196, 3,    256,  128,
      0,    1196, 251,  1,    0,    0,    0,    1197, 1198, 3,    256,  128,
      0,    1198, 253,  1,    0,    0,    0,    1199, 1202, 3,    294,  147,
      0,    1200, 1202, 3,    296,  148,  0,    1201, 1199, 1,    0,    0,
      0,    1201, 1200, 1,    0,    0,    0,    1202, 1206, 1,    0,    0,
      0,    1203, 1205, 3,    258,  129,  0,    1204, 1203, 1,    0,    0,
      0,    1205, 1208, 1,    0,    0,    0,    1206, 1204, 1,    0,    0,
      0,    1206, 1207, 1,    0,    0,    0,    1207, 255,  1,    0,    0,
      0,    1208, 1206, 1,    0,    0,    0,    1209, 1213, 3,    264,  132,
      0,    1210, 1212, 3,    258,  129,  0,    1211, 1210, 1,    0,    0,
      0,    1212, 1215, 1,    0,    0,    0,    1213, 1211, 1,    0,    0,
      0,    1213, 1214, 1,    0,    0,    0,    1214, 257,  1,    0,    0,
      0,    1215, 1213, 1,    0,    0,    0,    1216, 1219, 3,    260,  130,
      0,    1217, 1219, 3,    262,  131,  0,    1218, 1216, 1,    0,    0,
      0,    1218, 1217, 1,    0,    0,    0,    1219, 259,  1,    0,    0,
      0,    1220, 1221, 5,    1,    0,    0,    1221, 1222, 3,    264,  132,
      0,    1222, 261,  1,    0,    0,    0,    1223, 1224, 5,    11,   0,
      0,    1224, 1225, 3,    264,  132,  0,    1225, 263,  1,    0,    0,
      0,    1226, 1227, 5,    15,   0,    0,    1227, 1234, 3,    266,  133,
      0,    1228, 1229, 5,    13,   0,    0,    1229, 1234, 3,    266,  133,
      0,    1230, 1231, 5,    26,   0,    0,    1231, 1234, 3,    266,  133,
      0,    1232, 1234, 3,    266,  133,  0,    1233, 1226, 1,    0,    0,
      0,    1233, 1228, 1,    0,    0,    0,    1233, 1230, 1,    0,    0,
      0,    1233, 1232, 1,    0,    0,    0,    1234, 265,  1,    0,    0,
      0,    1235, 1243, 3,    268,  134,  0,    1236, 1243, 3,    270,  135,
      0,    1237, 1243, 3,    286,  143,  0,    1238, 1243, 3,    288,  144,
      0,    1239, 1243, 3,    290,  145,  0,    1240, 1243, 3,    298,  149,
      0,    1241, 1243, 3,    230,  115,  0,    1242, 1235, 1,    0,    0,
      0,    1242, 1236, 1,    0,    0,    0,    1242, 1237, 1,    0,    0,
      0,    1242, 1238, 1,    0,    0,    0,    1242, 1239, 1,    0,    0,
      0,    1242, 1240, 1,    0,    0,    0,    1242, 1241, 1,    0,    0,
      0,    1243, 267,  1,    0,    0,    0,    1244, 1245, 5,    2,    0,
      0,    1245, 1246, 3,    234,  117,  0,    1246, 1247, 5,    3,    0,
      0,    1247, 269,  1,    0,    0,    0,    1248, 1503, 3,    284,  142,
      0,    1249, 1250, 5,    80,   0,    0,    1250, 1251, 5,    2,    0,
      0,    1251, 1252, 3,    234,  117,  0,    1252, 1253, 5,    3,    0,
      0,    1253, 1503, 1,    0,    0,    0,    1254, 1503, 3,    274,  137,
      0,    1255, 1256, 5,    82,   0,    0,    1256, 1257, 5,    2,    0,
      0,    1257, 1258, 3,    234,  117,  0,    1258, 1259, 5,    8,    0,
      0,    1259, 1260, 3,    234,  117,  0,    1260, 1261, 5,    3,    0,
      0,    1261, 1503, 1,    0,    0,    0,    1262, 1263, 5,    83,   0,
      0,    1263, 1264, 5,    2,    0,    0,    1264, 1265, 3,    234,  117,
      0,    1265, 1266, 5,    3,    0,    0,    1266, 1503, 1,    0,    0,
      0,    1267, 1268, 5,    84,   0,    0,    1268, 1269, 5,    2,    0,
      0,    1269, 1270, 3,    230,  115,  0,    1270, 1271, 5,    3,    0,
      0,    1271, 1503, 1,    0,    0,    0,    1272, 1273, 5,    85,   0,
      0,    1273, 1274, 5,    2,    0,    0,    1274, 1275, 3,    234,  117,
      0,    1275, 1276, 5,    3,    0,    0,    1276, 1503, 1,    0,    0,
      0,    1277, 1278, 5,    86,   0,    0,    1278, 1279, 5,    2,    0,
      0,    1279, 1280, 3,    234,  117,  0,    1280, 1281, 5,    3,    0,
      0,    1281, 1503, 1,    0,    0,    0,    1282, 1288, 5,    87,   0,
      0,    1283, 1284, 5,    2,    0,    0,    1284, 1285, 3,    234,  117,
      0,    1285, 1286, 5,    3,    0,    0,    1286, 1289, 1,    0,    0,
      0,    1287, 1289, 5,    165,  0,    0,    1288, 1283, 1,    0,    0,
      0,    1288, 1287, 1,    0,    0,    0,    1289, 1503, 1,    0,    0,
      0,    1290, 1291, 5,    88,   0,    0,    1291, 1503, 5,    165,  0,
      0,    1292, 1293, 5,    89,   0,    0,    1293, 1294, 5,    2,    0,
      0,    1294, 1295, 3,    234,  117,  0,    1295, 1296, 5,    3,    0,
      0,    1296, 1503, 1,    0,    0,    0,    1297, 1298, 5,    90,   0,
      0,    1298, 1299, 5,    2,    0,    0,    1299, 1300, 3,    234,  117,
      0,    1300, 1301, 5,    3,    0,    0,    1301, 1503, 1,    0,    0,
      0,    1302, 1303, 5,    91,   0,    0,    1303, 1304, 5,    2,    0,
      0,    1304, 1305, 3,    234,  117,  0,    1305, 1306, 5,    3,    0,
      0,    1306, 1503, 1,    0,    0,    0,    1307, 1308, 5,    92,   0,
      0,    1308, 1309, 5,    2,    0,    0,    1309, 1310, 3,    234,  117,
      0,    1310, 1311, 5,    3,    0,    0,    1311, 1503, 1,    0,    0,
      0,    1312, 1313, 5,    93,   0,    0,    1313, 1503, 3,    152,  76,
      0,    1314, 1503, 3,    276,  138,  0,    1315, 1316, 5,    94,   0,
      0,    1316, 1317, 5,    2,    0,    0,    1317, 1318, 3,    234,  117,
      0,    1318, 1319, 5,    3,    0,    0,    1319, 1503, 1,    0,    0,
      0,    1320, 1503, 3,    278,  139,  0,    1321, 1322, 5,    95,   0,
      0,    1322, 1323, 5,    2,    0,    0,    1323, 1324, 3,    234,  117,
      0,    1324, 1325, 5,    3,    0,    0,    1325, 1503, 1,    0,    0,
      0,    1326, 1327, 5,    96,   0,    0,    1327, 1328, 5,    2,    0,
      0,    1328, 1329, 3,    234,  117,  0,    1329, 1330, 5,    3,    0,
      0,    1330, 1503, 1,    0,    0,    0,    1331, 1332, 5,    97,   0,
      0,    1332, 1333, 5,    2,    0,    0,    1333, 1334, 3,    234,  117,
      0,    1334, 1335, 5,    3,    0,    0,    1335, 1503, 1,    0,    0,
      0,    1336, 1337, 5,    99,   0,    0,    1337, 1338, 5,    2,    0,
      0,    1338, 1339, 3,    234,  117,  0,    1339, 1340, 5,    8,    0,
      0,    1340, 1341, 3,    234,  117,  0,    1341, 1342, 5,    3,    0,
      0,    1342, 1503, 1,    0,    0,    0,    1343, 1344, 5,    100,  0,
      0,    1344, 1345, 5,    2,    0,    0,    1345, 1346, 3,    234,  117,
      0,    1346, 1347, 5,    8,    0,    0,    1347, 1348, 3,    234,  117,
      0,    1348, 1349, 5,    3,    0,    0,    1349, 1503, 1,    0,    0,
      0,    1350, 1351, 5,    101,  0,    0,    1351, 1352, 5,    2,    0,
      0,    1352, 1353, 3,    234,  117,  0,    1353, 1354, 5,    8,    0,
      0,    1354, 1355, 3,    234,  117,  0,    1355, 1356, 5,    3,    0,
      0,    1356, 1503, 1,    0,    0,    0,    1357, 1358, 5,    102,  0,
      0,    1358, 1359, 5,    2,    0,    0,    1359, 1360, 3,    234,  117,
      0,    1360, 1361, 5,    8,    0,    0,    1361, 1362, 3,    234,  117,
      0,    1362, 1363, 5,    3,    0,    0,    1363, 1503, 1,    0,    0,
      0,    1364, 1365, 5,    103,  0,    0,    1365, 1366, 5,    2,    0,
      0,    1366, 1367, 3,    234,  117,  0,    1367, 1368, 5,    8,    0,
      0,    1368, 1369, 3,    234,  117,  0,    1369, 1370, 5,    3,    0,
      0,    1370, 1503, 1,    0,    0,    0,    1371, 1372, 5,    104,  0,
      0,    1372, 1373, 5,    2,    0,    0,    1373, 1374, 3,    234,  117,
      0,    1374, 1375, 5,    3,    0,    0,    1375, 1503, 1,    0,    0,
      0,    1376, 1377, 5,    105,  0,    0,    1377, 1378, 5,    2,    0,
      0,    1378, 1379, 3,    234,  117,  0,    1379, 1380, 5,    3,    0,
      0,    1380, 1503, 1,    0,    0,    0,    1381, 1382, 5,    106,  0,
      0,    1382, 1383, 5,    2,    0,    0,    1383, 1384, 3,    234,  117,
      0,    1384, 1385, 5,    3,    0,    0,    1385, 1503, 1,    0,    0,
      0,    1386, 1387, 5,    107,  0,    0,    1387, 1388, 5,    2,    0,
      0,    1388, 1389, 3,    234,  117,  0,    1389, 1390, 5,    3,    0,
      0,    1390, 1503, 1,    0,    0,    0,    1391, 1392, 5,    108,  0,
      0,    1392, 1393, 5,    2,    0,    0,    1393, 1394, 3,    234,  117,
      0,    1394, 1395, 5,    3,    0,    0,    1395, 1503, 1,    0,    0,
      0,    1396, 1397, 5,    109,  0,    0,    1397, 1398, 5,    2,    0,
      0,    1398, 1399, 3,    234,  117,  0,    1399, 1400, 5,    3,    0,
      0,    1400, 1503, 1,    0,    0,    0,    1401, 1402, 5,    110,  0,
      0,    1402, 1403, 5,    2,    0,    0,    1403, 1404, 3,    234,  117,
      0,    1404, 1405, 5,    3,    0,    0,    1405, 1503, 1,    0,    0,
      0,    1406, 1407, 5,    111,  0,    0,    1407, 1408, 5,    2,    0,
      0,    1408, 1409, 3,    234,  117,  0,    1409, 1410, 5,    3,    0,
      0,    1410, 1503, 1,    0,    0,    0,    1411, 1412, 5,    112,  0,
      0,    1412, 1503, 5,    165,  0,    0,    1413, 1414, 5,    113,  0,
      0,    1414, 1503, 5,    165,  0,    0,    1415, 1416, 5,    114,  0,
      0,    1416, 1503, 5,    165,  0,    0,    1417, 1418, 5,    119,  0,
      0,    1418, 1419, 5,    2,    0,    0,    1419, 1420, 3,    234,  117,
      0,    1420, 1421, 5,    3,    0,    0,    1421, 1503, 1,    0,    0,
      0,    1422, 1423, 5,    115,  0,    0,    1423, 1424, 5,    2,    0,
      0,    1424, 1425, 3,    234,  117,  0,    1425, 1426, 5,    3,    0,
      0,    1426, 1503, 1,    0,    0,    0,    1427, 1428, 5,    116,  0,
      0,    1428, 1429, 5,    2,    0,    0,    1429, 1430, 3,    234,  117,
      0,    1430, 1431, 5,    3,    0,    0,    1431, 1503, 1,    0,    0,
      0,    1432, 1433, 5,    117,  0,    0,    1433, 1434, 5,    2,    0,
      0,    1434, 1435, 3,    234,  117,  0,    1435, 1436, 5,    3,    0,
      0,    1436, 1503, 1,    0,    0,    0,    1437, 1438, 5,    118,  0,
      0,    1438, 1439, 5,    2,    0,    0,    1439, 1440, 3,    234,  117,
      0,    1440, 1441, 5,    3,    0,    0,    1441, 1503, 1,    0,    0,
      0,    1442, 1443, 5,    120,  0,    0,    1443, 1503, 3,    152,  76,
      0,    1444, 1445, 5,    121,  0,    0,    1445, 1446, 5,    2,    0,
      0,    1446, 1447, 3,    234,  117,  0,    1447, 1448, 5,    8,    0,
      0,    1448, 1449, 3,    234,  117,  0,    1449, 1450, 5,    8,    0,
      0,    1450, 1451, 3,    234,  117,  0,    1451, 1452, 5,    3,    0,
      0,    1452, 1503, 1,    0,    0,    0,    1453, 1454, 5,    122,  0,
      0,    1454, 1455, 5,    2,    0,    0,    1455, 1456, 3,    234,  117,
      0,    1456, 1457, 5,    8,    0,    0,    1457, 1458, 3,    234,  117,
      0,    1458, 1459, 5,    3,    0,    0,    1459, 1503, 1,    0,    0,
      0,    1460, 1461, 5,    123,  0,    0,    1461, 1462, 5,    2,    0,
      0,    1462, 1463, 3,    234,  117,  0,    1463, 1464, 5,    8,    0,
      0,    1464, 1465, 3,    234,  117,  0,    1465, 1466, 5,    3,    0,
      0,    1466, 1503, 1,    0,    0,    0,    1467, 1468, 5,    124,  0,
      0,    1468, 1469, 5,    2,    0,    0,    1469, 1470, 3,    234,  117,
      0,    1470, 1471, 5,    8,    0,    0,    1471, 1472, 3,    234,  117,
      0,    1472, 1473, 5,    3,    0,    0,    1473, 1503, 1,    0,    0,
      0,    1474, 1475, 5,    125,  0,    0,    1475, 1476, 5,    2,    0,
      0,    1476, 1477, 3,    234,  117,  0,    1477, 1478, 5,    3,    0,
      0,    1478, 1503, 1,    0,    0,    0,    1479, 1480, 5,    126,  0,
      0,    1480, 1481, 5,    2,    0,    0,    1481, 1482, 3,    234,  117,
      0,    1482, 1483, 5,    3,    0,    0,    1483, 1503, 1,    0,    0,
      0,    1484, 1485, 5,    127,  0,    0,    1485, 1486, 5,    2,    0,
      0,    1486, 1487, 3,    234,  117,  0,    1487, 1488, 5,    3,    0,
      0,    1488, 1503, 1,    0,    0,    0,    1489, 1490, 5,    128,  0,
      0,    1490, 1491, 5,    2,    0,    0,    1491, 1492, 3,    234,  117,
      0,    1492, 1493, 5,    3,    0,    0,    1493, 1503, 1,    0,    0,
      0,    1494, 1495, 5,    129,  0,    0,    1495, 1496, 5,    2,    0,
      0,    1496, 1497, 3,    234,  117,  0,    1497, 1498, 5,    3,    0,
      0,    1498, 1503, 1,    0,    0,    0,    1499, 1503, 3,    272,  136,
      0,    1500, 1503, 3,    280,  140,  0,    1501, 1503, 3,    282,  141,
      0,    1502, 1248, 1,    0,    0,    0,    1502, 1249, 1,    0,    0,
      0,    1502, 1254, 1,    0,    0,    0,    1502, 1255, 1,    0,    0,
      0,    1502, 1262, 1,    0,    0,    0,    1502, 1267, 1,    0,    0,
      0,    1502, 1272, 1,    0,    0,    0,    1502, 1277, 1,    0,    0,
      0,    1502, 1282, 1,    0,    0,    0,    1502, 1290, 1,    0,    0,
      0,    1502, 1292, 1,    0,    0,    0,    1502, 1297, 1,    0,    0,
      0,    1502, 1302, 1,    0,    0,    0,    1502, 1307, 1,    0,    0,
      0,    1502, 1312, 1,    0,    0,    0,    1502, 1314, 1,    0,    0,
      0,    1502, 1315, 1,    0,    0,    0,    1502, 1320, 1,    0,    0,
      0,    1502, 1321, 1,    0,    0,    0,    1502, 1326, 1,    0,    0,
      0,    1502, 1331, 1,    0,    0,    0,    1502, 1336, 1,    0,    0,
      0,    1502, 1343, 1,    0,    0,    0,    1502, 1350, 1,    0,    0,
      0,    1502, 1357, 1,    0,    0,    0,    1502, 1364, 1,    0,    0,
      0,    1502, 1371, 1,    0,    0,    0,    1502, 1376, 1,    0,    0,
      0,    1502, 1381, 1,    0,    0,    0,    1502, 1386, 1,    0,    0,
      0,    1502, 1391, 1,    0,    0,    0,    1502, 1396, 1,    0,    0,
      0,    1502, 1401, 1,    0,    0,    0,    1502, 1406, 1,    0,    0,
      0,    1502, 1411, 1,    0,    0,    0,    1502, 1413, 1,    0,    0,
      0,    1502, 1415, 1,    0,    0,    0,    1502, 1417, 1,    0,    0,
      0,    1502, 1422, 1,    0,    0,    0,    1502, 1427, 1,    0,    0,
      0,    1502, 1432, 1,    0,    0,    0,    1502, 1437, 1,    0,    0,
      0,    1502, 1442, 1,    0,    0,    0,    1502, 1444, 1,    0,    0,
      0,    1502, 1453, 1,    0,    0,    0,    1502, 1460, 1,    0,    0,
      0,    1502, 1467, 1,    0,    0,    0,    1502, 1474, 1,    0,    0,
      0,    1502, 1479, 1,    0,    0,    0,    1502, 1484, 1,    0,    0,
      0,    1502, 1489, 1,    0,    0,    0,    1502, 1494, 1,    0,    0,
      0,    1502, 1499, 1,    0,    0,    0,    1502, 1500, 1,    0,    0,
      0,    1502, 1501, 1,    0,    0,    0,    1503, 271,  1,    0,    0,
      0,    1504, 1505, 5,    130,  0,    0,    1505, 1506, 5,    2,    0,
      0,    1506, 1507, 3,    234,  117,  0,    1507, 1508, 5,    8,    0,
      0,    1508, 1511, 3,    234,  117,  0,    1509, 1510, 5,    8,    0,
      0,    1510, 1512, 3,    234,  117,  0,    1511, 1509, 1,    0,    0,
      0,    1511, 1512, 1,    0,    0,    0,    1512, 1513, 1,    0,    0,
      0,    1513, 1514, 5,    3,    0,    0,    1514, 273,  1,    0,    0,
      0,    1515, 1516, 5,    81,   0,    0,    1516, 1517, 5,    2,    0,
      0,    1517, 1518, 3,    234,  117,  0,    1518, 1519, 5,    3,    0,
      0,    1519, 275,  1,    0,    0,    0,    1520, 1521, 5,    131,  0,
      0,    1521, 1522, 5,    2,    0,    0,    1522, 1523, 3,    234,  117,
      0,    1523, 1524, 5,    8,    0,    0,    1524, 1527, 3,    234,  117,
      0,    1525, 1526, 5,    8,    0,    0,    1526, 1528, 3,    234,  117,
      0,    1527, 1525, 1,    0,    0,    0,    1527, 1528, 1,    0,    0,
      0,    1528, 1529, 1,    0,    0,    0,    1529, 1530, 5,    3,    0,
      0,    1530, 277,  1,    0,    0,    0,    1531, 1532, 5,    132,  0,
      0,    1532, 1533, 5,    2,    0,    0,    1533, 1534, 3,    234,  117,
      0,    1534, 1535, 5,    8,    0,    0,    1535, 1536, 3,    234,  117,
      0,    1536, 1537, 5,    8,    0,    0,    1537, 1540, 3,    234,  117,
      0,    1538, 1539, 5,    8,    0,    0,    1539, 1541, 3,    234,  117,
      0,    1540, 1538, 1,    0,    0,    0,    1540, 1541, 1,    0,    0,
      0,    1541, 1542, 1,    0,    0,    0,    1542, 1543, 5,    3,    0,
      0,    1543, 279,  1,    0,    0,    0,    1544, 1545, 5,    133,  0,
      0,    1545, 1546, 3,    110,  55,   0,    1546, 281,  1,    0,    0,
      0,    1547, 1548, 5,    78,   0,    0,    1548, 1549, 5,    133,  0,
      0,    1549, 1550, 3,    110,  55,   0,    1550, 283,  1,    0,    0,
      0,    1551, 1552, 5,    134,  0,    0,    1552, 1554, 5,    2,    0,
      0,    1553, 1555, 5,    33,   0,    0,    1554, 1553, 1,    0,    0,
      0,    1554, 1555, 1,    0,    0,    0,    1555, 1558, 1,    0,    0,
      0,    1556, 1559, 5,    1,    0,    0,    1557, 1559, 3,    234,  117,
      0,    1558, 1556, 1,    0,    0,    0,    1558, 1557, 1,    0,    0,
      0,    1559, 1560, 1,    0,    0,    0,    1560, 1624, 5,    3,    0,
      0,    1561, 1562, 5,    135,  0,    0,    1562, 1564, 5,    2,    0,
      0,    1563, 1565, 5,    33,   0,    0,    1564, 1563, 1,    0,    0,
      0,    1564, 1565, 1,    0,    0,    0,    1565, 1566, 1,    0,    0,
      0,    1566, 1567, 3,    234,  117,  0,    1567, 1568, 5,    3,    0,
      0,    1568, 1624, 1,    0,    0,    0,    1569, 1570, 5,    136,  0,
      0,    1570, 1572, 5,    2,    0,    0,    1571, 1573, 5,    33,   0,
      0,    1572, 1571, 1,    0,    0,    0,    1572, 1573, 1,    0,    0,
      0,    1573, 1574, 1,    0,    0,    0,    1574, 1575, 3,    234,  117,
      0,    1575, 1576, 5,    3,    0,    0,    1576, 1624, 1,    0,    0,
      0,    1577, 1578, 5,    137,  0,    0,    1578, 1580, 5,    2,    0,
      0,    1579, 1581, 5,    33,   0,    0,    1580, 1579, 1,    0,    0,
      0,    1580, 1581, 1,    0,    0,    0,    1581, 1582, 1,    0,    0,
      0,    1582, 1583, 3,    234,  117,  0,    1583, 1584, 5,    3,    0,
      0,    1584, 1624, 1,    0,    0,    0,    1585, 1586, 5,    138,  0,
      0,    1586, 1588, 5,    2,    0,    0,    1587, 1589, 5,    33,   0,
      0,    1588, 1587, 1,    0,    0,    0,    1588, 1589, 1,    0,    0,
      0,    1589, 1590, 1,    0,    0,    0,    1590, 1591, 3,    234,  117,
      0,    1591, 1592, 5,    3,    0,    0,    1592, 1624, 1,    0,    0,
      0,    1593, 1594, 5,    139,  0,    0,    1594, 1596, 5,    2,    0,
      0,    1595, 1597, 5,    33,   0,    0,    1596, 1595, 1,    0,    0,
      0,    1596, 1597, 1,    0,    0,    0,    1597, 1598, 1,    0,    0,
      0,    1598, 1599, 3,    234,  117,  0,    1599, 1600, 5,    3,    0,
      0,    1600, 1624, 1,    0,    0,    0,    1601, 1602, 5,    140,  0,
      0,    1602, 1604, 5,    2,    0,    0,    1603, 1605, 5,    33,   0,
      0,    1604, 1603, 1,    0,    0,    0,    1604, 1605, 1,    0,    0,
      0,    1605, 1606, 1,    0,    0,    0,    1606, 1607, 3,    234,  117,
      0,    1607, 1608, 5,    3,    0,    0,    1608, 1624, 1,    0,    0,
      0,    1609, 1610, 5,    43,   0,    0,    1610, 1612, 5,    2,    0,
      0,    1611, 1613, 5,    33,   0,    0,    1612, 1611, 1,    0,    0,
      0,    1612, 1613, 1,    0,    0,    0,    1613, 1614, 1,    0,    0,
      0,    1614, 1619, 3,    234,  117,  0,    1615, 1616, 5,    6,    0,
      0,    1616, 1617, 5,    141,  0,    0,    1617, 1618, 5,    20,   0,
      0,    1618, 1620, 3,    300,  150,  0,    1619, 1615, 1,    0,    0,
      0,    1619, 1620, 1,    0,    0,    0,    1620, 1621, 1,    0,    0,
      0,    1621, 1622, 5,    3,    0,    0,    1622, 1624, 1,    0,    0,
      0,    1623, 1551, 1,    0,    0,    0,    1623, 1561, 1,    0,    0,
      0,    1623, 1569, 1,    0,    0,    0,    1623, 1577, 1,    0,    0,
      0,    1623, 1585, 1,    0,    0,    0,    1623, 1593, 1,    0,    0,
      0,    1623, 1601, 1,    0,    0,    0,    1623, 1609, 1,    0,    0,
      0,    1624, 285,  1,    0,    0,    0,    1625, 1627, 3,    302,  151,
      0,    1626, 1628, 3,    150,  75,   0,    1627, 1626, 1,    0,    0,
      0,    1627, 1628, 1,    0,    0,    0,    1628, 287,  1,    0,    0,
      0,    1629, 1633, 3,    300,  150,  0,    1630, 1634, 5,    148,  0,
      0,    1631, 1632, 5,    27,   0,    0,    1632, 1634, 3,    302,  151,
      0,    1633, 1630, 1,    0,    0,    0,    1633, 1631, 1,    0,    0,
      0,    1633, 1634, 1,    0,    0,    0,    1634, 289,  1,    0,    0,
      0,    1635, 1639, 3,    292,  146,  0,    1636, 1639, 3,    294,  147,
      0,    1637, 1639, 3,    296,  148,  0,    1638, 1635, 1,    0,    0,
      0,    1638, 1636, 1,    0,    0,    0,    1638, 1637, 1,    0,    0,
      0,    1639, 291,  1,    0,    0,    0,    1640, 1641, 7,    4,    0,
      0,    1641, 293,  1,    0,    0,    0,    1642, 1643, 7,    5,    0,
      0,    1643, 295,  1,    0,    0,    0,    1644, 1645, 7,    6,    0,
      0,    1645, 297,  1,    0,    0,    0,    1646, 1647, 7,    7,    0,
      0,    1647, 299,  1,    0,    0,    0,    1648, 1649, 7,    8,    0,
      0,    1649, 301,  1,    0,    0,    0,    1650, 1652, 5,    149,  0,
      0,    1651, 1650, 1,    0,    0,    0,    1651, 1652, 1,    0,    0,
      0,    1652, 1655, 1,    0,    0,    0,    1653, 1656, 3,    308,  154,
      0,    1654, 1656, 3,    304,  152,  0,    1655, 1653, 1,    0,    0,
      0,    1655, 1654, 1,    0,    0,    0,    1656, 303,  1,    0,    0,
      0,    1657, 1660, 3,    310,  155,  0,    1658, 1660, 3,    312,  156,
      0,    1659, 1657, 1,    0,    0,    0,    1659, 1658, 1,    0,    0,
      0,    1660, 305,  1,    0,    0,    0,    1661, 1662, 7,    9,    0,
      0,    1662, 307,  1,    0,    0,    0,    1663, 1664, 5,    142,  0,
      0,    1664, 309,  1,    0,    0,    0,    1665, 1666, 5,    144,  0,
      0,    1666, 311,  1,    0,    0,    0,    1667, 1668, 5,    143,  0,
      0,    1668, 313,  1,    0,    0,    0,    164,  316,  325,  331,  333,
      347,  360,  365,  368,  372,  387,  396,  402,  406,  412,  415,  420,
      424,  432,  441,  451,  456,  459,  462,  465,  471,  479,  484,  490,
      496,  501,  507,  509,  513,  516,  520,  523,  527,  530,  534,  537,
      541,  544,  548,  551,  553,  566,  576,  581,  583,  596,  600,  605,
      609,  615,  621,  627,  635,  643,  663,  667,  670,  675,  691,  695,
      698,  707,  718,  722,  725,  729,  736,  745,  749,  754,  759,  764,
      769,  772,  777,  779,  789,  800,  817,  824,  834,  838,  844,  853,
      858,  865,  875,  884,  892,  899,  904,  913,  918,  922,  929,  931,
      939,  942,  950,  954,  959,  966,  977,  980,  985,  989,  1004, 1011,
      1023, 1031, 1036, 1041, 1053, 1062, 1065, 1068, 1075, 1077, 1083, 1091,
      1101, 1109, 1115, 1119, 1123, 1127, 1137, 1146, 1154, 1177, 1185, 1193,
      1201, 1206, 1213, 1218, 1233, 1242, 1288, 1502, 1511, 1527, 1540, 1554,
      1558, 1564, 1572, 1580, 1588, 1596, 1604, 1612, 1619, 1623, 1627, 1633,
      1638, 1651, 1655, 1659};
  staticData->serializedATN = antlr4::atn::SerializedATNView(
      serializedATNSegment,
      sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) {
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i),
                                           i);
  }
  sparqlautomaticParserStaticData = staticData.release();
}

}  // namespace

SparqlAutomaticParser::SparqlAutomaticParser(TokenStream* input)
    : SparqlAutomaticParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

SparqlAutomaticParser::SparqlAutomaticParser(
    TokenStream* input, const antlr4::atn::ParserATNSimulatorOptions& options)
    : Parser(input) {
  SparqlAutomaticParser::initialize();
  _interpreter = new atn::ParserATNSimulator(
      this, *sparqlautomaticParserStaticData->atn,
      sparqlautomaticParserStaticData->decisionToDFA,
      sparqlautomaticParserStaticData->sharedContextCache, options);
}

SparqlAutomaticParser::~SparqlAutomaticParser() { delete _interpreter; }

const atn::ATN& SparqlAutomaticParser::getATN() const {
  return *sparqlautomaticParserStaticData->atn;
}

std::string SparqlAutomaticParser::getGrammarFileName() const {
  return "SparqlAutomatic.g4";
}

const std::vector<std::string>& SparqlAutomaticParser::getRuleNames() const {
  return sparqlautomaticParserStaticData->ruleNames;
}

const dfa::Vocabulary& SparqlAutomaticParser::getVocabulary() const {
  return sparqlautomaticParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView SparqlAutomaticParser::getSerializedATN() const {
  return sparqlautomaticParserStaticData->serializedATN;
}

//----------------- QueryOrUpdateContext
//------------------------------------------------------------------

SparqlAutomaticParser::QueryOrUpdateContext::QueryOrUpdateContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::QueryOrUpdateContext::EOF() {
  return getToken(SparqlAutomaticParser::EOF, 0);
}

SparqlAutomaticParser::QueryContext*
SparqlAutomaticParser::QueryOrUpdateContext::query() {
  return getRuleContext<SparqlAutomaticParser::QueryContext>(0);
}

SparqlAutomaticParser::UpdateContext*
SparqlAutomaticParser::QueryOrUpdateContext::update() {
  return getRuleContext<SparqlAutomaticParser::UpdateContext>(0);
}

size_t SparqlAutomaticParser::QueryOrUpdateContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleQueryOrUpdate;
}

void SparqlAutomaticParser::QueryOrUpdateContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterQueryOrUpdate(this);
}

void SparqlAutomaticParser::QueryOrUpdateContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitQueryOrUpdate(this);
}

std::any SparqlAutomaticParser::QueryOrUpdateContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitQueryOrUpdate(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::QueryOrUpdateContext*
SparqlAutomaticParser::queryOrUpdate() {
  QueryOrUpdateContext* _localctx =
      _tracker.createInstance<QueryOrUpdateContext>(_ctx, getState());
  enterRule(_localctx, 0, SparqlAutomaticParser::RuleQueryOrUpdate);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(316);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 0, _ctx)) {
      case 1: {
        setState(314);
        query();
        break;
      }

      case 2: {
        setState(315);
        update();
        break;
      }

      default:
        break;
    }
    setState(318);
    match(SparqlAutomaticParser::EOF);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryContext
//------------------------------------------------------------------

SparqlAutomaticParser::QueryContext::QueryContext(ParserRuleContext* parent,
                                                  size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::PrologueContext*
SparqlAutomaticParser::QueryContext::prologue() {
  return getRuleContext<SparqlAutomaticParser::PrologueContext>(0);
}

SparqlAutomaticParser::ValuesClauseContext*
SparqlAutomaticParser::QueryContext::valuesClause() {
  return getRuleContext<SparqlAutomaticParser::ValuesClauseContext>(0);
}

SparqlAutomaticParser::SelectQueryContext*
SparqlAutomaticParser::QueryContext::selectQuery() {
  return getRuleContext<SparqlAutomaticParser::SelectQueryContext>(0);
}

SparqlAutomaticParser::ConstructQueryContext*
SparqlAutomaticParser::QueryContext::constructQuery() {
  return getRuleContext<SparqlAutomaticParser::ConstructQueryContext>(0);
}

SparqlAutomaticParser::DescribeQueryContext*
SparqlAutomaticParser::QueryContext::describeQuery() {
  return getRuleContext<SparqlAutomaticParser::DescribeQueryContext>(0);
}

SparqlAutomaticParser::AskQueryContext*
SparqlAutomaticParser::QueryContext::askQuery() {
  return getRuleContext<SparqlAutomaticParser::AskQueryContext>(0);
}

size_t SparqlAutomaticParser::QueryContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleQuery;
}

void SparqlAutomaticParser::QueryContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterQuery(this);
}

void SparqlAutomaticParser::QueryContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitQuery(this);
}

std::any SparqlAutomaticParser::QueryContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitQuery(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::QueryContext* SparqlAutomaticParser::query() {
  QueryContext* _localctx =
      _tracker.createInstance<QueryContext>(_ctx, getState());
  enterRule(_localctx, 2, SparqlAutomaticParser::RuleQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(320);
    prologue();
    setState(325);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::SELECT: {
        setState(321);
        selectQuery();
        break;
      }

      case SparqlAutomaticParser::CONSTRUCT: {
        setState(322);
        constructQuery();
        break;
      }

      case SparqlAutomaticParser::DESCRIBE: {
        setState(323);
        describeQuery();
        break;
      }

      case SparqlAutomaticParser::ASK: {
        setState(324);
        askQuery();
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(327);
    valuesClause();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrologueContext
//------------------------------------------------------------------

SparqlAutomaticParser::PrologueContext::PrologueContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::BaseDeclContext*>
SparqlAutomaticParser::PrologueContext::baseDecl() {
  return getRuleContexts<SparqlAutomaticParser::BaseDeclContext>();
}

SparqlAutomaticParser::BaseDeclContext*
SparqlAutomaticParser::PrologueContext::baseDecl(size_t i) {
  return getRuleContext<SparqlAutomaticParser::BaseDeclContext>(i);
}

std::vector<SparqlAutomaticParser::PrefixDeclContext*>
SparqlAutomaticParser::PrologueContext::prefixDecl() {
  return getRuleContexts<SparqlAutomaticParser::PrefixDeclContext>();
}

SparqlAutomaticParser::PrefixDeclContext*
SparqlAutomaticParser::PrologueContext::prefixDecl(size_t i) {
  return getRuleContext<SparqlAutomaticParser::PrefixDeclContext>(i);
}

size_t SparqlAutomaticParser::PrologueContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePrologue;
}

void SparqlAutomaticParser::PrologueContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPrologue(this);
}

void SparqlAutomaticParser::PrologueContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPrologue(this);
}

std::any SparqlAutomaticParser::PrologueContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPrologue(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PrologueContext* SparqlAutomaticParser::prologue() {
  PrologueContext* _localctx =
      _tracker.createInstance<PrologueContext>(_ctx, getState());
  enterRule(_localctx, 4, SparqlAutomaticParser::RulePrologue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(333);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::BASE

           || _la == SparqlAutomaticParser::PREFIX) {
      setState(331);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SparqlAutomaticParser::BASE: {
          setState(329);
          baseDecl();
          break;
        }

        case SparqlAutomaticParser::PREFIX: {
          setState(330);
          prefixDecl();
          break;
        }

        default:
          throw NoViableAltException(this);
      }
      setState(335);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BaseDeclContext
//------------------------------------------------------------------

SparqlAutomaticParser::BaseDeclContext::BaseDeclContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::BaseDeclContext::BASE() {
  return getToken(SparqlAutomaticParser::BASE, 0);
}

SparqlAutomaticParser::IrirefContext*
SparqlAutomaticParser::BaseDeclContext::iriref() {
  return getRuleContext<SparqlAutomaticParser::IrirefContext>(0);
}

size_t SparqlAutomaticParser::BaseDeclContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleBaseDecl;
}

void SparqlAutomaticParser::BaseDeclContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterBaseDecl(this);
}

void SparqlAutomaticParser::BaseDeclContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitBaseDecl(this);
}

std::any SparqlAutomaticParser::BaseDeclContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitBaseDecl(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::BaseDeclContext* SparqlAutomaticParser::baseDecl() {
  BaseDeclContext* _localctx =
      _tracker.createInstance<BaseDeclContext>(_ctx, getState());
  enterRule(_localctx, 6, SparqlAutomaticParser::RuleBaseDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(336);
    match(SparqlAutomaticParser::BASE);
    setState(337);
    iriref();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrefixDeclContext
//------------------------------------------------------------------

SparqlAutomaticParser::PrefixDeclContext::PrefixDeclContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::PrefixDeclContext::PREFIX() {
  return getToken(SparqlAutomaticParser::PREFIX, 0);
}

tree::TerminalNode* SparqlAutomaticParser::PrefixDeclContext::PNAME_NS() {
  return getToken(SparqlAutomaticParser::PNAME_NS, 0);
}

SparqlAutomaticParser::IrirefContext*
SparqlAutomaticParser::PrefixDeclContext::iriref() {
  return getRuleContext<SparqlAutomaticParser::IrirefContext>(0);
}

size_t SparqlAutomaticParser::PrefixDeclContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePrefixDecl;
}

void SparqlAutomaticParser::PrefixDeclContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPrefixDecl(this);
}

void SparqlAutomaticParser::PrefixDeclContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPrefixDecl(this);
}

std::any SparqlAutomaticParser::PrefixDeclContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPrefixDecl(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PrefixDeclContext* SparqlAutomaticParser::prefixDecl() {
  PrefixDeclContext* _localctx =
      _tracker.createInstance<PrefixDeclContext>(_ctx, getState());
  enterRule(_localctx, 8, SparqlAutomaticParser::RulePrefixDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(339);
    match(SparqlAutomaticParser::PREFIX);
    setState(340);
    match(SparqlAutomaticParser::PNAME_NS);
    setState(341);
    iriref();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectQueryContext
//------------------------------------------------------------------

SparqlAutomaticParser::SelectQueryContext::SelectQueryContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::SelectClauseContext*
SparqlAutomaticParser::SelectQueryContext::selectClause() {
  return getRuleContext<SparqlAutomaticParser::SelectClauseContext>(0);
}

SparqlAutomaticParser::WhereClauseContext*
SparqlAutomaticParser::SelectQueryContext::whereClause() {
  return getRuleContext<SparqlAutomaticParser::WhereClauseContext>(0);
}

SparqlAutomaticParser::SolutionModifierContext*
SparqlAutomaticParser::SelectQueryContext::solutionModifier() {
  return getRuleContext<SparqlAutomaticParser::SolutionModifierContext>(0);
}

std::vector<SparqlAutomaticParser::DatasetClauseContext*>
SparqlAutomaticParser::SelectQueryContext::datasetClause() {
  return getRuleContexts<SparqlAutomaticParser::DatasetClauseContext>();
}

SparqlAutomaticParser::DatasetClauseContext*
SparqlAutomaticParser::SelectQueryContext::datasetClause(size_t i) {
  return getRuleContext<SparqlAutomaticParser::DatasetClauseContext>(i);
}

size_t SparqlAutomaticParser::SelectQueryContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleSelectQuery;
}

void SparqlAutomaticParser::SelectQueryContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterSelectQuery(this);
}

void SparqlAutomaticParser::SelectQueryContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitSelectQuery(this);
}

std::any SparqlAutomaticParser::SelectQueryContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitSelectQuery(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::SelectQueryContext*
SparqlAutomaticParser::selectQuery() {
  SelectQueryContext* _localctx =
      _tracker.createInstance<SelectQueryContext>(_ctx, getState());
  enterRule(_localctx, 10, SparqlAutomaticParser::RuleSelectQuery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(343);
    selectClause();
    setState(347);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::FROM) {
      setState(344);
      datasetClause();
      setState(349);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(350);
    whereClause();
    setState(351);
    solutionModifier();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubSelectContext
//------------------------------------------------------------------

SparqlAutomaticParser::SubSelectContext::SubSelectContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::SelectClauseContext*
SparqlAutomaticParser::SubSelectContext::selectClause() {
  return getRuleContext<SparqlAutomaticParser::SelectClauseContext>(0);
}

SparqlAutomaticParser::WhereClauseContext*
SparqlAutomaticParser::SubSelectContext::whereClause() {
  return getRuleContext<SparqlAutomaticParser::WhereClauseContext>(0);
}

SparqlAutomaticParser::SolutionModifierContext*
SparqlAutomaticParser::SubSelectContext::solutionModifier() {
  return getRuleContext<SparqlAutomaticParser::SolutionModifierContext>(0);
}

SparqlAutomaticParser::ValuesClauseContext*
SparqlAutomaticParser::SubSelectContext::valuesClause() {
  return getRuleContext<SparqlAutomaticParser::ValuesClauseContext>(0);
}

size_t SparqlAutomaticParser::SubSelectContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleSubSelect;
}

void SparqlAutomaticParser::SubSelectContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterSubSelect(this);
}

void SparqlAutomaticParser::SubSelectContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitSubSelect(this);
}

std::any SparqlAutomaticParser::SubSelectContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitSubSelect(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::SubSelectContext* SparqlAutomaticParser::subSelect() {
  SubSelectContext* _localctx =
      _tracker.createInstance<SubSelectContext>(_ctx, getState());
  enterRule(_localctx, 12, SparqlAutomaticParser::RuleSubSelect);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(353);
    selectClause();
    setState(354);
    whereClause();
    setState(355);
    solutionModifier();
    setState(356);
    valuesClause();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::SelectClauseContext::SelectClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::SelectClauseContext::SELECT() {
  return getToken(SparqlAutomaticParser::SELECT, 0);
}

tree::TerminalNode* SparqlAutomaticParser::SelectClauseContext::DISTINCT() {
  return getToken(SparqlAutomaticParser::DISTINCT, 0);
}

tree::TerminalNode* SparqlAutomaticParser::SelectClauseContext::REDUCED() {
  return getToken(SparqlAutomaticParser::REDUCED, 0);
}

std::vector<SparqlAutomaticParser::VarOrAliasContext*>
SparqlAutomaticParser::SelectClauseContext::varOrAlias() {
  return getRuleContexts<SparqlAutomaticParser::VarOrAliasContext>();
}

SparqlAutomaticParser::VarOrAliasContext*
SparqlAutomaticParser::SelectClauseContext::varOrAlias(size_t i) {
  return getRuleContext<SparqlAutomaticParser::VarOrAliasContext>(i);
}

size_t SparqlAutomaticParser::SelectClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleSelectClause;
}

void SparqlAutomaticParser::SelectClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterSelectClause(this);
}

void SparqlAutomaticParser::SelectClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitSelectClause(this);
}

std::any SparqlAutomaticParser::SelectClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitSelectClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::SelectClauseContext*
SparqlAutomaticParser::selectClause() {
  SelectClauseContext* _localctx =
      _tracker.createInstance<SelectClauseContext>(_ctx, getState());
  enterRule(_localctx, 14, SparqlAutomaticParser::RuleSelectClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(358);
    match(SparqlAutomaticParser::SELECT);
    setState(360);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::DISTINCT

        || _la == SparqlAutomaticParser::REDUCED) {
      setState(359);
      _la = _input->LA(1);
      if (!(_la == SparqlAutomaticParser::DISTINCT

            || _la == SparqlAutomaticParser::REDUCED)) {
        _errHandler->recoverInline(this);
      } else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(368);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__1:
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2: {
        setState(363);
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(362);
          varOrAlias();
          setState(365);
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == SparqlAutomaticParser::T__1 ||
                 _la == SparqlAutomaticParser::VAR1

                 || _la == SparqlAutomaticParser::VAR2);
        break;
      }

      case SparqlAutomaticParser::T__0: {
        setState(367);
        antlrcpp::downCast<SelectClauseContext*>(_localctx)->asterisk =
            match(SparqlAutomaticParser::T__0);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarOrAliasContext
//------------------------------------------------------------------

SparqlAutomaticParser::VarOrAliasContext::VarOrAliasContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VarContext*
SparqlAutomaticParser::VarOrAliasContext::var() {
  return getRuleContext<SparqlAutomaticParser::VarContext>(0);
}

SparqlAutomaticParser::AliasContext*
SparqlAutomaticParser::VarOrAliasContext::alias() {
  return getRuleContext<SparqlAutomaticParser::AliasContext>(0);
}

size_t SparqlAutomaticParser::VarOrAliasContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleVarOrAlias;
}

void SparqlAutomaticParser::VarOrAliasContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterVarOrAlias(this);
}

void SparqlAutomaticParser::VarOrAliasContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitVarOrAlias(this);
}

std::any SparqlAutomaticParser::VarOrAliasContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitVarOrAlias(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::VarOrAliasContext* SparqlAutomaticParser::varOrAlias() {
  VarOrAliasContext* _localctx =
      _tracker.createInstance<VarOrAliasContext>(_ctx, getState());
  enterRule(_localctx, 16, SparqlAutomaticParser::RuleVarOrAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(372);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2: {
        enterOuterAlt(_localctx, 1);
        setState(370);
        var();
        break;
      }

      case SparqlAutomaticParser::T__1: {
        enterOuterAlt(_localctx, 2);
        setState(371);
        alias();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AliasContext
//------------------------------------------------------------------

SparqlAutomaticParser::AliasContext::AliasContext(ParserRuleContext* parent,
                                                  size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::AliasWithoutBracketsContext*
SparqlAutomaticParser::AliasContext::aliasWithoutBrackets() {
  return getRuleContext<SparqlAutomaticParser::AliasWithoutBracketsContext>(0);
}

size_t SparqlAutomaticParser::AliasContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleAlias;
}

void SparqlAutomaticParser::AliasContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterAlias(this);
}

void SparqlAutomaticParser::AliasContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitAlias(this);
}

std::any SparqlAutomaticParser::AliasContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitAlias(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::AliasContext* SparqlAutomaticParser::alias() {
  AliasContext* _localctx =
      _tracker.createInstance<AliasContext>(_ctx, getState());
  enterRule(_localctx, 18, SparqlAutomaticParser::RuleAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(374);
    match(SparqlAutomaticParser::T__1);
    setState(375);
    aliasWithoutBrackets();
    setState(376);
    match(SparqlAutomaticParser::T__2);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AliasWithoutBracketsContext
//------------------------------------------------------------------

SparqlAutomaticParser::AliasWithoutBracketsContext::AliasWithoutBracketsContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::ExpressionContext*
SparqlAutomaticParser::AliasWithoutBracketsContext::expression() {
  return getRuleContext<SparqlAutomaticParser::ExpressionContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::AliasWithoutBracketsContext::AS() {
  return getToken(SparqlAutomaticParser::AS, 0);
}

SparqlAutomaticParser::VarContext*
SparqlAutomaticParser::AliasWithoutBracketsContext::var() {
  return getRuleContext<SparqlAutomaticParser::VarContext>(0);
}

size_t SparqlAutomaticParser::AliasWithoutBracketsContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleAliasWithoutBrackets;
}

void SparqlAutomaticParser::AliasWithoutBracketsContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterAliasWithoutBrackets(this);
}

void SparqlAutomaticParser::AliasWithoutBracketsContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitAliasWithoutBrackets(this);
}

std::any SparqlAutomaticParser::AliasWithoutBracketsContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitAliasWithoutBrackets(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::AliasWithoutBracketsContext*
SparqlAutomaticParser::aliasWithoutBrackets() {
  AliasWithoutBracketsContext* _localctx =
      _tracker.createInstance<AliasWithoutBracketsContext>(_ctx, getState());
  enterRule(_localctx, 20, SparqlAutomaticParser::RuleAliasWithoutBrackets);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(378);
    expression();
    setState(379);
    match(SparqlAutomaticParser::AS);
    setState(380);
    var();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructQueryContext
//------------------------------------------------------------------

SparqlAutomaticParser::ConstructQueryContext::ConstructQueryContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::ConstructQueryContext::CONSTRUCT() {
  return getToken(SparqlAutomaticParser::CONSTRUCT, 0);
}

SparqlAutomaticParser::ConstructTemplateContext*
SparqlAutomaticParser::ConstructQueryContext::constructTemplate() {
  return getRuleContext<SparqlAutomaticParser::ConstructTemplateContext>(0);
}

SparqlAutomaticParser::WhereClauseContext*
SparqlAutomaticParser::ConstructQueryContext::whereClause() {
  return getRuleContext<SparqlAutomaticParser::WhereClauseContext>(0);
}

SparqlAutomaticParser::SolutionModifierContext*
SparqlAutomaticParser::ConstructQueryContext::solutionModifier() {
  return getRuleContext<SparqlAutomaticParser::SolutionModifierContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::ConstructQueryContext::WHERE() {
  return getToken(SparqlAutomaticParser::WHERE, 0);
}

std::vector<SparqlAutomaticParser::DatasetClauseContext*>
SparqlAutomaticParser::ConstructQueryContext::datasetClause() {
  return getRuleContexts<SparqlAutomaticParser::DatasetClauseContext>();
}

SparqlAutomaticParser::DatasetClauseContext*
SparqlAutomaticParser::ConstructQueryContext::datasetClause(size_t i) {
  return getRuleContext<SparqlAutomaticParser::DatasetClauseContext>(i);
}

SparqlAutomaticParser::TriplesTemplateContext*
SparqlAutomaticParser::ConstructQueryContext::triplesTemplate() {
  return getRuleContext<SparqlAutomaticParser::TriplesTemplateContext>(0);
}

size_t SparqlAutomaticParser::ConstructQueryContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleConstructQuery;
}

void SparqlAutomaticParser::ConstructQueryContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterConstructQuery(this);
}

void SparqlAutomaticParser::ConstructQueryContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitConstructQuery(this);
}

std::any SparqlAutomaticParser::ConstructQueryContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitConstructQuery(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ConstructQueryContext*
SparqlAutomaticParser::constructQuery() {
  ConstructQueryContext* _localctx =
      _tracker.createInstance<ConstructQueryContext>(_ctx, getState());
  enterRule(_localctx, 22, SparqlAutomaticParser::RuleConstructQuery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(382);
    match(SparqlAutomaticParser::CONSTRUCT);
    setState(406);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__3: {
        setState(383);
        constructTemplate();
        setState(387);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SparqlAutomaticParser::FROM) {
          setState(384);
          datasetClause();
          setState(389);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(390);
        whereClause();
        setState(391);
        solutionModifier();
        break;
      }

      case SparqlAutomaticParser::WHERE:
      case SparqlAutomaticParser::FROM: {
        setState(396);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SparqlAutomaticParser::FROM) {
          setState(393);
          datasetClause();
          setState(398);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(399);
        match(SparqlAutomaticParser::WHERE);
        setState(400);
        match(SparqlAutomaticParser::T__3);
        setState(402);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 805371908) != 0 ||
            (((_la - 142) & ~0x3fULL) == 0) &&
                ((1ULL << (_la - 142)) & 29228991) != 0) {
          setState(401);
          triplesTemplate();
        }
        setState(404);
        match(SparqlAutomaticParser::T__4);
        setState(405);
        solutionModifier();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DescribeQueryContext
//------------------------------------------------------------------

SparqlAutomaticParser::DescribeQueryContext::DescribeQueryContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::DescribeQueryContext::DESCRIBE() {
  return getToken(SparqlAutomaticParser::DESCRIBE, 0);
}

SparqlAutomaticParser::SolutionModifierContext*
SparqlAutomaticParser::DescribeQueryContext::solutionModifier() {
  return getRuleContext<SparqlAutomaticParser::SolutionModifierContext>(0);
}

std::vector<SparqlAutomaticParser::DatasetClauseContext*>
SparqlAutomaticParser::DescribeQueryContext::datasetClause() {
  return getRuleContexts<SparqlAutomaticParser::DatasetClauseContext>();
}

SparqlAutomaticParser::DatasetClauseContext*
SparqlAutomaticParser::DescribeQueryContext::datasetClause(size_t i) {
  return getRuleContext<SparqlAutomaticParser::DatasetClauseContext>(i);
}

SparqlAutomaticParser::WhereClauseContext*
SparqlAutomaticParser::DescribeQueryContext::whereClause() {
  return getRuleContext<SparqlAutomaticParser::WhereClauseContext>(0);
}

std::vector<SparqlAutomaticParser::VarOrIriContext*>
SparqlAutomaticParser::DescribeQueryContext::varOrIri() {
  return getRuleContexts<SparqlAutomaticParser::VarOrIriContext>();
}

SparqlAutomaticParser::VarOrIriContext*
SparqlAutomaticParser::DescribeQueryContext::varOrIri(size_t i) {
  return getRuleContext<SparqlAutomaticParser::VarOrIriContext>(i);
}

size_t SparqlAutomaticParser::DescribeQueryContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleDescribeQuery;
}

void SparqlAutomaticParser::DescribeQueryContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDescribeQuery(this);
}

void SparqlAutomaticParser::DescribeQueryContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDescribeQuery(this);
}

std::any SparqlAutomaticParser::DescribeQueryContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitDescribeQuery(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::DescribeQueryContext*
SparqlAutomaticParser::describeQuery() {
  DescribeQueryContext* _localctx =
      _tracker.createInstance<DescribeQueryContext>(_ctx, getState());
  enterRule(_localctx, 24, SparqlAutomaticParser::RuleDescribeQuery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(408);
    match(SparqlAutomaticParser::DESCRIBE);
    setState(415);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        setState(410);
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(409);
          varOrIri();
          setState(412);
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la - 142) & ~0x3fULL) == 0) &&
                 ((1ULL << (_la - 142)) & 183) != 0);
        break;
      }

      case SparqlAutomaticParser::T__0: {
        setState(414);
        match(SparqlAutomaticParser::T__0);
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(420);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::FROM) {
      setState(417);
      datasetClause();
      setState(422);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(424);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::T__3

        || _la == SparqlAutomaticParser::WHERE) {
      setState(423);
      whereClause();
    }
    setState(426);
    solutionModifier();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AskQueryContext
//------------------------------------------------------------------

SparqlAutomaticParser::AskQueryContext::AskQueryContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::AskQueryContext::ASK() {
  return getToken(SparqlAutomaticParser::ASK, 0);
}

SparqlAutomaticParser::WhereClauseContext*
SparqlAutomaticParser::AskQueryContext::whereClause() {
  return getRuleContext<SparqlAutomaticParser::WhereClauseContext>(0);
}

SparqlAutomaticParser::SolutionModifierContext*
SparqlAutomaticParser::AskQueryContext::solutionModifier() {
  return getRuleContext<SparqlAutomaticParser::SolutionModifierContext>(0);
}

std::vector<SparqlAutomaticParser::DatasetClauseContext*>
SparqlAutomaticParser::AskQueryContext::datasetClause() {
  return getRuleContexts<SparqlAutomaticParser::DatasetClauseContext>();
}

SparqlAutomaticParser::DatasetClauseContext*
SparqlAutomaticParser::AskQueryContext::datasetClause(size_t i) {
  return getRuleContext<SparqlAutomaticParser::DatasetClauseContext>(i);
}

size_t SparqlAutomaticParser::AskQueryContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleAskQuery;
}

void SparqlAutomaticParser::AskQueryContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterAskQuery(this);
}

void SparqlAutomaticParser::AskQueryContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitAskQuery(this);
}

std::any SparqlAutomaticParser::AskQueryContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitAskQuery(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::AskQueryContext* SparqlAutomaticParser::askQuery() {
  AskQueryContext* _localctx =
      _tracker.createInstance<AskQueryContext>(_ctx, getState());
  enterRule(_localctx, 26, SparqlAutomaticParser::RuleAskQuery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(428);
    match(SparqlAutomaticParser::ASK);
    setState(432);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::FROM) {
      setState(429);
      datasetClause();
      setState(434);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(435);
    whereClause();
    setState(436);
    solutionModifier();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DatasetClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::DatasetClauseContext::DatasetClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::DatasetClauseContext::FROM() {
  return getToken(SparqlAutomaticParser::FROM, 0);
}

SparqlAutomaticParser::DefaultGraphClauseContext*
SparqlAutomaticParser::DatasetClauseContext::defaultGraphClause() {
  return getRuleContext<SparqlAutomaticParser::DefaultGraphClauseContext>(0);
}

SparqlAutomaticParser::NamedGraphClauseContext*
SparqlAutomaticParser::DatasetClauseContext::namedGraphClause() {
  return getRuleContext<SparqlAutomaticParser::NamedGraphClauseContext>(0);
}

size_t SparqlAutomaticParser::DatasetClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleDatasetClause;
}

void SparqlAutomaticParser::DatasetClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDatasetClause(this);
}

void SparqlAutomaticParser::DatasetClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDatasetClause(this);
}

std::any SparqlAutomaticParser::DatasetClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitDatasetClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::DatasetClauseContext*
SparqlAutomaticParser::datasetClause() {
  DatasetClauseContext* _localctx =
      _tracker.createInstance<DatasetClauseContext>(_ctx, getState());
  enterRule(_localctx, 28, SparqlAutomaticParser::RuleDatasetClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(438);
    match(SparqlAutomaticParser::FROM);
    setState(441);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        setState(439);
        defaultGraphClause();
        break;
      }

      case SparqlAutomaticParser::NAMED: {
        setState(440);
        namedGraphClause();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultGraphClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::DefaultGraphClauseContext::DefaultGraphClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::SourceSelectorContext*
SparqlAutomaticParser::DefaultGraphClauseContext::sourceSelector() {
  return getRuleContext<SparqlAutomaticParser::SourceSelectorContext>(0);
}

size_t SparqlAutomaticParser::DefaultGraphClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleDefaultGraphClause;
}

void SparqlAutomaticParser::DefaultGraphClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDefaultGraphClause(this);
}

void SparqlAutomaticParser::DefaultGraphClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDefaultGraphClause(this);
}

std::any SparqlAutomaticParser::DefaultGraphClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitDefaultGraphClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::DefaultGraphClauseContext*
SparqlAutomaticParser::defaultGraphClause() {
  DefaultGraphClauseContext* _localctx =
      _tracker.createInstance<DefaultGraphClauseContext>(_ctx, getState());
  enterRule(_localctx, 30, SparqlAutomaticParser::RuleDefaultGraphClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(443);
    sourceSelector();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedGraphClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::NamedGraphClauseContext::NamedGraphClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::NamedGraphClauseContext::NAMED() {
  return getToken(SparqlAutomaticParser::NAMED, 0);
}

SparqlAutomaticParser::SourceSelectorContext*
SparqlAutomaticParser::NamedGraphClauseContext::sourceSelector() {
  return getRuleContext<SparqlAutomaticParser::SourceSelectorContext>(0);
}

size_t SparqlAutomaticParser::NamedGraphClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleNamedGraphClause;
}

void SparqlAutomaticParser::NamedGraphClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterNamedGraphClause(this);
}

void SparqlAutomaticParser::NamedGraphClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitNamedGraphClause(this);
}

std::any SparqlAutomaticParser::NamedGraphClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitNamedGraphClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::NamedGraphClauseContext*
SparqlAutomaticParser::namedGraphClause() {
  NamedGraphClauseContext* _localctx =
      _tracker.createInstance<NamedGraphClauseContext>(_ctx, getState());
  enterRule(_localctx, 32, SparqlAutomaticParser::RuleNamedGraphClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(445);
    match(SparqlAutomaticParser::NAMED);
    setState(446);
    sourceSelector();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceSelectorContext
//------------------------------------------------------------------

SparqlAutomaticParser::SourceSelectorContext::SourceSelectorContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::IriContext*
SparqlAutomaticParser::SourceSelectorContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

size_t SparqlAutomaticParser::SourceSelectorContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleSourceSelector;
}

void SparqlAutomaticParser::SourceSelectorContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterSourceSelector(this);
}

void SparqlAutomaticParser::SourceSelectorContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitSourceSelector(this);
}

std::any SparqlAutomaticParser::SourceSelectorContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitSourceSelector(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::SourceSelectorContext*
SparqlAutomaticParser::sourceSelector() {
  SourceSelectorContext* _localctx =
      _tracker.createInstance<SourceSelectorContext>(_ctx, getState());
  enterRule(_localctx, 34, SparqlAutomaticParser::RuleSourceSelector);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(448);
    iri();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhereClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::WhereClauseContext::WhereClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::GroupGraphPatternContext*
SparqlAutomaticParser::WhereClauseContext::groupGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::GroupGraphPatternContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::WhereClauseContext::WHERE() {
  return getToken(SparqlAutomaticParser::WHERE, 0);
}

size_t SparqlAutomaticParser::WhereClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleWhereClause;
}

void SparqlAutomaticParser::WhereClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterWhereClause(this);
}

void SparqlAutomaticParser::WhereClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitWhereClause(this);
}

std::any SparqlAutomaticParser::WhereClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitWhereClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::WhereClauseContext*
SparqlAutomaticParser::whereClause() {
  WhereClauseContext* _localctx =
      _tracker.createInstance<WhereClauseContext>(_ctx, getState());
  enterRule(_localctx, 36, SparqlAutomaticParser::RuleWhereClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(451);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::WHERE) {
      setState(450);
      match(SparqlAutomaticParser::WHERE);
    }
    setState(453);
    groupGraphPattern();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SolutionModifierContext
//------------------------------------------------------------------

SparqlAutomaticParser::SolutionModifierContext::SolutionModifierContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::GroupClauseContext*
SparqlAutomaticParser::SolutionModifierContext::groupClause() {
  return getRuleContext<SparqlAutomaticParser::GroupClauseContext>(0);
}

SparqlAutomaticParser::HavingClauseContext*
SparqlAutomaticParser::SolutionModifierContext::havingClause() {
  return getRuleContext<SparqlAutomaticParser::HavingClauseContext>(0);
}

SparqlAutomaticParser::OrderClauseContext*
SparqlAutomaticParser::SolutionModifierContext::orderClause() {
  return getRuleContext<SparqlAutomaticParser::OrderClauseContext>(0);
}

SparqlAutomaticParser::LimitOffsetClausesContext*
SparqlAutomaticParser::SolutionModifierContext::limitOffsetClauses() {
  return getRuleContext<SparqlAutomaticParser::LimitOffsetClausesContext>(0);
}

size_t SparqlAutomaticParser::SolutionModifierContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleSolutionModifier;
}

void SparqlAutomaticParser::SolutionModifierContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterSolutionModifier(this);
}

void SparqlAutomaticParser::SolutionModifierContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitSolutionModifier(this);
}

std::any SparqlAutomaticParser::SolutionModifierContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitSolutionModifier(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::SolutionModifierContext*
SparqlAutomaticParser::solutionModifier() {
  SolutionModifierContext* _localctx =
      _tracker.createInstance<SolutionModifierContext>(_ctx, getState());
  enterRule(_localctx, 38, SparqlAutomaticParser::RuleSolutionModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(456);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::GROUPBY) {
      setState(455);
      groupClause();
    }
    setState(459);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::HAVING) {
      setState(458);
      havingClause();
    }
    setState(462);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::ORDERBY

        || _la == SparqlAutomaticParser::INTERNALSORTBY) {
      setState(461);
      orderClause();
    }
    setState(465);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 3940649673949184) != 0) {
      setState(464);
      limitOffsetClauses();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::GroupClauseContext::GroupClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::GroupClauseContext::GROUPBY() {
  return getToken(SparqlAutomaticParser::GROUPBY, 0);
}

std::vector<SparqlAutomaticParser::GroupConditionContext*>
SparqlAutomaticParser::GroupClauseContext::groupCondition() {
  return getRuleContexts<SparqlAutomaticParser::GroupConditionContext>();
}

SparqlAutomaticParser::GroupConditionContext*
SparqlAutomaticParser::GroupClauseContext::groupCondition(size_t i) {
  return getRuleContext<SparqlAutomaticParser::GroupConditionContext>(i);
}

size_t SparqlAutomaticParser::GroupClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleGroupClause;
}

void SparqlAutomaticParser::GroupClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterGroupClause(this);
}

void SparqlAutomaticParser::GroupClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitGroupClause(this);
}

std::any SparqlAutomaticParser::GroupClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGroupClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GroupClauseContext*
SparqlAutomaticParser::groupClause() {
  GroupClauseContext* _localctx =
      _tracker.createInstance<GroupClauseContext>(_ctx, getState());
  enterRule(_localctx, 40, SparqlAutomaticParser::RuleGroupClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(467);
    match(SparqlAutomaticParser::GROUPBY);
    setState(469);
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(468);
      groupCondition();
      setState(471);
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == SparqlAutomaticParser::T__1

             || _la == SparqlAutomaticParser::GROUP_CONCAT ||
             (((_la - 78) & ~0x3fULL) == 0) &&
                 ((1ULL << (_la - 78)) & 9223372036853727229) != 0 ||
             (((_la - 142) & ~0x3fULL) == 0) &&
                 ((1ULL << (_la - 142)) & 183) != 0);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupConditionContext
//------------------------------------------------------------------

SparqlAutomaticParser::GroupConditionContext::GroupConditionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::BuiltInCallContext*
SparqlAutomaticParser::GroupConditionContext::builtInCall() {
  return getRuleContext<SparqlAutomaticParser::BuiltInCallContext>(0);
}

SparqlAutomaticParser::FunctionCallContext*
SparqlAutomaticParser::GroupConditionContext::functionCall() {
  return getRuleContext<SparqlAutomaticParser::FunctionCallContext>(0);
}

SparqlAutomaticParser::ExpressionContext*
SparqlAutomaticParser::GroupConditionContext::expression() {
  return getRuleContext<SparqlAutomaticParser::ExpressionContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::GroupConditionContext::AS() {
  return getToken(SparqlAutomaticParser::AS, 0);
}

SparqlAutomaticParser::VarContext*
SparqlAutomaticParser::GroupConditionContext::var() {
  return getRuleContext<SparqlAutomaticParser::VarContext>(0);
}

size_t SparqlAutomaticParser::GroupConditionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleGroupCondition;
}

void SparqlAutomaticParser::GroupConditionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterGroupCondition(this);
}

void SparqlAutomaticParser::GroupConditionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitGroupCondition(this);
}

std::any SparqlAutomaticParser::GroupConditionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGroupCondition(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GroupConditionContext*
SparqlAutomaticParser::groupCondition() {
  GroupConditionContext* _localctx =
      _tracker.createInstance<GroupConditionContext>(_ctx, getState());
  enterRule(_localctx, 42, SparqlAutomaticParser::RuleGroupCondition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(484);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::GROUP_CONCAT:
      case SparqlAutomaticParser::NOT:
      case SparqlAutomaticParser::STR:
      case SparqlAutomaticParser::LANG:
      case SparqlAutomaticParser::LANGMATCHES:
      case SparqlAutomaticParser::DATATYPE:
      case SparqlAutomaticParser::BOUND:
      case SparqlAutomaticParser::IRI:
      case SparqlAutomaticParser::URI:
      case SparqlAutomaticParser::BNODE:
      case SparqlAutomaticParser::RAND:
      case SparqlAutomaticParser::ABS:
      case SparqlAutomaticParser::CEIL:
      case SparqlAutomaticParser::FLOOR:
      case SparqlAutomaticParser::ROUND:
      case SparqlAutomaticParser::CONCAT:
      case SparqlAutomaticParser::STRLEN:
      case SparqlAutomaticParser::UCASE:
      case SparqlAutomaticParser::LCASE:
      case SparqlAutomaticParser::ENCODE_FOR_URI:
      case SparqlAutomaticParser::CONTAINS:
      case SparqlAutomaticParser::STRSTARTS:
      case SparqlAutomaticParser::STRENDS:
      case SparqlAutomaticParser::STRBEFORE:
      case SparqlAutomaticParser::STRAFTER:
      case SparqlAutomaticParser::YEAR:
      case SparqlAutomaticParser::MONTH:
      case SparqlAutomaticParser::DAY:
      case SparqlAutomaticParser::HOURS:
      case SparqlAutomaticParser::MINUTES:
      case SparqlAutomaticParser::SECONDS:
      case SparqlAutomaticParser::TIMEZONE:
      case SparqlAutomaticParser::TZ:
      case SparqlAutomaticParser::NOW:
      case SparqlAutomaticParser::UUID:
      case SparqlAutomaticParser::STRUUID:
      case SparqlAutomaticParser::SHA1:
      case SparqlAutomaticParser::SHA256:
      case SparqlAutomaticParser::SHA384:
      case SparqlAutomaticParser::SHA512:
      case SparqlAutomaticParser::MD5:
      case SparqlAutomaticParser::COALESCE:
      case SparqlAutomaticParser::IF:
      case SparqlAutomaticParser::STRLANG:
      case SparqlAutomaticParser::STRDT:
      case SparqlAutomaticParser::SAMETERM:
      case SparqlAutomaticParser::ISIRI:
      case SparqlAutomaticParser::ISURI:
      case SparqlAutomaticParser::ISBLANK:
      case SparqlAutomaticParser::ISLITERAL:
      case SparqlAutomaticParser::ISNUMERIC:
      case SparqlAutomaticParser::REGEX:
      case SparqlAutomaticParser::SUBSTR:
      case SparqlAutomaticParser::REPLACE:
      case SparqlAutomaticParser::EXISTS:
      case SparqlAutomaticParser::COUNT:
      case SparqlAutomaticParser::SUM:
      case SparqlAutomaticParser::MIN:
      case SparqlAutomaticParser::MAX:
      case SparqlAutomaticParser::AVG:
      case SparqlAutomaticParser::STDEV:
      case SparqlAutomaticParser::SAMPLE: {
        enterOuterAlt(_localctx, 1);
        setState(473);
        builtInCall();
        break;
      }

      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 2);
        setState(474);
        functionCall();
        break;
      }

      case SparqlAutomaticParser::T__1: {
        enterOuterAlt(_localctx, 3);
        setState(475);
        match(SparqlAutomaticParser::T__1);
        setState(476);
        expression();
        setState(479);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::AS) {
          setState(477);
          match(SparqlAutomaticParser::AS);
          setState(478);
          var();
        }
        setState(481);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2: {
        enterOuterAlt(_localctx, 4);
        setState(483);
        var();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HavingClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::HavingClauseContext::HavingClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::HavingClauseContext::HAVING() {
  return getToken(SparqlAutomaticParser::HAVING, 0);
}

std::vector<SparqlAutomaticParser::HavingConditionContext*>
SparqlAutomaticParser::HavingClauseContext::havingCondition() {
  return getRuleContexts<SparqlAutomaticParser::HavingConditionContext>();
}

SparqlAutomaticParser::HavingConditionContext*
SparqlAutomaticParser::HavingClauseContext::havingCondition(size_t i) {
  return getRuleContext<SparqlAutomaticParser::HavingConditionContext>(i);
}

size_t SparqlAutomaticParser::HavingClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleHavingClause;
}

void SparqlAutomaticParser::HavingClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterHavingClause(this);
}

void SparqlAutomaticParser::HavingClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitHavingClause(this);
}

std::any SparqlAutomaticParser::HavingClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitHavingClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::HavingClauseContext*
SparqlAutomaticParser::havingClause() {
  HavingClauseContext* _localctx =
      _tracker.createInstance<HavingClauseContext>(_ctx, getState());
  enterRule(_localctx, 44, SparqlAutomaticParser::RuleHavingClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(486);
    match(SparqlAutomaticParser::HAVING);
    setState(488);
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(487);
      havingCondition();
      setState(490);
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == SparqlAutomaticParser::T__1

             || _la == SparqlAutomaticParser::GROUP_CONCAT ||
             (((_la - 78) & ~0x3fULL) == 0) &&
                 ((1ULL << (_la - 78)) & 9223372036853727229) != 0 ||
             (((_la - 142) & ~0x3fULL) == 0) &&
                 ((1ULL << (_la - 142)) & 135) != 0);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HavingConditionContext
//------------------------------------------------------------------

SparqlAutomaticParser::HavingConditionContext::HavingConditionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::ConstraintContext*
SparqlAutomaticParser::HavingConditionContext::constraint() {
  return getRuleContext<SparqlAutomaticParser::ConstraintContext>(0);
}

size_t SparqlAutomaticParser::HavingConditionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleHavingCondition;
}

void SparqlAutomaticParser::HavingConditionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterHavingCondition(this);
}

void SparqlAutomaticParser::HavingConditionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitHavingCondition(this);
}

std::any SparqlAutomaticParser::HavingConditionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitHavingCondition(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::HavingConditionContext*
SparqlAutomaticParser::havingCondition() {
  HavingConditionContext* _localctx =
      _tracker.createInstance<HavingConditionContext>(_ctx, getState());
  enterRule(_localctx, 46, SparqlAutomaticParser::RuleHavingCondition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(492);
    constraint();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::OrderClauseContext::OrderClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::OrderClauseContext::ORDERBY() {
  return getToken(SparqlAutomaticParser::ORDERBY, 0);
}

tree::TerminalNode*
SparqlAutomaticParser::OrderClauseContext::INTERNALSORTBY() {
  return getToken(SparqlAutomaticParser::INTERNALSORTBY, 0);
}

std::vector<SparqlAutomaticParser::OrderConditionContext*>
SparqlAutomaticParser::OrderClauseContext::orderCondition() {
  return getRuleContexts<SparqlAutomaticParser::OrderConditionContext>();
}

SparqlAutomaticParser::OrderConditionContext*
SparqlAutomaticParser::OrderClauseContext::orderCondition(size_t i) {
  return getRuleContext<SparqlAutomaticParser::OrderConditionContext>(i);
}

size_t SparqlAutomaticParser::OrderClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleOrderClause;
}

void SparqlAutomaticParser::OrderClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterOrderClause(this);
}

void SparqlAutomaticParser::OrderClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitOrderClause(this);
}

std::any SparqlAutomaticParser::OrderClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitOrderClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::OrderClauseContext*
SparqlAutomaticParser::orderClause() {
  OrderClauseContext* _localctx =
      _tracker.createInstance<OrderClauseContext>(_ctx, getState());
  enterRule(_localctx, 48, SparqlAutomaticParser::RuleOrderClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(496);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::ORDERBY: {
        setState(494);
        antlrcpp::downCast<OrderClauseContext*>(_localctx)->orderBy =
            match(SparqlAutomaticParser::ORDERBY);
        break;
      }

      case SparqlAutomaticParser::INTERNALSORTBY: {
        setState(495);
        antlrcpp::downCast<OrderClauseContext*>(_localctx)->internalSortBy =
            match(SparqlAutomaticParser::INTERNALSORTBY);
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(499);
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(498);
      orderCondition();
      setState(501);
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (
        ((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 431008558088196) != 0 ||
        (((_la - 78) & ~0x3fULL) == 0) &&
            ((1ULL << (_la - 78)) & 9223372036853727229) != 0 ||
        (((_la - 142) & ~0x3fULL) == 0) && ((1ULL << (_la - 142)) & 183) != 0);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderConditionContext
//------------------------------------------------------------------

SparqlAutomaticParser::OrderConditionContext::OrderConditionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::BrackettedExpressionContext*
SparqlAutomaticParser::OrderConditionContext::brackettedExpression() {
  return getRuleContext<SparqlAutomaticParser::BrackettedExpressionContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::OrderConditionContext::ASC() {
  return getToken(SparqlAutomaticParser::ASC, 0);
}

tree::TerminalNode* SparqlAutomaticParser::OrderConditionContext::DESC() {
  return getToken(SparqlAutomaticParser::DESC, 0);
}

SparqlAutomaticParser::ConstraintContext*
SparqlAutomaticParser::OrderConditionContext::constraint() {
  return getRuleContext<SparqlAutomaticParser::ConstraintContext>(0);
}

SparqlAutomaticParser::VarContext*
SparqlAutomaticParser::OrderConditionContext::var() {
  return getRuleContext<SparqlAutomaticParser::VarContext>(0);
}

size_t SparqlAutomaticParser::OrderConditionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleOrderCondition;
}

void SparqlAutomaticParser::OrderConditionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterOrderCondition(this);
}

void SparqlAutomaticParser::OrderConditionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitOrderCondition(this);
}

std::any SparqlAutomaticParser::OrderConditionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitOrderCondition(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::OrderConditionContext*
SparqlAutomaticParser::orderCondition() {
  OrderConditionContext* _localctx =
      _tracker.createInstance<OrderConditionContext>(_ctx, getState());
  enterRule(_localctx, 50, SparqlAutomaticParser::RuleOrderCondition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(509);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::ASC:
      case SparqlAutomaticParser::DESC: {
        enterOuterAlt(_localctx, 1);
        setState(503);
        _la = _input->LA(1);
        if (!(_la == SparqlAutomaticParser::ASC

              || _la == SparqlAutomaticParser::DESC)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(504);
        brackettedExpression();
        break;
      }

      case SparqlAutomaticParser::T__1:
      case SparqlAutomaticParser::GROUP_CONCAT:
      case SparqlAutomaticParser::NOT:
      case SparqlAutomaticParser::STR:
      case SparqlAutomaticParser::LANG:
      case SparqlAutomaticParser::LANGMATCHES:
      case SparqlAutomaticParser::DATATYPE:
      case SparqlAutomaticParser::BOUND:
      case SparqlAutomaticParser::IRI:
      case SparqlAutomaticParser::URI:
      case SparqlAutomaticParser::BNODE:
      case SparqlAutomaticParser::RAND:
      case SparqlAutomaticParser::ABS:
      case SparqlAutomaticParser::CEIL:
      case SparqlAutomaticParser::FLOOR:
      case SparqlAutomaticParser::ROUND:
      case SparqlAutomaticParser::CONCAT:
      case SparqlAutomaticParser::STRLEN:
      case SparqlAutomaticParser::UCASE:
      case SparqlAutomaticParser::LCASE:
      case SparqlAutomaticParser::ENCODE_FOR_URI:
      case SparqlAutomaticParser::CONTAINS:
      case SparqlAutomaticParser::STRSTARTS:
      case SparqlAutomaticParser::STRENDS:
      case SparqlAutomaticParser::STRBEFORE:
      case SparqlAutomaticParser::STRAFTER:
      case SparqlAutomaticParser::YEAR:
      case SparqlAutomaticParser::MONTH:
      case SparqlAutomaticParser::DAY:
      case SparqlAutomaticParser::HOURS:
      case SparqlAutomaticParser::MINUTES:
      case SparqlAutomaticParser::SECONDS:
      case SparqlAutomaticParser::TIMEZONE:
      case SparqlAutomaticParser::TZ:
      case SparqlAutomaticParser::NOW:
      case SparqlAutomaticParser::UUID:
      case SparqlAutomaticParser::STRUUID:
      case SparqlAutomaticParser::SHA1:
      case SparqlAutomaticParser::SHA256:
      case SparqlAutomaticParser::SHA384:
      case SparqlAutomaticParser::SHA512:
      case SparqlAutomaticParser::MD5:
      case SparqlAutomaticParser::COALESCE:
      case SparqlAutomaticParser::IF:
      case SparqlAutomaticParser::STRLANG:
      case SparqlAutomaticParser::STRDT:
      case SparqlAutomaticParser::SAMETERM:
      case SparqlAutomaticParser::ISIRI:
      case SparqlAutomaticParser::ISURI:
      case SparqlAutomaticParser::ISBLANK:
      case SparqlAutomaticParser::ISLITERAL:
      case SparqlAutomaticParser::ISNUMERIC:
      case SparqlAutomaticParser::REGEX:
      case SparqlAutomaticParser::SUBSTR:
      case SparqlAutomaticParser::REPLACE:
      case SparqlAutomaticParser::EXISTS:
      case SparqlAutomaticParser::COUNT:
      case SparqlAutomaticParser::SUM:
      case SparqlAutomaticParser::MIN:
      case SparqlAutomaticParser::MAX:
      case SparqlAutomaticParser::AVG:
      case SparqlAutomaticParser::STDEV:
      case SparqlAutomaticParser::SAMPLE:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 2);
        setState(507);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SparqlAutomaticParser::T__1:
          case SparqlAutomaticParser::GROUP_CONCAT:
          case SparqlAutomaticParser::NOT:
          case SparqlAutomaticParser::STR:
          case SparqlAutomaticParser::LANG:
          case SparqlAutomaticParser::LANGMATCHES:
          case SparqlAutomaticParser::DATATYPE:
          case SparqlAutomaticParser::BOUND:
          case SparqlAutomaticParser::IRI:
          case SparqlAutomaticParser::URI:
          case SparqlAutomaticParser::BNODE:
          case SparqlAutomaticParser::RAND:
          case SparqlAutomaticParser::ABS:
          case SparqlAutomaticParser::CEIL:
          case SparqlAutomaticParser::FLOOR:
          case SparqlAutomaticParser::ROUND:
          case SparqlAutomaticParser::CONCAT:
          case SparqlAutomaticParser::STRLEN:
          case SparqlAutomaticParser::UCASE:
          case SparqlAutomaticParser::LCASE:
          case SparqlAutomaticParser::ENCODE_FOR_URI:
          case SparqlAutomaticParser::CONTAINS:
          case SparqlAutomaticParser::STRSTARTS:
          case SparqlAutomaticParser::STRENDS:
          case SparqlAutomaticParser::STRBEFORE:
          case SparqlAutomaticParser::STRAFTER:
          case SparqlAutomaticParser::YEAR:
          case SparqlAutomaticParser::MONTH:
          case SparqlAutomaticParser::DAY:
          case SparqlAutomaticParser::HOURS:
          case SparqlAutomaticParser::MINUTES:
          case SparqlAutomaticParser::SECONDS:
          case SparqlAutomaticParser::TIMEZONE:
          case SparqlAutomaticParser::TZ:
          case SparqlAutomaticParser::NOW:
          case SparqlAutomaticParser::UUID:
          case SparqlAutomaticParser::STRUUID:
          case SparqlAutomaticParser::SHA1:
          case SparqlAutomaticParser::SHA256:
          case SparqlAutomaticParser::SHA384:
          case SparqlAutomaticParser::SHA512:
          case SparqlAutomaticParser::MD5:
          case SparqlAutomaticParser::COALESCE:
          case SparqlAutomaticParser::IF:
          case SparqlAutomaticParser::STRLANG:
          case SparqlAutomaticParser::STRDT:
          case SparqlAutomaticParser::SAMETERM:
          case SparqlAutomaticParser::ISIRI:
          case SparqlAutomaticParser::ISURI:
          case SparqlAutomaticParser::ISBLANK:
          case SparqlAutomaticParser::ISLITERAL:
          case SparqlAutomaticParser::ISNUMERIC:
          case SparqlAutomaticParser::REGEX:
          case SparqlAutomaticParser::SUBSTR:
          case SparqlAutomaticParser::REPLACE:
          case SparqlAutomaticParser::EXISTS:
          case SparqlAutomaticParser::COUNT:
          case SparqlAutomaticParser::SUM:
          case SparqlAutomaticParser::MIN:
          case SparqlAutomaticParser::MAX:
          case SparqlAutomaticParser::AVG:
          case SparqlAutomaticParser::STDEV:
          case SparqlAutomaticParser::SAMPLE:
          case SparqlAutomaticParser::IRI_REF:
          case SparqlAutomaticParser::PNAME_NS:
          case SparqlAutomaticParser::PNAME_LN:
          case SparqlAutomaticParser::PREFIX_LANGTAG: {
            setState(505);
            constraint();
            break;
          }

          case SparqlAutomaticParser::VAR1:
          case SparqlAutomaticParser::VAR2: {
            setState(506);
            var();
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitOffsetClausesContext
//------------------------------------------------------------------

SparqlAutomaticParser::LimitOffsetClausesContext::LimitOffsetClausesContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::LimitClauseContext*
SparqlAutomaticParser::LimitOffsetClausesContext::limitClause() {
  return getRuleContext<SparqlAutomaticParser::LimitClauseContext>(0);
}

SparqlAutomaticParser::OffsetClauseContext*
SparqlAutomaticParser::LimitOffsetClausesContext::offsetClause() {
  return getRuleContext<SparqlAutomaticParser::OffsetClauseContext>(0);
}

SparqlAutomaticParser::TextLimitClauseContext*
SparqlAutomaticParser::LimitOffsetClausesContext::textLimitClause() {
  return getRuleContext<SparqlAutomaticParser::TextLimitClauseContext>(0);
}

size_t SparqlAutomaticParser::LimitOffsetClausesContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleLimitOffsetClauses;
}

void SparqlAutomaticParser::LimitOffsetClausesContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterLimitOffsetClauses(this);
}

void SparqlAutomaticParser::LimitOffsetClausesContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitLimitOffsetClauses(this);
}

std::any SparqlAutomaticParser::LimitOffsetClausesContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitLimitOffsetClauses(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::LimitOffsetClausesContext*
SparqlAutomaticParser::limitOffsetClauses() {
  LimitOffsetClausesContext* _localctx =
      _tracker.createInstance<LimitOffsetClausesContext>(_ctx, getState());
  enterRule(_localctx, 52, SparqlAutomaticParser::RuleLimitOffsetClauses);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(553);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 44, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(511);
        limitClause();
        setState(513);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::OFFSET) {
          setState(512);
          offsetClause();
        }
        setState(516);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::TEXTLIMIT) {
          setState(515);
          textLimitClause();
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(518);
        limitClause();
        setState(520);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::TEXTLIMIT) {
          setState(519);
          textLimitClause();
        }
        setState(523);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::OFFSET) {
          setState(522);
          offsetClause();
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(525);
        offsetClause();
        setState(527);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::LIMIT) {
          setState(526);
          limitClause();
        }
        setState(530);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::TEXTLIMIT) {
          setState(529);
          textLimitClause();
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(532);
        offsetClause();
        setState(534);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::TEXTLIMIT) {
          setState(533);
          textLimitClause();
        }
        setState(537);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::LIMIT) {
          setState(536);
          limitClause();
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(539);
        textLimitClause();
        setState(541);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::OFFSET) {
          setState(540);
          offsetClause();
        }
        setState(544);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::LIMIT) {
          setState(543);
          limitClause();
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(546);
        textLimitClause();
        setState(548);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::LIMIT) {
          setState(547);
          limitClause();
        }
        setState(551);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::OFFSET) {
          setState(550);
          offsetClause();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::LimitClauseContext::LimitClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::LimitClauseContext::LIMIT() {
  return getToken(SparqlAutomaticParser::LIMIT, 0);
}

SparqlAutomaticParser::IntegerContext*
SparqlAutomaticParser::LimitClauseContext::integer() {
  return getRuleContext<SparqlAutomaticParser::IntegerContext>(0);
}

size_t SparqlAutomaticParser::LimitClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleLimitClause;
}

void SparqlAutomaticParser::LimitClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterLimitClause(this);
}

void SparqlAutomaticParser::LimitClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitLimitClause(this);
}

std::any SparqlAutomaticParser::LimitClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitLimitClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::LimitClauseContext*
SparqlAutomaticParser::limitClause() {
  LimitClauseContext* _localctx =
      _tracker.createInstance<LimitClauseContext>(_ctx, getState());
  enterRule(_localctx, 54, SparqlAutomaticParser::RuleLimitClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(555);
    match(SparqlAutomaticParser::LIMIT);
    setState(556);
    integer();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OffsetClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::OffsetClauseContext::OffsetClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::OffsetClauseContext::OFFSET() {
  return getToken(SparqlAutomaticParser::OFFSET, 0);
}

SparqlAutomaticParser::IntegerContext*
SparqlAutomaticParser::OffsetClauseContext::integer() {
  return getRuleContext<SparqlAutomaticParser::IntegerContext>(0);
}

size_t SparqlAutomaticParser::OffsetClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleOffsetClause;
}

void SparqlAutomaticParser::OffsetClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterOffsetClause(this);
}

void SparqlAutomaticParser::OffsetClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitOffsetClause(this);
}

std::any SparqlAutomaticParser::OffsetClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitOffsetClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::OffsetClauseContext*
SparqlAutomaticParser::offsetClause() {
  OffsetClauseContext* _localctx =
      _tracker.createInstance<OffsetClauseContext>(_ctx, getState());
  enterRule(_localctx, 56, SparqlAutomaticParser::RuleOffsetClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(558);
    match(SparqlAutomaticParser::OFFSET);
    setState(559);
    integer();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextLimitClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::TextLimitClauseContext::TextLimitClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::TextLimitClauseContext::TEXTLIMIT() {
  return getToken(SparqlAutomaticParser::TEXTLIMIT, 0);
}

SparqlAutomaticParser::IntegerContext*
SparqlAutomaticParser::TextLimitClauseContext::integer() {
  return getRuleContext<SparqlAutomaticParser::IntegerContext>(0);
}

size_t SparqlAutomaticParser::TextLimitClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleTextLimitClause;
}

void SparqlAutomaticParser::TextLimitClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTextLimitClause(this);
}

void SparqlAutomaticParser::TextLimitClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTextLimitClause(this);
}

std::any SparqlAutomaticParser::TextLimitClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitTextLimitClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::TextLimitClauseContext*
SparqlAutomaticParser::textLimitClause() {
  TextLimitClauseContext* _localctx =
      _tracker.createInstance<TextLimitClauseContext>(_ctx, getState());
  enterRule(_localctx, 58, SparqlAutomaticParser::RuleTextLimitClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(561);
    match(SparqlAutomaticParser::TEXTLIMIT);
    setState(562);
    integer();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValuesClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::ValuesClauseContext::ValuesClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::ValuesClauseContext::VALUES() {
  return getToken(SparqlAutomaticParser::VALUES, 0);
}

SparqlAutomaticParser::DataBlockContext*
SparqlAutomaticParser::ValuesClauseContext::dataBlock() {
  return getRuleContext<SparqlAutomaticParser::DataBlockContext>(0);
}

size_t SparqlAutomaticParser::ValuesClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleValuesClause;
}

void SparqlAutomaticParser::ValuesClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterValuesClause(this);
}

void SparqlAutomaticParser::ValuesClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitValuesClause(this);
}

std::any SparqlAutomaticParser::ValuesClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitValuesClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ValuesClauseContext*
SparqlAutomaticParser::valuesClause() {
  ValuesClauseContext* _localctx =
      _tracker.createInstance<ValuesClauseContext>(_ctx, getState());
  enterRule(_localctx, 60, SparqlAutomaticParser::RuleValuesClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(566);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::VALUES) {
      setState(564);
      match(SparqlAutomaticParser::VALUES);
      setState(565);
      dataBlock();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateContext
//------------------------------------------------------------------

SparqlAutomaticParser::UpdateContext::UpdateContext(ParserRuleContext* parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::PrologueContext*>
SparqlAutomaticParser::UpdateContext::prologue() {
  return getRuleContexts<SparqlAutomaticParser::PrologueContext>();
}

SparqlAutomaticParser::PrologueContext*
SparqlAutomaticParser::UpdateContext::prologue(size_t i) {
  return getRuleContext<SparqlAutomaticParser::PrologueContext>(i);
}

std::vector<SparqlAutomaticParser::Update1Context*>
SparqlAutomaticParser::UpdateContext::update1() {
  return getRuleContexts<SparqlAutomaticParser::Update1Context>();
}

SparqlAutomaticParser::Update1Context*
SparqlAutomaticParser::UpdateContext::update1(size_t i) {
  return getRuleContext<SparqlAutomaticParser::Update1Context>(i);
}

size_t SparqlAutomaticParser::UpdateContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleUpdate;
}

void SparqlAutomaticParser::UpdateContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterUpdate(this);
}

void SparqlAutomaticParser::UpdateContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitUpdate(this);
}

std::any SparqlAutomaticParser::UpdateContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitUpdate(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::UpdateContext* SparqlAutomaticParser::update() {
  UpdateContext* _localctx =
      _tracker.createInstance<UpdateContext>(_ctx, getState());
  enterRule(_localctx, 62, SparqlAutomaticParser::RuleUpdate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(568);
    prologue();
    setState(583);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la - 53) & ~0x3fULL) == 0) && ((1ULL << (_la - 53)) & 15993) != 0) {
      setState(569);
      update1();
      setState(576);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
          _input, 46, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(570);
          match(SparqlAutomaticParser::T__5);
          setState(571);
          prologue();
          setState(572);
          update1();
        }
        setState(578);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
            _input, 46, _ctx);
      }
      setState(581);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SparqlAutomaticParser::T__5) {
        setState(579);
        match(SparqlAutomaticParser::T__5);
        setState(580);
        prologue();
      }
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update1Context
//------------------------------------------------------------------

SparqlAutomaticParser::Update1Context::Update1Context(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::LoadContext*
SparqlAutomaticParser::Update1Context::load() {
  return getRuleContext<SparqlAutomaticParser::LoadContext>(0);
}

SparqlAutomaticParser::ClearContext*
SparqlAutomaticParser::Update1Context::clear() {
  return getRuleContext<SparqlAutomaticParser::ClearContext>(0);
}

SparqlAutomaticParser::DropContext*
SparqlAutomaticParser::Update1Context::drop() {
  return getRuleContext<SparqlAutomaticParser::DropContext>(0);
}

SparqlAutomaticParser::AddContext*
SparqlAutomaticParser::Update1Context::add() {
  return getRuleContext<SparqlAutomaticParser::AddContext>(0);
}

SparqlAutomaticParser::MoveContext*
SparqlAutomaticParser::Update1Context::move() {
  return getRuleContext<SparqlAutomaticParser::MoveContext>(0);
}

SparqlAutomaticParser::CopyContext*
SparqlAutomaticParser::Update1Context::copy() {
  return getRuleContext<SparqlAutomaticParser::CopyContext>(0);
}

SparqlAutomaticParser::CreateContext*
SparqlAutomaticParser::Update1Context::create() {
  return getRuleContext<SparqlAutomaticParser::CreateContext>(0);
}

SparqlAutomaticParser::InsertDataContext*
SparqlAutomaticParser::Update1Context::insertData() {
  return getRuleContext<SparqlAutomaticParser::InsertDataContext>(0);
}

SparqlAutomaticParser::DeleteDataContext*
SparqlAutomaticParser::Update1Context::deleteData() {
  return getRuleContext<SparqlAutomaticParser::DeleteDataContext>(0);
}

SparqlAutomaticParser::DeleteWhereContext*
SparqlAutomaticParser::Update1Context::deleteWhere() {
  return getRuleContext<SparqlAutomaticParser::DeleteWhereContext>(0);
}

SparqlAutomaticParser::ModifyContext*
SparqlAutomaticParser::Update1Context::modify() {
  return getRuleContext<SparqlAutomaticParser::ModifyContext>(0);
}

size_t SparqlAutomaticParser::Update1Context::getRuleIndex() const {
  return SparqlAutomaticParser::RuleUpdate1;
}

void SparqlAutomaticParser::Update1Context::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterUpdate1(this);
}

void SparqlAutomaticParser::Update1Context::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitUpdate1(this);
}

std::any SparqlAutomaticParser::Update1Context::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitUpdate1(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::Update1Context* SparqlAutomaticParser::update1() {
  Update1Context* _localctx =
      _tracker.createInstance<Update1Context>(_ctx, getState());
  enterRule(_localctx, 64, SparqlAutomaticParser::RuleUpdate1);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(596);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 49, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(585);
        load();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(586);
        clear();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(587);
        drop();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(588);
        add();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(589);
        move();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(590);
        copy();
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(591);
        create();
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(592);
        insertData();
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(593);
        deleteData();
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(594);
        deleteWhere();
        break;
      }

      case 11: {
        enterOuterAlt(_localctx, 11);
        setState(595);
        modify();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadContext
//------------------------------------------------------------------

SparqlAutomaticParser::LoadContext::LoadContext(ParserRuleContext* parent,
                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::LoadContext::LOAD() {
  return getToken(SparqlAutomaticParser::LOAD, 0);
}

SparqlAutomaticParser::IriContext* SparqlAutomaticParser::LoadContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::LoadContext::SILENT() {
  return getToken(SparqlAutomaticParser::SILENT, 0);
}

tree::TerminalNode* SparqlAutomaticParser::LoadContext::INTO() {
  return getToken(SparqlAutomaticParser::INTO, 0);
}

SparqlAutomaticParser::GraphRefContext*
SparqlAutomaticParser::LoadContext::graphRef() {
  return getRuleContext<SparqlAutomaticParser::GraphRefContext>(0);
}

size_t SparqlAutomaticParser::LoadContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleLoad;
}

void SparqlAutomaticParser::LoadContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterLoad(this);
}

void SparqlAutomaticParser::LoadContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitLoad(this);
}

std::any SparqlAutomaticParser::LoadContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitLoad(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::LoadContext* SparqlAutomaticParser::load() {
  LoadContext* _localctx =
      _tracker.createInstance<LoadContext>(_ctx, getState());
  enterRule(_localctx, 66, SparqlAutomaticParser::RuleLoad);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(598);
    match(SparqlAutomaticParser::LOAD);
    setState(600);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::SILENT) {
      setState(599);
      match(SparqlAutomaticParser::SILENT);
    }
    setState(602);
    iri();
    setState(605);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::INTO) {
      setState(603);
      match(SparqlAutomaticParser::INTO);
      setState(604);
      graphRef();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClearContext
//------------------------------------------------------------------

SparqlAutomaticParser::ClearContext::ClearContext(ParserRuleContext* parent,
                                                  size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::ClearContext::CLEAR() {
  return getToken(SparqlAutomaticParser::CLEAR, 0);
}

SparqlAutomaticParser::GraphRefAllContext*
SparqlAutomaticParser::ClearContext::graphRefAll() {
  return getRuleContext<SparqlAutomaticParser::GraphRefAllContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::ClearContext::SILENT() {
  return getToken(SparqlAutomaticParser::SILENT, 0);
}

size_t SparqlAutomaticParser::ClearContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleClear;
}

void SparqlAutomaticParser::ClearContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterClear(this);
}

void SparqlAutomaticParser::ClearContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitClear(this);
}

std::any SparqlAutomaticParser::ClearContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitClear(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ClearContext* SparqlAutomaticParser::clear() {
  ClearContext* _localctx =
      _tracker.createInstance<ClearContext>(_ctx, getState());
  enterRule(_localctx, 68, SparqlAutomaticParser::RuleClear);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(607);
    match(SparqlAutomaticParser::CLEAR);
    setState(609);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::SILENT) {
      setState(608);
      match(SparqlAutomaticParser::SILENT);
    }
    setState(611);
    graphRefAll();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropContext
//------------------------------------------------------------------

SparqlAutomaticParser::DropContext::DropContext(ParserRuleContext* parent,
                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::DropContext::DROP() {
  return getToken(SparqlAutomaticParser::DROP, 0);
}

SparqlAutomaticParser::GraphRefAllContext*
SparqlAutomaticParser::DropContext::graphRefAll() {
  return getRuleContext<SparqlAutomaticParser::GraphRefAllContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::DropContext::SILENT() {
  return getToken(SparqlAutomaticParser::SILENT, 0);
}

size_t SparqlAutomaticParser::DropContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleDrop;
}

void SparqlAutomaticParser::DropContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDrop(this);
}

void SparqlAutomaticParser::DropContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDrop(this);
}

std::any SparqlAutomaticParser::DropContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitDrop(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::DropContext* SparqlAutomaticParser::drop() {
  DropContext* _localctx =
      _tracker.createInstance<DropContext>(_ctx, getState());
  enterRule(_localctx, 70, SparqlAutomaticParser::RuleDrop);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(613);
    match(SparqlAutomaticParser::DROP);
    setState(615);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::SILENT) {
      setState(614);
      match(SparqlAutomaticParser::SILENT);
    }
    setState(617);
    graphRefAll();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateContext
//------------------------------------------------------------------

SparqlAutomaticParser::CreateContext::CreateContext(ParserRuleContext* parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::CreateContext::CREATE() {
  return getToken(SparqlAutomaticParser::CREATE, 0);
}

SparqlAutomaticParser::GraphRefContext*
SparqlAutomaticParser::CreateContext::graphRef() {
  return getRuleContext<SparqlAutomaticParser::GraphRefContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::CreateContext::SILENT() {
  return getToken(SparqlAutomaticParser::SILENT, 0);
}

size_t SparqlAutomaticParser::CreateContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleCreate;
}

void SparqlAutomaticParser::CreateContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterCreate(this);
}

void SparqlAutomaticParser::CreateContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitCreate(this);
}

std::any SparqlAutomaticParser::CreateContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitCreate(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::CreateContext* SparqlAutomaticParser::create() {
  CreateContext* _localctx =
      _tracker.createInstance<CreateContext>(_ctx, getState());
  enterRule(_localctx, 72, SparqlAutomaticParser::RuleCreate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(619);
    match(SparqlAutomaticParser::CREATE);
    setState(621);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::SILENT) {
      setState(620);
      match(SparqlAutomaticParser::SILENT);
    }
    setState(623);
    graphRef();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddContext
//------------------------------------------------------------------

SparqlAutomaticParser::AddContext::AddContext(ParserRuleContext* parent,
                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::AddContext::ADD() {
  return getToken(SparqlAutomaticParser::ADD, 0);
}

std::vector<SparqlAutomaticParser::GraphOrDefaultContext*>
SparqlAutomaticParser::AddContext::graphOrDefault() {
  return getRuleContexts<SparqlAutomaticParser::GraphOrDefaultContext>();
}

SparqlAutomaticParser::GraphOrDefaultContext*
SparqlAutomaticParser::AddContext::graphOrDefault(size_t i) {
  return getRuleContext<SparqlAutomaticParser::GraphOrDefaultContext>(i);
}

tree::TerminalNode* SparqlAutomaticParser::AddContext::TO() {
  return getToken(SparqlAutomaticParser::TO, 0);
}

tree::TerminalNode* SparqlAutomaticParser::AddContext::SILENT() {
  return getToken(SparqlAutomaticParser::SILENT, 0);
}

size_t SparqlAutomaticParser::AddContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleAdd;
}

void SparqlAutomaticParser::AddContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterAdd(this);
}

void SparqlAutomaticParser::AddContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitAdd(this);
}

std::any SparqlAutomaticParser::AddContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitAdd(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::AddContext* SparqlAutomaticParser::add() {
  AddContext* _localctx = _tracker.createInstance<AddContext>(_ctx, getState());
  enterRule(_localctx, 74, SparqlAutomaticParser::RuleAdd);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(625);
    match(SparqlAutomaticParser::ADD);
    setState(627);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::SILENT) {
      setState(626);
      match(SparqlAutomaticParser::SILENT);
    }
    setState(629);
    graphOrDefault();
    setState(630);
    match(SparqlAutomaticParser::TO);
    setState(631);
    graphOrDefault();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MoveContext
//------------------------------------------------------------------

SparqlAutomaticParser::MoveContext::MoveContext(ParserRuleContext* parent,
                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::MoveContext::MOVE() {
  return getToken(SparqlAutomaticParser::MOVE, 0);
}

std::vector<SparqlAutomaticParser::GraphOrDefaultContext*>
SparqlAutomaticParser::MoveContext::graphOrDefault() {
  return getRuleContexts<SparqlAutomaticParser::GraphOrDefaultContext>();
}

SparqlAutomaticParser::GraphOrDefaultContext*
SparqlAutomaticParser::MoveContext::graphOrDefault(size_t i) {
  return getRuleContext<SparqlAutomaticParser::GraphOrDefaultContext>(i);
}

tree::TerminalNode* SparqlAutomaticParser::MoveContext::TO() {
  return getToken(SparqlAutomaticParser::TO, 0);
}

tree::TerminalNode* SparqlAutomaticParser::MoveContext::SILENT() {
  return getToken(SparqlAutomaticParser::SILENT, 0);
}

size_t SparqlAutomaticParser::MoveContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleMove;
}

void SparqlAutomaticParser::MoveContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterMove(this);
}

void SparqlAutomaticParser::MoveContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitMove(this);
}

std::any SparqlAutomaticParser::MoveContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitMove(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::MoveContext* SparqlAutomaticParser::move() {
  MoveContext* _localctx =
      _tracker.createInstance<MoveContext>(_ctx, getState());
  enterRule(_localctx, 76, SparqlAutomaticParser::RuleMove);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(633);
    match(SparqlAutomaticParser::MOVE);
    setState(635);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::SILENT) {
      setState(634);
      match(SparqlAutomaticParser::SILENT);
    }
    setState(637);
    graphOrDefault();
    setState(638);
    match(SparqlAutomaticParser::TO);
    setState(639);
    graphOrDefault();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CopyContext
//------------------------------------------------------------------

SparqlAutomaticParser::CopyContext::CopyContext(ParserRuleContext* parent,
                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::CopyContext::COPY() {
  return getToken(SparqlAutomaticParser::COPY, 0);
}

std::vector<SparqlAutomaticParser::GraphOrDefaultContext*>
SparqlAutomaticParser::CopyContext::graphOrDefault() {
  return getRuleContexts<SparqlAutomaticParser::GraphOrDefaultContext>();
}

SparqlAutomaticParser::GraphOrDefaultContext*
SparqlAutomaticParser::CopyContext::graphOrDefault(size_t i) {
  return getRuleContext<SparqlAutomaticParser::GraphOrDefaultContext>(i);
}

tree::TerminalNode* SparqlAutomaticParser::CopyContext::TO() {
  return getToken(SparqlAutomaticParser::TO, 0);
}

tree::TerminalNode* SparqlAutomaticParser::CopyContext::SILENT() {
  return getToken(SparqlAutomaticParser::SILENT, 0);
}

size_t SparqlAutomaticParser::CopyContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleCopy;
}

void SparqlAutomaticParser::CopyContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterCopy(this);
}

void SparqlAutomaticParser::CopyContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitCopy(this);
}

std::any SparqlAutomaticParser::CopyContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitCopy(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::CopyContext* SparqlAutomaticParser::copy() {
  CopyContext* _localctx =
      _tracker.createInstance<CopyContext>(_ctx, getState());
  enterRule(_localctx, 78, SparqlAutomaticParser::RuleCopy);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(641);
    match(SparqlAutomaticParser::COPY);
    setState(643);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::SILENT) {
      setState(642);
      match(SparqlAutomaticParser::SILENT);
    }
    setState(645);
    graphOrDefault();
    setState(646);
    match(SparqlAutomaticParser::TO);
    setState(647);
    graphOrDefault();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertDataContext
//------------------------------------------------------------------

SparqlAutomaticParser::InsertDataContext::InsertDataContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::InsertDataContext::INSERT() {
  return getToken(SparqlAutomaticParser::INSERT, 0);
}

tree::TerminalNode* SparqlAutomaticParser::InsertDataContext::DATA() {
  return getToken(SparqlAutomaticParser::DATA, 0);
}

SparqlAutomaticParser::QuadDataContext*
SparqlAutomaticParser::InsertDataContext::quadData() {
  return getRuleContext<SparqlAutomaticParser::QuadDataContext>(0);
}

size_t SparqlAutomaticParser::InsertDataContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleInsertData;
}

void SparqlAutomaticParser::InsertDataContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterInsertData(this);
}

void SparqlAutomaticParser::InsertDataContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitInsertData(this);
}

std::any SparqlAutomaticParser::InsertDataContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitInsertData(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::InsertDataContext* SparqlAutomaticParser::insertData() {
  InsertDataContext* _localctx =
      _tracker.createInstance<InsertDataContext>(_ctx, getState());
  enterRule(_localctx, 80, SparqlAutomaticParser::RuleInsertData);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(649);
    match(SparqlAutomaticParser::INSERT);
    setState(650);
    match(SparqlAutomaticParser::DATA);
    setState(651);
    quadData();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteDataContext
//------------------------------------------------------------------

SparqlAutomaticParser::DeleteDataContext::DeleteDataContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::DeleteDataContext::DELETE() {
  return getToken(SparqlAutomaticParser::DELETE, 0);
}

tree::TerminalNode* SparqlAutomaticParser::DeleteDataContext::DATA() {
  return getToken(SparqlAutomaticParser::DATA, 0);
}

SparqlAutomaticParser::QuadDataContext*
SparqlAutomaticParser::DeleteDataContext::quadData() {
  return getRuleContext<SparqlAutomaticParser::QuadDataContext>(0);
}

size_t SparqlAutomaticParser::DeleteDataContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleDeleteData;
}

void SparqlAutomaticParser::DeleteDataContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDeleteData(this);
}

void SparqlAutomaticParser::DeleteDataContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDeleteData(this);
}

std::any SparqlAutomaticParser::DeleteDataContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitDeleteData(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::DeleteDataContext* SparqlAutomaticParser::deleteData() {
  DeleteDataContext* _localctx =
      _tracker.createInstance<DeleteDataContext>(_ctx, getState());
  enterRule(_localctx, 82, SparqlAutomaticParser::RuleDeleteData);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(653);
    match(SparqlAutomaticParser::DELETE);
    setState(654);
    match(SparqlAutomaticParser::DATA);
    setState(655);
    quadData();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteWhereContext
//------------------------------------------------------------------

SparqlAutomaticParser::DeleteWhereContext::DeleteWhereContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::DeleteWhereContext::DELETE() {
  return getToken(SparqlAutomaticParser::DELETE, 0);
}

tree::TerminalNode* SparqlAutomaticParser::DeleteWhereContext::WHERE() {
  return getToken(SparqlAutomaticParser::WHERE, 0);
}

SparqlAutomaticParser::QuadPatternContext*
SparqlAutomaticParser::DeleteWhereContext::quadPattern() {
  return getRuleContext<SparqlAutomaticParser::QuadPatternContext>(0);
}

size_t SparqlAutomaticParser::DeleteWhereContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleDeleteWhere;
}

void SparqlAutomaticParser::DeleteWhereContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDeleteWhere(this);
}

void SparqlAutomaticParser::DeleteWhereContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDeleteWhere(this);
}

std::any SparqlAutomaticParser::DeleteWhereContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitDeleteWhere(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::DeleteWhereContext*
SparqlAutomaticParser::deleteWhere() {
  DeleteWhereContext* _localctx =
      _tracker.createInstance<DeleteWhereContext>(_ctx, getState());
  enterRule(_localctx, 84, SparqlAutomaticParser::RuleDeleteWhere);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(657);
    match(SparqlAutomaticParser::DELETE);
    setState(658);
    match(SparqlAutomaticParser::WHERE);
    setState(659);
    quadPattern();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModifyContext
//------------------------------------------------------------------

SparqlAutomaticParser::ModifyContext::ModifyContext(ParserRuleContext* parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::ModifyContext::WHERE() {
  return getToken(SparqlAutomaticParser::WHERE, 0);
}

SparqlAutomaticParser::GroupGraphPatternContext*
SparqlAutomaticParser::ModifyContext::groupGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::GroupGraphPatternContext>(0);
}

SparqlAutomaticParser::DeleteClauseContext*
SparqlAutomaticParser::ModifyContext::deleteClause() {
  return getRuleContext<SparqlAutomaticParser::DeleteClauseContext>(0);
}

SparqlAutomaticParser::InsertClauseContext*
SparqlAutomaticParser::ModifyContext::insertClause() {
  return getRuleContext<SparqlAutomaticParser::InsertClauseContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::ModifyContext::WITH() {
  return getToken(SparqlAutomaticParser::WITH, 0);
}

SparqlAutomaticParser::IriContext* SparqlAutomaticParser::ModifyContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

std::vector<SparqlAutomaticParser::UsingClauseContext*>
SparqlAutomaticParser::ModifyContext::usingClause() {
  return getRuleContexts<SparqlAutomaticParser::UsingClauseContext>();
}

SparqlAutomaticParser::UsingClauseContext*
SparqlAutomaticParser::ModifyContext::usingClause(size_t i) {
  return getRuleContext<SparqlAutomaticParser::UsingClauseContext>(i);
}

size_t SparqlAutomaticParser::ModifyContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleModify;
}

void SparqlAutomaticParser::ModifyContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterModify(this);
}

void SparqlAutomaticParser::ModifyContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitModify(this);
}

std::any SparqlAutomaticParser::ModifyContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitModify(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ModifyContext* SparqlAutomaticParser::modify() {
  ModifyContext* _localctx =
      _tracker.createInstance<ModifyContext>(_ctx, getState());
  enterRule(_localctx, 86, SparqlAutomaticParser::RuleModify);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(663);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::WITH) {
      setState(661);
      match(SparqlAutomaticParser::WITH);
      setState(662);
      iri();
    }
    setState(670);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::DELETE: {
        setState(665);
        deleteClause();
        setState(667);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::INSERT) {
          setState(666);
          insertClause();
        }
        break;
      }

      case SparqlAutomaticParser::INSERT: {
        setState(669);
        insertClause();
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(675);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::USING) {
      setState(672);
      usingClause();
      setState(677);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(678);
    match(SparqlAutomaticParser::WHERE);
    setState(679);
    groupGraphPattern();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::DeleteClauseContext::DeleteClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::DeleteClauseContext::DELETE() {
  return getToken(SparqlAutomaticParser::DELETE, 0);
}

SparqlAutomaticParser::QuadPatternContext*
SparqlAutomaticParser::DeleteClauseContext::quadPattern() {
  return getRuleContext<SparqlAutomaticParser::QuadPatternContext>(0);
}

size_t SparqlAutomaticParser::DeleteClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleDeleteClause;
}

void SparqlAutomaticParser::DeleteClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDeleteClause(this);
}

void SparqlAutomaticParser::DeleteClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDeleteClause(this);
}

std::any SparqlAutomaticParser::DeleteClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitDeleteClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::DeleteClauseContext*
SparqlAutomaticParser::deleteClause() {
  DeleteClauseContext* _localctx =
      _tracker.createInstance<DeleteClauseContext>(_ctx, getState());
  enterRule(_localctx, 88, SparqlAutomaticParser::RuleDeleteClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(681);
    match(SparqlAutomaticParser::DELETE);
    setState(682);
    quadPattern();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::InsertClauseContext::InsertClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::InsertClauseContext::INSERT() {
  return getToken(SparqlAutomaticParser::INSERT, 0);
}

SparqlAutomaticParser::QuadPatternContext*
SparqlAutomaticParser::InsertClauseContext::quadPattern() {
  return getRuleContext<SparqlAutomaticParser::QuadPatternContext>(0);
}

size_t SparqlAutomaticParser::InsertClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleInsertClause;
}

void SparqlAutomaticParser::InsertClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterInsertClause(this);
}

void SparqlAutomaticParser::InsertClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitInsertClause(this);
}

std::any SparqlAutomaticParser::InsertClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitInsertClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::InsertClauseContext*
SparqlAutomaticParser::insertClause() {
  InsertClauseContext* _localctx =
      _tracker.createInstance<InsertClauseContext>(_ctx, getState());
  enterRule(_localctx, 90, SparqlAutomaticParser::RuleInsertClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(684);
    match(SparqlAutomaticParser::INSERT);
    setState(685);
    quadPattern();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UsingClauseContext
//------------------------------------------------------------------

SparqlAutomaticParser::UsingClauseContext::UsingClauseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::UsingClauseContext::USING() {
  return getToken(SparqlAutomaticParser::USING, 0);
}

SparqlAutomaticParser::IriContext*
SparqlAutomaticParser::UsingClauseContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::UsingClauseContext::NAMED() {
  return getToken(SparqlAutomaticParser::NAMED, 0);
}

size_t SparqlAutomaticParser::UsingClauseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleUsingClause;
}

void SparqlAutomaticParser::UsingClauseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterUsingClause(this);
}

void SparqlAutomaticParser::UsingClauseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitUsingClause(this);
}

std::any SparqlAutomaticParser::UsingClauseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitUsingClause(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::UsingClauseContext*
SparqlAutomaticParser::usingClause() {
  UsingClauseContext* _localctx =
      _tracker.createInstance<UsingClauseContext>(_ctx, getState());
  enterRule(_localctx, 92, SparqlAutomaticParser::RuleUsingClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(687);
    match(SparqlAutomaticParser::USING);
    setState(691);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        setState(688);
        iri();
        break;
      }

      case SparqlAutomaticParser::NAMED: {
        setState(689);
        match(SparqlAutomaticParser::NAMED);
        setState(690);
        iri();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GraphOrDefaultContext
//------------------------------------------------------------------

SparqlAutomaticParser::GraphOrDefaultContext::GraphOrDefaultContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::GraphOrDefaultContext::DEFAULT() {
  return getToken(SparqlAutomaticParser::DEFAULT, 0);
}

SparqlAutomaticParser::IriContext*
SparqlAutomaticParser::GraphOrDefaultContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::GraphOrDefaultContext::GRAPH() {
  return getToken(SparqlAutomaticParser::GRAPH, 0);
}

size_t SparqlAutomaticParser::GraphOrDefaultContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleGraphOrDefault;
}

void SparqlAutomaticParser::GraphOrDefaultContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterGraphOrDefault(this);
}

void SparqlAutomaticParser::GraphOrDefaultContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitGraphOrDefault(this);
}

std::any SparqlAutomaticParser::GraphOrDefaultContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGraphOrDefault(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GraphOrDefaultContext*
SparqlAutomaticParser::graphOrDefault() {
  GraphOrDefaultContext* _localctx =
      _tracker.createInstance<GraphOrDefaultContext>(_ctx, getState());
  enterRule(_localctx, 94, SparqlAutomaticParser::RuleGraphOrDefault);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(698);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::DEFAULT: {
        enterOuterAlt(_localctx, 1);
        setState(693);
        match(SparqlAutomaticParser::DEFAULT);
        break;
      }

      case SparqlAutomaticParser::GRAPH:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 2);
        setState(695);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::GRAPH) {
          setState(694);
          match(SparqlAutomaticParser::GRAPH);
        }
        setState(697);
        iri();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GraphRefContext
//------------------------------------------------------------------

SparqlAutomaticParser::GraphRefContext::GraphRefContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::GraphRefContext::GRAPH() {
  return getToken(SparqlAutomaticParser::GRAPH, 0);
}

SparqlAutomaticParser::IriContext*
SparqlAutomaticParser::GraphRefContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

size_t SparqlAutomaticParser::GraphRefContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleGraphRef;
}

void SparqlAutomaticParser::GraphRefContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterGraphRef(this);
}

void SparqlAutomaticParser::GraphRefContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitGraphRef(this);
}

std::any SparqlAutomaticParser::GraphRefContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGraphRef(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GraphRefContext* SparqlAutomaticParser::graphRef() {
  GraphRefContext* _localctx =
      _tracker.createInstance<GraphRefContext>(_ctx, getState());
  enterRule(_localctx, 96, SparqlAutomaticParser::RuleGraphRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(700);
    match(SparqlAutomaticParser::GRAPH);
    setState(701);
    iri();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GraphRefAllContext
//------------------------------------------------------------------

SparqlAutomaticParser::GraphRefAllContext::GraphRefAllContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::GraphRefContext*
SparqlAutomaticParser::GraphRefAllContext::graphRef() {
  return getRuleContext<SparqlAutomaticParser::GraphRefContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::GraphRefAllContext::DEFAULT() {
  return getToken(SparqlAutomaticParser::DEFAULT, 0);
}

tree::TerminalNode* SparqlAutomaticParser::GraphRefAllContext::NAMED() {
  return getToken(SparqlAutomaticParser::NAMED, 0);
}

tree::TerminalNode* SparqlAutomaticParser::GraphRefAllContext::ALL() {
  return getToken(SparqlAutomaticParser::ALL, 0);
}

size_t SparqlAutomaticParser::GraphRefAllContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleGraphRefAll;
}

void SparqlAutomaticParser::GraphRefAllContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterGraphRefAll(this);
}

void SparqlAutomaticParser::GraphRefAllContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitGraphRefAll(this);
}

std::any SparqlAutomaticParser::GraphRefAllContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGraphRefAll(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GraphRefAllContext*
SparqlAutomaticParser::graphRefAll() {
  GraphRefAllContext* _localctx =
      _tracker.createInstance<GraphRefAllContext>(_ctx, getState());
  enterRule(_localctx, 98, SparqlAutomaticParser::RuleGraphRefAll);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(707);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::GRAPH: {
        enterOuterAlt(_localctx, 1);
        setState(703);
        graphRef();
        break;
      }

      case SparqlAutomaticParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(704);
        match(SparqlAutomaticParser::DEFAULT);
        break;
      }

      case SparqlAutomaticParser::NAMED: {
        enterOuterAlt(_localctx, 3);
        setState(705);
        match(SparqlAutomaticParser::NAMED);
        break;
      }

      case SparqlAutomaticParser::ALL: {
        enterOuterAlt(_localctx, 4);
        setState(706);
        match(SparqlAutomaticParser::ALL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuadPatternContext
//------------------------------------------------------------------

SparqlAutomaticParser::QuadPatternContext::QuadPatternContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::QuadsContext*
SparqlAutomaticParser::QuadPatternContext::quads() {
  return getRuleContext<SparqlAutomaticParser::QuadsContext>(0);
}

size_t SparqlAutomaticParser::QuadPatternContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleQuadPattern;
}

void SparqlAutomaticParser::QuadPatternContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterQuadPattern(this);
}

void SparqlAutomaticParser::QuadPatternContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitQuadPattern(this);
}

std::any SparqlAutomaticParser::QuadPatternContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitQuadPattern(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::QuadPatternContext*
SparqlAutomaticParser::quadPattern() {
  QuadPatternContext* _localctx =
      _tracker.createInstance<QuadPatternContext>(_ctx, getState());
  enterRule(_localctx, 100, SparqlAutomaticParser::RuleQuadPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(709);
    match(SparqlAutomaticParser::T__3);
    setState(710);
    quads();
    setState(711);
    match(SparqlAutomaticParser::T__4);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuadDataContext
//------------------------------------------------------------------

SparqlAutomaticParser::QuadDataContext::QuadDataContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::QuadsContext*
SparqlAutomaticParser::QuadDataContext::quads() {
  return getRuleContext<SparqlAutomaticParser::QuadsContext>(0);
}

size_t SparqlAutomaticParser::QuadDataContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleQuadData;
}

void SparqlAutomaticParser::QuadDataContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterQuadData(this);
}

void SparqlAutomaticParser::QuadDataContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitQuadData(this);
}

std::any SparqlAutomaticParser::QuadDataContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitQuadData(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::QuadDataContext* SparqlAutomaticParser::quadData() {
  QuadDataContext* _localctx =
      _tracker.createInstance<QuadDataContext>(_ctx, getState());
  enterRule(_localctx, 102, SparqlAutomaticParser::RuleQuadData);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(713);
    match(SparqlAutomaticParser::T__3);
    setState(714);
    quads();
    setState(715);
    match(SparqlAutomaticParser::T__4);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuadsContext
//------------------------------------------------------------------

SparqlAutomaticParser::QuadsContext::QuadsContext(ParserRuleContext* parent,
                                                  size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::TriplesTemplateContext*>
SparqlAutomaticParser::QuadsContext::triplesTemplate() {
  return getRuleContexts<SparqlAutomaticParser::TriplesTemplateContext>();
}

SparqlAutomaticParser::TriplesTemplateContext*
SparqlAutomaticParser::QuadsContext::triplesTemplate(size_t i) {
  return getRuleContext<SparqlAutomaticParser::TriplesTemplateContext>(i);
}

std::vector<SparqlAutomaticParser::QuadsNotTriplesContext*>
SparqlAutomaticParser::QuadsContext::quadsNotTriples() {
  return getRuleContexts<SparqlAutomaticParser::QuadsNotTriplesContext>();
}

SparqlAutomaticParser::QuadsNotTriplesContext*
SparqlAutomaticParser::QuadsContext::quadsNotTriples(size_t i) {
  return getRuleContext<SparqlAutomaticParser::QuadsNotTriplesContext>(i);
}

size_t SparqlAutomaticParser::QuadsContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleQuads;
}

void SparqlAutomaticParser::QuadsContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterQuads(this);
}

void SparqlAutomaticParser::QuadsContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitQuads(this);
}

std::any SparqlAutomaticParser::QuadsContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitQuads(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::QuadsContext* SparqlAutomaticParser::quads() {
  QuadsContext* _localctx =
      _tracker.createInstance<QuadsContext>(_ctx, getState());
  enterRule(_localctx, 104, SparqlAutomaticParser::RuleQuads);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(718);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 805371908) != 0 ||
        (((_la - 142) & ~0x3fULL) == 0) &&
            ((1ULL << (_la - 142)) & 29228991) != 0) {
      setState(717);
      triplesTemplate();
    }
    setState(729);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::GRAPH) {
      setState(720);
      quadsNotTriples();
      setState(722);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SparqlAutomaticParser::T__6) {
        setState(721);
        match(SparqlAutomaticParser::T__6);
      }
      setState(725);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 805371908) != 0 ||
          (((_la - 142) & ~0x3fULL) == 0) &&
              ((1ULL << (_la - 142)) & 29228991) != 0) {
        setState(724);
        triplesTemplate();
      }
      setState(731);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuadsNotTriplesContext
//------------------------------------------------------------------

SparqlAutomaticParser::QuadsNotTriplesContext::QuadsNotTriplesContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::QuadsNotTriplesContext::GRAPH() {
  return getToken(SparqlAutomaticParser::GRAPH, 0);
}

SparqlAutomaticParser::VarOrIriContext*
SparqlAutomaticParser::QuadsNotTriplesContext::varOrIri() {
  return getRuleContext<SparqlAutomaticParser::VarOrIriContext>(0);
}

SparqlAutomaticParser::TriplesTemplateContext*
SparqlAutomaticParser::QuadsNotTriplesContext::triplesTemplate() {
  return getRuleContext<SparqlAutomaticParser::TriplesTemplateContext>(0);
}

size_t SparqlAutomaticParser::QuadsNotTriplesContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleQuadsNotTriples;
}

void SparqlAutomaticParser::QuadsNotTriplesContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterQuadsNotTriples(this);
}

void SparqlAutomaticParser::QuadsNotTriplesContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitQuadsNotTriples(this);
}

std::any SparqlAutomaticParser::QuadsNotTriplesContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitQuadsNotTriples(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::QuadsNotTriplesContext*
SparqlAutomaticParser::quadsNotTriples() {
  QuadsNotTriplesContext* _localctx =
      _tracker.createInstance<QuadsNotTriplesContext>(_ctx, getState());
  enterRule(_localctx, 106, SparqlAutomaticParser::RuleQuadsNotTriples);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(732);
    match(SparqlAutomaticParser::GRAPH);
    setState(733);
    varOrIri();
    setState(734);
    match(SparqlAutomaticParser::T__3);
    setState(736);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 805371908) != 0 ||
        (((_la - 142) & ~0x3fULL) == 0) &&
            ((1ULL << (_la - 142)) & 29228991) != 0) {
      setState(735);
      triplesTemplate();
    }
    setState(738);
    match(SparqlAutomaticParser::T__4);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriplesTemplateContext
//------------------------------------------------------------------

SparqlAutomaticParser::TriplesTemplateContext::TriplesTemplateContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::TriplesSameSubjectContext*>
SparqlAutomaticParser::TriplesTemplateContext::triplesSameSubject() {
  return getRuleContexts<SparqlAutomaticParser::TriplesSameSubjectContext>();
}

SparqlAutomaticParser::TriplesSameSubjectContext*
SparqlAutomaticParser::TriplesTemplateContext::triplesSameSubject(size_t i) {
  return getRuleContext<SparqlAutomaticParser::TriplesSameSubjectContext>(i);
}

size_t SparqlAutomaticParser::TriplesTemplateContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleTriplesTemplate;
}

void SparqlAutomaticParser::TriplesTemplateContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTriplesTemplate(this);
}

void SparqlAutomaticParser::TriplesTemplateContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTriplesTemplate(this);
}

std::any SparqlAutomaticParser::TriplesTemplateContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitTriplesTemplate(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::TriplesTemplateContext*
SparqlAutomaticParser::triplesTemplate() {
  TriplesTemplateContext* _localctx =
      _tracker.createInstance<TriplesTemplateContext>(_ctx, getState());
  enterRule(_localctx, 108, SparqlAutomaticParser::RuleTriplesTemplate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(740);
    triplesSameSubject();
    setState(745);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71,
                                                                     _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(741);
        match(SparqlAutomaticParser::T__6);
        setState(742);
        triplesSameSubject();
      }
      setState(747);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
          _input, 71, _ctx);
    }
    setState(749);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::T__6) {
      setState(748);
      match(SparqlAutomaticParser::T__6);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupGraphPatternContext
//------------------------------------------------------------------

SparqlAutomaticParser::GroupGraphPatternContext::GroupGraphPatternContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::SubSelectContext*
SparqlAutomaticParser::GroupGraphPatternContext::subSelect() {
  return getRuleContext<SparqlAutomaticParser::SubSelectContext>(0);
}

SparqlAutomaticParser::GroupGraphPatternSubContext*
SparqlAutomaticParser::GroupGraphPatternContext::groupGraphPatternSub() {
  return getRuleContext<SparqlAutomaticParser::GroupGraphPatternSubContext>(0);
}

size_t SparqlAutomaticParser::GroupGraphPatternContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleGroupGraphPattern;
}

void SparqlAutomaticParser::GroupGraphPatternContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterGroupGraphPattern(this);
}

void SparqlAutomaticParser::GroupGraphPatternContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitGroupGraphPattern(this);
}

std::any SparqlAutomaticParser::GroupGraphPatternContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGroupGraphPattern(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GroupGraphPatternContext*
SparqlAutomaticParser::groupGraphPattern() {
  GroupGraphPatternContext* _localctx =
      _tracker.createInstance<GroupGraphPatternContext>(_ctx, getState());
  enterRule(_localctx, 110, SparqlAutomaticParser::RuleGroupGraphPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(751);
    match(SparqlAutomaticParser::T__3);
    setState(754);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::SELECT: {
        setState(752);
        subSelect();
        break;
      }

      case SparqlAutomaticParser::T__1:
      case SparqlAutomaticParser::T__3:
      case SparqlAutomaticParser::T__4:
      case SparqlAutomaticParser::T__15:
      case SparqlAutomaticParser::T__27:
      case SparqlAutomaticParser::T__28:
      case SparqlAutomaticParser::VALUES:
      case SparqlAutomaticParser::GRAPH:
      case SparqlAutomaticParser::OPTIONAL:
      case SparqlAutomaticParser::SERVICE:
      case SparqlAutomaticParser::BIND:
      case SparqlAutomaticParser::MINUS:
      case SparqlAutomaticParser::FILTER:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::BLANK_NODE_LABEL:
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2:
      case SparqlAutomaticParser::PREFIX_LANGTAG:
      case SparqlAutomaticParser::INTEGER:
      case SparqlAutomaticParser::DECIMAL:
      case SparqlAutomaticParser::DOUBLE:
      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE:
      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE:
      case SparqlAutomaticParser::STRING_LITERAL1:
      case SparqlAutomaticParser::STRING_LITERAL2:
      case SparqlAutomaticParser::STRING_LITERAL_LONG1:
      case SparqlAutomaticParser::STRING_LITERAL_LONG2:
      case SparqlAutomaticParser::NIL:
      case SparqlAutomaticParser::ANON: {
        setState(753);
        groupGraphPatternSub();
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(756);
    match(SparqlAutomaticParser::T__4);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupGraphPatternSubContext
//------------------------------------------------------------------

SparqlAutomaticParser::GroupGraphPatternSubContext::GroupGraphPatternSubContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::TriplesBlockContext*
SparqlAutomaticParser::GroupGraphPatternSubContext::triplesBlock() {
  return getRuleContext<SparqlAutomaticParser::TriplesBlockContext>(0);
}

std::vector<
    SparqlAutomaticParser::GraphPatternNotTriplesAndMaybeTriplesContext*>
SparqlAutomaticParser::GroupGraphPatternSubContext::
    graphPatternNotTriplesAndMaybeTriples() {
  return getRuleContexts<
      SparqlAutomaticParser::GraphPatternNotTriplesAndMaybeTriplesContext>();
}

SparqlAutomaticParser::GraphPatternNotTriplesAndMaybeTriplesContext*
SparqlAutomaticParser::GroupGraphPatternSubContext::
    graphPatternNotTriplesAndMaybeTriples(size_t i) {
  return getRuleContext<
      SparqlAutomaticParser::GraphPatternNotTriplesAndMaybeTriplesContext>(i);
}

size_t SparqlAutomaticParser::GroupGraphPatternSubContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleGroupGraphPatternSub;
}

void SparqlAutomaticParser::GroupGraphPatternSubContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupGraphPatternSub(this);
}

void SparqlAutomaticParser::GroupGraphPatternSubContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitGroupGraphPatternSub(this);
}

std::any SparqlAutomaticParser::GroupGraphPatternSubContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGroupGraphPatternSub(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GroupGraphPatternSubContext*
SparqlAutomaticParser::groupGraphPatternSub() {
  GroupGraphPatternSubContext* _localctx =
      _tracker.createInstance<GroupGraphPatternSubContext>(_ctx, getState());
  enterRule(_localctx, 112, SparqlAutomaticParser::RuleGroupGraphPatternSub);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(759);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 805371908) != 0 ||
        (((_la - 142) & ~0x3fULL) == 0) &&
            ((1ULL << (_la - 142)) & 29228991) != 0) {
      setState(758);
      triplesBlock();
    }
    setState(764);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__3

           || _la == SparqlAutomaticParser::VALUES ||
           (((_la - 69) & ~0x3fULL) == 0) &&
               ((1ULL << (_la - 69)) & 349) != 0) {
      setState(761);
      graphPatternNotTriplesAndMaybeTriples();
      setState(766);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GraphPatternNotTriplesAndMaybeTriplesContext
//------------------------------------------------------------------

SparqlAutomaticParser::GraphPatternNotTriplesAndMaybeTriplesContext::
    GraphPatternNotTriplesAndMaybeTriplesContext(ParserRuleContext* parent,
                                                 size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::GraphPatternNotTriplesContext* SparqlAutomaticParser::
    GraphPatternNotTriplesAndMaybeTriplesContext::graphPatternNotTriples() {
  return getRuleContext<SparqlAutomaticParser::GraphPatternNotTriplesContext>(
      0);
}

SparqlAutomaticParser::TriplesBlockContext* SparqlAutomaticParser::
    GraphPatternNotTriplesAndMaybeTriplesContext::triplesBlock() {
  return getRuleContext<SparqlAutomaticParser::TriplesBlockContext>(0);
}

size_t SparqlAutomaticParser::GraphPatternNotTriplesAndMaybeTriplesContext::
    getRuleIndex() const {
  return SparqlAutomaticParser::RuleGraphPatternNotTriplesAndMaybeTriples;
}

void SparqlAutomaticParser::GraphPatternNotTriplesAndMaybeTriplesContext::
    enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterGraphPatternNotTriplesAndMaybeTriples(this);
}

void SparqlAutomaticParser::GraphPatternNotTriplesAndMaybeTriplesContext::
    exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitGraphPatternNotTriplesAndMaybeTriples(this);
}

std::any
SparqlAutomaticParser::GraphPatternNotTriplesAndMaybeTriplesContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGraphPatternNotTriplesAndMaybeTriples(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GraphPatternNotTriplesAndMaybeTriplesContext*
SparqlAutomaticParser::graphPatternNotTriplesAndMaybeTriples() {
  GraphPatternNotTriplesAndMaybeTriplesContext* _localctx =
      _tracker.createInstance<GraphPatternNotTriplesAndMaybeTriplesContext>(
          _ctx, getState());
  enterRule(_localctx, 114,
            SparqlAutomaticParser::RuleGraphPatternNotTriplesAndMaybeTriples);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(767);
    graphPatternNotTriples();
    setState(769);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::T__6) {
      setState(768);
      match(SparqlAutomaticParser::T__6);
    }
    setState(772);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 805371908) != 0 ||
        (((_la - 142) & ~0x3fULL) == 0) &&
            ((1ULL << (_la - 142)) & 29228991) != 0) {
      setState(771);
      triplesBlock();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriplesBlockContext
//------------------------------------------------------------------

SparqlAutomaticParser::TriplesBlockContext::TriplesBlockContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::TriplesSameSubjectPathContext*
SparqlAutomaticParser::TriplesBlockContext::triplesSameSubjectPath() {
  return getRuleContext<SparqlAutomaticParser::TriplesSameSubjectPathContext>(
      0);
}

SparqlAutomaticParser::TriplesBlockContext*
SparqlAutomaticParser::TriplesBlockContext::triplesBlock() {
  return getRuleContext<SparqlAutomaticParser::TriplesBlockContext>(0);
}

size_t SparqlAutomaticParser::TriplesBlockContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleTriplesBlock;
}

void SparqlAutomaticParser::TriplesBlockContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTriplesBlock(this);
}

void SparqlAutomaticParser::TriplesBlockContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTriplesBlock(this);
}

std::any SparqlAutomaticParser::TriplesBlockContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitTriplesBlock(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::TriplesBlockContext*
SparqlAutomaticParser::triplesBlock() {
  TriplesBlockContext* _localctx =
      _tracker.createInstance<TriplesBlockContext>(_ctx, getState());
  enterRule(_localctx, 116, SparqlAutomaticParser::RuleTriplesBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(774);
    triplesSameSubjectPath();
    setState(779);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::T__6) {
      setState(775);
      match(SparqlAutomaticParser::T__6);
      setState(777);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 805371908) != 0 ||
          (((_la - 142) & ~0x3fULL) == 0) &&
              ((1ULL << (_la - 142)) & 29228991) != 0) {
        setState(776);
        triplesBlock();
      }
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GraphPatternNotTriplesContext
//------------------------------------------------------------------

SparqlAutomaticParser::GraphPatternNotTriplesContext::
    GraphPatternNotTriplesContext(ParserRuleContext* parent,
                                  size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::GroupOrUnionGraphPatternContext* SparqlAutomaticParser::
    GraphPatternNotTriplesContext::groupOrUnionGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::GroupOrUnionGraphPatternContext>(
      0);
}

SparqlAutomaticParser::OptionalGraphPatternContext*
SparqlAutomaticParser::GraphPatternNotTriplesContext::optionalGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::OptionalGraphPatternContext>(0);
}

SparqlAutomaticParser::MinusGraphPatternContext*
SparqlAutomaticParser::GraphPatternNotTriplesContext::minusGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::MinusGraphPatternContext>(0);
}

SparqlAutomaticParser::GraphGraphPatternContext*
SparqlAutomaticParser::GraphPatternNotTriplesContext::graphGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::GraphGraphPatternContext>(0);
}

SparqlAutomaticParser::ServiceGraphPatternContext*
SparqlAutomaticParser::GraphPatternNotTriplesContext::serviceGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::ServiceGraphPatternContext>(0);
}

SparqlAutomaticParser::FilterRContext*
SparqlAutomaticParser::GraphPatternNotTriplesContext::filterR() {
  return getRuleContext<SparqlAutomaticParser::FilterRContext>(0);
}

SparqlAutomaticParser::BindContext*
SparqlAutomaticParser::GraphPatternNotTriplesContext::bind() {
  return getRuleContext<SparqlAutomaticParser::BindContext>(0);
}

SparqlAutomaticParser::InlineDataContext*
SparqlAutomaticParser::GraphPatternNotTriplesContext::inlineData() {
  return getRuleContext<SparqlAutomaticParser::InlineDataContext>(0);
}

size_t SparqlAutomaticParser::GraphPatternNotTriplesContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleGraphPatternNotTriples;
}

void SparqlAutomaticParser::GraphPatternNotTriplesContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterGraphPatternNotTriples(this);
}

void SparqlAutomaticParser::GraphPatternNotTriplesContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitGraphPatternNotTriples(this);
}

std::any SparqlAutomaticParser::GraphPatternNotTriplesContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGraphPatternNotTriples(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GraphPatternNotTriplesContext*
SparqlAutomaticParser::graphPatternNotTriples() {
  GraphPatternNotTriplesContext* _localctx =
      _tracker.createInstance<GraphPatternNotTriplesContext>(_ctx, getState());
  enterRule(_localctx, 118, SparqlAutomaticParser::RuleGraphPatternNotTriples);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(789);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__3: {
        enterOuterAlt(_localctx, 1);
        setState(781);
        groupOrUnionGraphPattern();
        break;
      }

      case SparqlAutomaticParser::OPTIONAL: {
        enterOuterAlt(_localctx, 2);
        setState(782);
        optionalGraphPattern();
        break;
      }

      case SparqlAutomaticParser::MINUS: {
        enterOuterAlt(_localctx, 3);
        setState(783);
        minusGraphPattern();
        break;
      }

      case SparqlAutomaticParser::GRAPH: {
        enterOuterAlt(_localctx, 4);
        setState(784);
        graphGraphPattern();
        break;
      }

      case SparqlAutomaticParser::SERVICE: {
        enterOuterAlt(_localctx, 5);
        setState(785);
        serviceGraphPattern();
        break;
      }

      case SparqlAutomaticParser::FILTER: {
        enterOuterAlt(_localctx, 6);
        setState(786);
        filterR();
        break;
      }

      case SparqlAutomaticParser::BIND: {
        enterOuterAlt(_localctx, 7);
        setState(787);
        bind();
        break;
      }

      case SparqlAutomaticParser::VALUES: {
        enterOuterAlt(_localctx, 8);
        setState(788);
        inlineData();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionalGraphPatternContext
//------------------------------------------------------------------

SparqlAutomaticParser::OptionalGraphPatternContext::OptionalGraphPatternContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode*
SparqlAutomaticParser::OptionalGraphPatternContext::OPTIONAL() {
  return getToken(SparqlAutomaticParser::OPTIONAL, 0);
}

SparqlAutomaticParser::GroupGraphPatternContext*
SparqlAutomaticParser::OptionalGraphPatternContext::groupGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::GroupGraphPatternContext>(0);
}

size_t SparqlAutomaticParser::OptionalGraphPatternContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleOptionalGraphPattern;
}

void SparqlAutomaticParser::OptionalGraphPatternContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionalGraphPattern(this);
}

void SparqlAutomaticParser::OptionalGraphPatternContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitOptionalGraphPattern(this);
}

std::any SparqlAutomaticParser::OptionalGraphPatternContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitOptionalGraphPattern(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::OptionalGraphPatternContext*
SparqlAutomaticParser::optionalGraphPattern() {
  OptionalGraphPatternContext* _localctx =
      _tracker.createInstance<OptionalGraphPatternContext>(_ctx, getState());
  enterRule(_localctx, 120, SparqlAutomaticParser::RuleOptionalGraphPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(791);
    match(SparqlAutomaticParser::OPTIONAL);
    setState(792);
    groupGraphPattern();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GraphGraphPatternContext
//------------------------------------------------------------------

SparqlAutomaticParser::GraphGraphPatternContext::GraphGraphPatternContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::GraphGraphPatternContext::GRAPH() {
  return getToken(SparqlAutomaticParser::GRAPH, 0);
}

SparqlAutomaticParser::VarOrIriContext*
SparqlAutomaticParser::GraphGraphPatternContext::varOrIri() {
  return getRuleContext<SparqlAutomaticParser::VarOrIriContext>(0);
}

SparqlAutomaticParser::GroupGraphPatternContext*
SparqlAutomaticParser::GraphGraphPatternContext::groupGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::GroupGraphPatternContext>(0);
}

size_t SparqlAutomaticParser::GraphGraphPatternContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleGraphGraphPattern;
}

void SparqlAutomaticParser::GraphGraphPatternContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterGraphGraphPattern(this);
}

void SparqlAutomaticParser::GraphGraphPatternContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitGraphGraphPattern(this);
}

std::any SparqlAutomaticParser::GraphGraphPatternContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGraphGraphPattern(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GraphGraphPatternContext*
SparqlAutomaticParser::graphGraphPattern() {
  GraphGraphPatternContext* _localctx =
      _tracker.createInstance<GraphGraphPatternContext>(_ctx, getState());
  enterRule(_localctx, 122, SparqlAutomaticParser::RuleGraphGraphPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(794);
    match(SparqlAutomaticParser::GRAPH);
    setState(795);
    varOrIri();
    setState(796);
    groupGraphPattern();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServiceGraphPatternContext
//------------------------------------------------------------------

SparqlAutomaticParser::ServiceGraphPatternContext::ServiceGraphPatternContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode*
SparqlAutomaticParser::ServiceGraphPatternContext::SERVICE() {
  return getToken(SparqlAutomaticParser::SERVICE, 0);
}

SparqlAutomaticParser::VarOrIriContext*
SparqlAutomaticParser::ServiceGraphPatternContext::varOrIri() {
  return getRuleContext<SparqlAutomaticParser::VarOrIriContext>(0);
}

SparqlAutomaticParser::GroupGraphPatternContext*
SparqlAutomaticParser::ServiceGraphPatternContext::groupGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::GroupGraphPatternContext>(0);
}

tree::TerminalNode*
SparqlAutomaticParser::ServiceGraphPatternContext::SILENT() {
  return getToken(SparqlAutomaticParser::SILENT, 0);
}

size_t SparqlAutomaticParser::ServiceGraphPatternContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleServiceGraphPattern;
}

void SparqlAutomaticParser::ServiceGraphPatternContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterServiceGraphPattern(this);
}

void SparqlAutomaticParser::ServiceGraphPatternContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitServiceGraphPattern(this);
}

std::any SparqlAutomaticParser::ServiceGraphPatternContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitServiceGraphPattern(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ServiceGraphPatternContext*
SparqlAutomaticParser::serviceGraphPattern() {
  ServiceGraphPatternContext* _localctx =
      _tracker.createInstance<ServiceGraphPatternContext>(_ctx, getState());
  enterRule(_localctx, 124, SparqlAutomaticParser::RuleServiceGraphPattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(798);
    match(SparqlAutomaticParser::SERVICE);
    setState(800);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::SILENT) {
      setState(799);
      match(SparqlAutomaticParser::SILENT);
    }
    setState(802);
    varOrIri();
    setState(803);
    groupGraphPattern();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BindContext
//------------------------------------------------------------------

SparqlAutomaticParser::BindContext::BindContext(ParserRuleContext* parent,
                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::BindContext::BIND() {
  return getToken(SparqlAutomaticParser::BIND, 0);
}

SparqlAutomaticParser::ExpressionContext*
SparqlAutomaticParser::BindContext::expression() {
  return getRuleContext<SparqlAutomaticParser::ExpressionContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::BindContext::AS() {
  return getToken(SparqlAutomaticParser::AS, 0);
}

SparqlAutomaticParser::VarContext* SparqlAutomaticParser::BindContext::var() {
  return getRuleContext<SparqlAutomaticParser::VarContext>(0);
}

size_t SparqlAutomaticParser::BindContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleBind;
}

void SparqlAutomaticParser::BindContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterBind(this);
}

void SparqlAutomaticParser::BindContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitBind(this);
}

std::any SparqlAutomaticParser::BindContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitBind(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::BindContext* SparqlAutomaticParser::bind() {
  BindContext* _localctx =
      _tracker.createInstance<BindContext>(_ctx, getState());
  enterRule(_localctx, 126, SparqlAutomaticParser::RuleBind);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(805);
    match(SparqlAutomaticParser::BIND);
    setState(806);
    match(SparqlAutomaticParser::T__1);
    setState(807);
    expression();
    setState(808);
    match(SparqlAutomaticParser::AS);
    setState(809);
    var();
    setState(810);
    match(SparqlAutomaticParser::T__2);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InlineDataContext
//------------------------------------------------------------------

SparqlAutomaticParser::InlineDataContext::InlineDataContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::InlineDataContext::VALUES() {
  return getToken(SparqlAutomaticParser::VALUES, 0);
}

SparqlAutomaticParser::DataBlockContext*
SparqlAutomaticParser::InlineDataContext::dataBlock() {
  return getRuleContext<SparqlAutomaticParser::DataBlockContext>(0);
}

size_t SparqlAutomaticParser::InlineDataContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleInlineData;
}

void SparqlAutomaticParser::InlineDataContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterInlineData(this);
}

void SparqlAutomaticParser::InlineDataContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitInlineData(this);
}

std::any SparqlAutomaticParser::InlineDataContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitInlineData(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::InlineDataContext* SparqlAutomaticParser::inlineData() {
  InlineDataContext* _localctx =
      _tracker.createInstance<InlineDataContext>(_ctx, getState());
  enterRule(_localctx, 128, SparqlAutomaticParser::RuleInlineData);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(812);
    match(SparqlAutomaticParser::VALUES);
    setState(813);
    dataBlock();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataBlockContext
//------------------------------------------------------------------

SparqlAutomaticParser::DataBlockContext::DataBlockContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::InlineDataOneVarContext*
SparqlAutomaticParser::DataBlockContext::inlineDataOneVar() {
  return getRuleContext<SparqlAutomaticParser::InlineDataOneVarContext>(0);
}

SparqlAutomaticParser::InlineDataFullContext*
SparqlAutomaticParser::DataBlockContext::inlineDataFull() {
  return getRuleContext<SparqlAutomaticParser::InlineDataFullContext>(0);
}

size_t SparqlAutomaticParser::DataBlockContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleDataBlock;
}

void SparqlAutomaticParser::DataBlockContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDataBlock(this);
}

void SparqlAutomaticParser::DataBlockContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDataBlock(this);
}

std::any SparqlAutomaticParser::DataBlockContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitDataBlock(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::DataBlockContext* SparqlAutomaticParser::dataBlock() {
  DataBlockContext* _localctx =
      _tracker.createInstance<DataBlockContext>(_ctx, getState());
  enterRule(_localctx, 130, SparqlAutomaticParser::RuleDataBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(817);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2: {
        enterOuterAlt(_localctx, 1);
        setState(815);
        inlineDataOneVar();
        break;
      }

      case SparqlAutomaticParser::T__1:
      case SparqlAutomaticParser::NIL: {
        enterOuterAlt(_localctx, 2);
        setState(816);
        inlineDataFull();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InlineDataOneVarContext
//------------------------------------------------------------------

SparqlAutomaticParser::InlineDataOneVarContext::InlineDataOneVarContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VarContext*
SparqlAutomaticParser::InlineDataOneVarContext::var() {
  return getRuleContext<SparqlAutomaticParser::VarContext>(0);
}

std::vector<SparqlAutomaticParser::DataBlockValueContext*>
SparqlAutomaticParser::InlineDataOneVarContext::dataBlockValue() {
  return getRuleContexts<SparqlAutomaticParser::DataBlockValueContext>();
}

SparqlAutomaticParser::DataBlockValueContext*
SparqlAutomaticParser::InlineDataOneVarContext::dataBlockValue(size_t i) {
  return getRuleContext<SparqlAutomaticParser::DataBlockValueContext>(i);
}

size_t SparqlAutomaticParser::InlineDataOneVarContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleInlineDataOneVar;
}

void SparqlAutomaticParser::InlineDataOneVarContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterInlineDataOneVar(this);
}

void SparqlAutomaticParser::InlineDataOneVarContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitInlineDataOneVar(this);
}

std::any SparqlAutomaticParser::InlineDataOneVarContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitInlineDataOneVar(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::InlineDataOneVarContext*
SparqlAutomaticParser::inlineDataOneVar() {
  InlineDataOneVarContext* _localctx =
      _tracker.createInstance<InlineDataOneVarContext>(_ctx, getState());
  enterRule(_localctx, 132, SparqlAutomaticParser::RuleInlineDataOneVar);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(819);
    var();
    setState(820);
    match(SparqlAutomaticParser::T__3);
    setState(824);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la - 28) & ~0x3fULL) == 0) &&
               ((1ULL << (_la - 28)) & 70368744177667) != 0 ||
           (((_la - 142) & ~0x3fULL) == 0) &&
               ((1ULL << (_la - 142)) & 4063111) != 0) {
      setState(821);
      dataBlockValue();
      setState(826);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(827);
    match(SparqlAutomaticParser::T__4);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InlineDataFullContext
//------------------------------------------------------------------

SparqlAutomaticParser::InlineDataFullContext::InlineDataFullContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::InlineDataFullContext::NIL() {
  return getToken(SparqlAutomaticParser::NIL, 0);
}

std::vector<SparqlAutomaticParser::DataBlockSingleContext*>
SparqlAutomaticParser::InlineDataFullContext::dataBlockSingle() {
  return getRuleContexts<SparqlAutomaticParser::DataBlockSingleContext>();
}

SparqlAutomaticParser::DataBlockSingleContext*
SparqlAutomaticParser::InlineDataFullContext::dataBlockSingle(size_t i) {
  return getRuleContext<SparqlAutomaticParser::DataBlockSingleContext>(i);
}

std::vector<SparqlAutomaticParser::VarContext*>
SparqlAutomaticParser::InlineDataFullContext::var() {
  return getRuleContexts<SparqlAutomaticParser::VarContext>();
}

SparqlAutomaticParser::VarContext*
SparqlAutomaticParser::InlineDataFullContext::var(size_t i) {
  return getRuleContext<SparqlAutomaticParser::VarContext>(i);
}

size_t SparqlAutomaticParser::InlineDataFullContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleInlineDataFull;
}

void SparqlAutomaticParser::InlineDataFullContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterInlineDataFull(this);
}

void SparqlAutomaticParser::InlineDataFullContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitInlineDataFull(this);
}

std::any SparqlAutomaticParser::InlineDataFullContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitInlineDataFull(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::InlineDataFullContext*
SparqlAutomaticParser::inlineDataFull() {
  InlineDataFullContext* _localctx =
      _tracker.createInstance<InlineDataFullContext>(_ctx, getState());
  enterRule(_localctx, 134, SparqlAutomaticParser::RuleInlineDataFull);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(838);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::NIL: {
        setState(829);
        match(SparqlAutomaticParser::NIL);
        break;
      }

      case SparqlAutomaticParser::T__1: {
        setState(830);
        match(SparqlAutomaticParser::T__1);
        setState(834);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SparqlAutomaticParser::VAR1

               || _la == SparqlAutomaticParser::VAR2) {
          setState(831);
          var();
          setState(836);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(837);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(840);
    match(SparqlAutomaticParser::T__3);
    setState(844);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__1 ||
           _la == SparqlAutomaticParser::NIL) {
      setState(841);
      dataBlockSingle();
      setState(846);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(847);
    match(SparqlAutomaticParser::T__4);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataBlockSingleContext
//------------------------------------------------------------------

SparqlAutomaticParser::DataBlockSingleContext::DataBlockSingleContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::DataBlockSingleContext::NIL() {
  return getToken(SparqlAutomaticParser::NIL, 0);
}

std::vector<SparqlAutomaticParser::DataBlockValueContext*>
SparqlAutomaticParser::DataBlockSingleContext::dataBlockValue() {
  return getRuleContexts<SparqlAutomaticParser::DataBlockValueContext>();
}

SparqlAutomaticParser::DataBlockValueContext*
SparqlAutomaticParser::DataBlockSingleContext::dataBlockValue(size_t i) {
  return getRuleContext<SparqlAutomaticParser::DataBlockValueContext>(i);
}

size_t SparqlAutomaticParser::DataBlockSingleContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleDataBlockSingle;
}

void SparqlAutomaticParser::DataBlockSingleContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDataBlockSingle(this);
}

void SparqlAutomaticParser::DataBlockSingleContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDataBlockSingle(this);
}

std::any SparqlAutomaticParser::DataBlockSingleContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitDataBlockSingle(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::DataBlockSingleContext*
SparqlAutomaticParser::dataBlockSingle() {
  DataBlockSingleContext* _localctx =
      _tracker.createInstance<DataBlockSingleContext>(_ctx, getState());
  enterRule(_localctx, 136, SparqlAutomaticParser::RuleDataBlockSingle);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(858);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__1: {
        setState(849);
        match(SparqlAutomaticParser::T__1);
        setState(853);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la - 28) & ~0x3fULL) == 0) &&
                   ((1ULL << (_la - 28)) & 70368744177667) != 0 ||
               (((_la - 142) & ~0x3fULL) == 0) &&
                   ((1ULL << (_la - 142)) & 4063111) != 0) {
          setState(850);
          dataBlockValue();
          setState(855);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(856);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::NIL: {
        setState(857);
        match(SparqlAutomaticParser::NIL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataBlockValueContext
//------------------------------------------------------------------

SparqlAutomaticParser::DataBlockValueContext::DataBlockValueContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::IriContext*
SparqlAutomaticParser::DataBlockValueContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

SparqlAutomaticParser::RdfLiteralContext*
SparqlAutomaticParser::DataBlockValueContext::rdfLiteral() {
  return getRuleContext<SparqlAutomaticParser::RdfLiteralContext>(0);
}

SparqlAutomaticParser::NumericLiteralContext*
SparqlAutomaticParser::DataBlockValueContext::numericLiteral() {
  return getRuleContext<SparqlAutomaticParser::NumericLiteralContext>(0);
}

SparqlAutomaticParser::BooleanLiteralContext*
SparqlAutomaticParser::DataBlockValueContext::booleanLiteral() {
  return getRuleContext<SparqlAutomaticParser::BooleanLiteralContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::DataBlockValueContext::UNDEF() {
  return getToken(SparqlAutomaticParser::UNDEF, 0);
}

size_t SparqlAutomaticParser::DataBlockValueContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleDataBlockValue;
}

void SparqlAutomaticParser::DataBlockValueContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDataBlockValue(this);
}

void SparqlAutomaticParser::DataBlockValueContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDataBlockValue(this);
}

std::any SparqlAutomaticParser::DataBlockValueContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitDataBlockValue(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::DataBlockValueContext*
SparqlAutomaticParser::dataBlockValue() {
  DataBlockValueContext* _localctx =
      _tracker.createInstance<DataBlockValueContext>(_ctx, getState());
  enterRule(_localctx, 138, SparqlAutomaticParser::RuleDataBlockValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(865);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 1);
        setState(860);
        iri();
        break;
      }

      case SparqlAutomaticParser::STRING_LITERAL1:
      case SparqlAutomaticParser::STRING_LITERAL2:
      case SparqlAutomaticParser::STRING_LITERAL_LONG1:
      case SparqlAutomaticParser::STRING_LITERAL_LONG2: {
        enterOuterAlt(_localctx, 2);
        setState(861);
        rdfLiteral();
        break;
      }

      case SparqlAutomaticParser::INTEGER:
      case SparqlAutomaticParser::DECIMAL:
      case SparqlAutomaticParser::DOUBLE:
      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE:
      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE: {
        enterOuterAlt(_localctx, 3);
        setState(862);
        numericLiteral();
        break;
      }

      case SparqlAutomaticParser::T__27:
      case SparqlAutomaticParser::T__28: {
        enterOuterAlt(_localctx, 4);
        setState(863);
        booleanLiteral();
        break;
      }

      case SparqlAutomaticParser::UNDEF: {
        enterOuterAlt(_localctx, 5);
        setState(864);
        match(SparqlAutomaticParser::UNDEF);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MinusGraphPatternContext
//------------------------------------------------------------------

SparqlAutomaticParser::MinusGraphPatternContext::MinusGraphPatternContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::MinusGraphPatternContext::MINUS() {
  return getToken(SparqlAutomaticParser::MINUS, 0);
}

SparqlAutomaticParser::GroupGraphPatternContext*
SparqlAutomaticParser::MinusGraphPatternContext::groupGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::GroupGraphPatternContext>(0);
}

size_t SparqlAutomaticParser::MinusGraphPatternContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleMinusGraphPattern;
}

void SparqlAutomaticParser::MinusGraphPatternContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterMinusGraphPattern(this);
}

void SparqlAutomaticParser::MinusGraphPatternContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitMinusGraphPattern(this);
}

std::any SparqlAutomaticParser::MinusGraphPatternContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitMinusGraphPattern(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::MinusGraphPatternContext*
SparqlAutomaticParser::minusGraphPattern() {
  MinusGraphPatternContext* _localctx =
      _tracker.createInstance<MinusGraphPatternContext>(_ctx, getState());
  enterRule(_localctx, 140, SparqlAutomaticParser::RuleMinusGraphPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(867);
    match(SparqlAutomaticParser::MINUS);
    setState(868);
    groupGraphPattern();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupOrUnionGraphPatternContext
//------------------------------------------------------------------

SparqlAutomaticParser::GroupOrUnionGraphPatternContext::
    GroupOrUnionGraphPatternContext(ParserRuleContext* parent,
                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::GroupGraphPatternContext*>
SparqlAutomaticParser::GroupOrUnionGraphPatternContext::groupGraphPattern() {
  return getRuleContexts<SparqlAutomaticParser::GroupGraphPatternContext>();
}

SparqlAutomaticParser::GroupGraphPatternContext*
SparqlAutomaticParser::GroupOrUnionGraphPatternContext::groupGraphPattern(
    size_t i) {
  return getRuleContext<SparqlAutomaticParser::GroupGraphPatternContext>(i);
}

std::vector<tree::TerminalNode*>
SparqlAutomaticParser::GroupOrUnionGraphPatternContext::UNION() {
  return getTokens(SparqlAutomaticParser::UNION);
}

tree::TerminalNode*
SparqlAutomaticParser::GroupOrUnionGraphPatternContext::UNION(size_t i) {
  return getToken(SparqlAutomaticParser::UNION, i);
}

size_t SparqlAutomaticParser::GroupOrUnionGraphPatternContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleGroupOrUnionGraphPattern;
}

void SparqlAutomaticParser::GroupOrUnionGraphPatternContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupOrUnionGraphPattern(this);
}

void SparqlAutomaticParser::GroupOrUnionGraphPatternContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupOrUnionGraphPattern(this);
}

std::any SparqlAutomaticParser::GroupOrUnionGraphPatternContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGroupOrUnionGraphPattern(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GroupOrUnionGraphPatternContext*
SparqlAutomaticParser::groupOrUnionGraphPattern() {
  GroupOrUnionGraphPatternContext* _localctx =
      _tracker.createInstance<GroupOrUnionGraphPatternContext>(_ctx,
                                                               getState());
  enterRule(_localctx, 142,
            SparqlAutomaticParser::RuleGroupOrUnionGraphPattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(870);
    groupGraphPattern();
    setState(875);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::UNION) {
      setState(871);
      match(SparqlAutomaticParser::UNION);
      setState(872);
      groupGraphPattern();
      setState(877);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterRContext
//------------------------------------------------------------------

SparqlAutomaticParser::FilterRContext::FilterRContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::FilterRContext::FILTER() {
  return getToken(SparqlAutomaticParser::FILTER, 0);
}

SparqlAutomaticParser::ConstraintContext*
SparqlAutomaticParser::FilterRContext::constraint() {
  return getRuleContext<SparqlAutomaticParser::ConstraintContext>(0);
}

size_t SparqlAutomaticParser::FilterRContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleFilterR;
}

void SparqlAutomaticParser::FilterRContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterFilterR(this);
}

void SparqlAutomaticParser::FilterRContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitFilterR(this);
}

std::any SparqlAutomaticParser::FilterRContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitFilterR(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::FilterRContext* SparqlAutomaticParser::filterR() {
  FilterRContext* _localctx =
      _tracker.createInstance<FilterRContext>(_ctx, getState());
  enterRule(_localctx, 144, SparqlAutomaticParser::RuleFilterR);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(878);
    match(SparqlAutomaticParser::FILTER);
    setState(879);
    constraint();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintContext
//------------------------------------------------------------------

SparqlAutomaticParser::ConstraintContext::ConstraintContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::BrackettedExpressionContext*
SparqlAutomaticParser::ConstraintContext::brackettedExpression() {
  return getRuleContext<SparqlAutomaticParser::BrackettedExpressionContext>(0);
}

SparqlAutomaticParser::BuiltInCallContext*
SparqlAutomaticParser::ConstraintContext::builtInCall() {
  return getRuleContext<SparqlAutomaticParser::BuiltInCallContext>(0);
}

SparqlAutomaticParser::FunctionCallContext*
SparqlAutomaticParser::ConstraintContext::functionCall() {
  return getRuleContext<SparqlAutomaticParser::FunctionCallContext>(0);
}

size_t SparqlAutomaticParser::ConstraintContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleConstraint;
}

void SparqlAutomaticParser::ConstraintContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterConstraint(this);
}

void SparqlAutomaticParser::ConstraintContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitConstraint(this);
}

std::any SparqlAutomaticParser::ConstraintContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitConstraint(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ConstraintContext* SparqlAutomaticParser::constraint() {
  ConstraintContext* _localctx =
      _tracker.createInstance<ConstraintContext>(_ctx, getState());
  enterRule(_localctx, 146, SparqlAutomaticParser::RuleConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(884);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__1: {
        enterOuterAlt(_localctx, 1);
        setState(881);
        brackettedExpression();
        break;
      }

      case SparqlAutomaticParser::GROUP_CONCAT:
      case SparqlAutomaticParser::NOT:
      case SparqlAutomaticParser::STR:
      case SparqlAutomaticParser::LANG:
      case SparqlAutomaticParser::LANGMATCHES:
      case SparqlAutomaticParser::DATATYPE:
      case SparqlAutomaticParser::BOUND:
      case SparqlAutomaticParser::IRI:
      case SparqlAutomaticParser::URI:
      case SparqlAutomaticParser::BNODE:
      case SparqlAutomaticParser::RAND:
      case SparqlAutomaticParser::ABS:
      case SparqlAutomaticParser::CEIL:
      case SparqlAutomaticParser::FLOOR:
      case SparqlAutomaticParser::ROUND:
      case SparqlAutomaticParser::CONCAT:
      case SparqlAutomaticParser::STRLEN:
      case SparqlAutomaticParser::UCASE:
      case SparqlAutomaticParser::LCASE:
      case SparqlAutomaticParser::ENCODE_FOR_URI:
      case SparqlAutomaticParser::CONTAINS:
      case SparqlAutomaticParser::STRSTARTS:
      case SparqlAutomaticParser::STRENDS:
      case SparqlAutomaticParser::STRBEFORE:
      case SparqlAutomaticParser::STRAFTER:
      case SparqlAutomaticParser::YEAR:
      case SparqlAutomaticParser::MONTH:
      case SparqlAutomaticParser::DAY:
      case SparqlAutomaticParser::HOURS:
      case SparqlAutomaticParser::MINUTES:
      case SparqlAutomaticParser::SECONDS:
      case SparqlAutomaticParser::TIMEZONE:
      case SparqlAutomaticParser::TZ:
      case SparqlAutomaticParser::NOW:
      case SparqlAutomaticParser::UUID:
      case SparqlAutomaticParser::STRUUID:
      case SparqlAutomaticParser::SHA1:
      case SparqlAutomaticParser::SHA256:
      case SparqlAutomaticParser::SHA384:
      case SparqlAutomaticParser::SHA512:
      case SparqlAutomaticParser::MD5:
      case SparqlAutomaticParser::COALESCE:
      case SparqlAutomaticParser::IF:
      case SparqlAutomaticParser::STRLANG:
      case SparqlAutomaticParser::STRDT:
      case SparqlAutomaticParser::SAMETERM:
      case SparqlAutomaticParser::ISIRI:
      case SparqlAutomaticParser::ISURI:
      case SparqlAutomaticParser::ISBLANK:
      case SparqlAutomaticParser::ISLITERAL:
      case SparqlAutomaticParser::ISNUMERIC:
      case SparqlAutomaticParser::REGEX:
      case SparqlAutomaticParser::SUBSTR:
      case SparqlAutomaticParser::REPLACE:
      case SparqlAutomaticParser::EXISTS:
      case SparqlAutomaticParser::COUNT:
      case SparqlAutomaticParser::SUM:
      case SparqlAutomaticParser::MIN:
      case SparqlAutomaticParser::MAX:
      case SparqlAutomaticParser::AVG:
      case SparqlAutomaticParser::STDEV:
      case SparqlAutomaticParser::SAMPLE: {
        enterOuterAlt(_localctx, 2);
        setState(882);
        builtInCall();
        break;
      }

      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 3);
        setState(883);
        functionCall();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallContext
//------------------------------------------------------------------

SparqlAutomaticParser::FunctionCallContext::FunctionCallContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::IriContext*
SparqlAutomaticParser::FunctionCallContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

SparqlAutomaticParser::ArgListContext*
SparqlAutomaticParser::FunctionCallContext::argList() {
  return getRuleContext<SparqlAutomaticParser::ArgListContext>(0);
}

size_t SparqlAutomaticParser::FunctionCallContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleFunctionCall;
}

void SparqlAutomaticParser::FunctionCallContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterFunctionCall(this);
}

void SparqlAutomaticParser::FunctionCallContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitFunctionCall(this);
}

std::any SparqlAutomaticParser::FunctionCallContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitFunctionCall(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::FunctionCallContext*
SparqlAutomaticParser::functionCall() {
  FunctionCallContext* _localctx =
      _tracker.createInstance<FunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 148, SparqlAutomaticParser::RuleFunctionCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(886);
    iri();
    setState(887);
    argList();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgListContext
//------------------------------------------------------------------

SparqlAutomaticParser::ArgListContext::ArgListContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::ArgListContext::NIL() {
  return getToken(SparqlAutomaticParser::NIL, 0);
}

std::vector<SparqlAutomaticParser::ExpressionContext*>
SparqlAutomaticParser::ArgListContext::expression() {
  return getRuleContexts<SparqlAutomaticParser::ExpressionContext>();
}

SparqlAutomaticParser::ExpressionContext*
SparqlAutomaticParser::ArgListContext::expression(size_t i) {
  return getRuleContext<SparqlAutomaticParser::ExpressionContext>(i);
}

tree::TerminalNode* SparqlAutomaticParser::ArgListContext::DISTINCT() {
  return getToken(SparqlAutomaticParser::DISTINCT, 0);
}

size_t SparqlAutomaticParser::ArgListContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleArgList;
}

void SparqlAutomaticParser::ArgListContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterArgList(this);
}

void SparqlAutomaticParser::ArgListContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitArgList(this);
}

std::any SparqlAutomaticParser::ArgListContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitArgList(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ArgListContext* SparqlAutomaticParser::argList() {
  ArgListContext* _localctx =
      _tracker.createInstance<ArgListContext>(_ctx, getState());
  enterRule(_localctx, 150, SparqlAutomaticParser::RuleArgList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(904);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::NIL: {
        enterOuterAlt(_localctx, 1);
        setState(889);
        match(SparqlAutomaticParser::NIL);
        break;
      }

      case SparqlAutomaticParser::T__1: {
        enterOuterAlt(_localctx, 2);
        setState(890);
        match(SparqlAutomaticParser::T__1);
        setState(892);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::DISTINCT) {
          setState(891);
          match(SparqlAutomaticParser::DISTINCT);
        }
        setState(894);
        expression();
        setState(899);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SparqlAutomaticParser::T__7) {
          setState(895);
          match(SparqlAutomaticParser::T__7);
          setState(896);
          expression();
          setState(901);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(902);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionListContext
//------------------------------------------------------------------

SparqlAutomaticParser::ExpressionListContext::ExpressionListContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::ExpressionListContext::NIL() {
  return getToken(SparqlAutomaticParser::NIL, 0);
}

std::vector<SparqlAutomaticParser::ExpressionContext*>
SparqlAutomaticParser::ExpressionListContext::expression() {
  return getRuleContexts<SparqlAutomaticParser::ExpressionContext>();
}

SparqlAutomaticParser::ExpressionContext*
SparqlAutomaticParser::ExpressionListContext::expression(size_t i) {
  return getRuleContext<SparqlAutomaticParser::ExpressionContext>(i);
}

size_t SparqlAutomaticParser::ExpressionListContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleExpressionList;
}

void SparqlAutomaticParser::ExpressionListContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterExpressionList(this);
}

void SparqlAutomaticParser::ExpressionListContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitExpressionList(this);
}

std::any SparqlAutomaticParser::ExpressionListContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitExpressionList(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ExpressionListContext*
SparqlAutomaticParser::expressionList() {
  ExpressionListContext* _localctx =
      _tracker.createInstance<ExpressionListContext>(_ctx, getState());
  enterRule(_localctx, 152, SparqlAutomaticParser::RuleExpressionList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(918);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::NIL: {
        enterOuterAlt(_localctx, 1);
        setState(906);
        match(SparqlAutomaticParser::NIL);
        break;
      }

      case SparqlAutomaticParser::T__1: {
        enterOuterAlt(_localctx, 2);
        setState(907);
        match(SparqlAutomaticParser::T__1);
        setState(908);
        expression();
        setState(913);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SparqlAutomaticParser::T__7) {
          setState(909);
          match(SparqlAutomaticParser::T__7);
          setState(910);
          expression();
          setState(915);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(916);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructTemplateContext
//------------------------------------------------------------------

SparqlAutomaticParser::ConstructTemplateContext::ConstructTemplateContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::ConstructTriplesContext*
SparqlAutomaticParser::ConstructTemplateContext::constructTriples() {
  return getRuleContext<SparqlAutomaticParser::ConstructTriplesContext>(0);
}

size_t SparqlAutomaticParser::ConstructTemplateContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleConstructTemplate;
}

void SparqlAutomaticParser::ConstructTemplateContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterConstructTemplate(this);
}

void SparqlAutomaticParser::ConstructTemplateContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitConstructTemplate(this);
}

std::any SparqlAutomaticParser::ConstructTemplateContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitConstructTemplate(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ConstructTemplateContext*
SparqlAutomaticParser::constructTemplate() {
  ConstructTemplateContext* _localctx =
      _tracker.createInstance<ConstructTemplateContext>(_ctx, getState());
  enterRule(_localctx, 154, SparqlAutomaticParser::RuleConstructTemplate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(920);
    match(SparqlAutomaticParser::T__3);
    setState(922);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 805371908) != 0 ||
        (((_la - 142) & ~0x3fULL) == 0) &&
            ((1ULL << (_la - 142)) & 29228991) != 0) {
      setState(921);
      constructTriples();
    }
    setState(924);
    match(SparqlAutomaticParser::T__4);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructTriplesContext
//------------------------------------------------------------------

SparqlAutomaticParser::ConstructTriplesContext::ConstructTriplesContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::TriplesSameSubjectContext*
SparqlAutomaticParser::ConstructTriplesContext::triplesSameSubject() {
  return getRuleContext<SparqlAutomaticParser::TriplesSameSubjectContext>(0);
}

SparqlAutomaticParser::ConstructTriplesContext*
SparqlAutomaticParser::ConstructTriplesContext::constructTriples() {
  return getRuleContext<SparqlAutomaticParser::ConstructTriplesContext>(0);
}

size_t SparqlAutomaticParser::ConstructTriplesContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleConstructTriples;
}

void SparqlAutomaticParser::ConstructTriplesContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterConstructTriples(this);
}

void SparqlAutomaticParser::ConstructTriplesContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitConstructTriples(this);
}

std::any SparqlAutomaticParser::ConstructTriplesContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitConstructTriples(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ConstructTriplesContext*
SparqlAutomaticParser::constructTriples() {
  ConstructTriplesContext* _localctx =
      _tracker.createInstance<ConstructTriplesContext>(_ctx, getState());
  enterRule(_localctx, 156, SparqlAutomaticParser::RuleConstructTriples);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(926);
    triplesSameSubject();
    setState(931);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::T__6) {
      setState(927);
      match(SparqlAutomaticParser::T__6);
      setState(929);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 805371908) != 0 ||
          (((_la - 142) & ~0x3fULL) == 0) &&
              ((1ULL << (_la - 142)) & 29228991) != 0) {
        setState(928);
        constructTriples();
      }
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriplesSameSubjectContext
//------------------------------------------------------------------

SparqlAutomaticParser::TriplesSameSubjectContext::TriplesSameSubjectContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VarOrTermContext*
SparqlAutomaticParser::TriplesSameSubjectContext::varOrTerm() {
  return getRuleContext<SparqlAutomaticParser::VarOrTermContext>(0);
}

SparqlAutomaticParser::PropertyListNotEmptyContext*
SparqlAutomaticParser::TriplesSameSubjectContext::propertyListNotEmpty() {
  return getRuleContext<SparqlAutomaticParser::PropertyListNotEmptyContext>(0);
}

SparqlAutomaticParser::TriplesNodeContext*
SparqlAutomaticParser::TriplesSameSubjectContext::triplesNode() {
  return getRuleContext<SparqlAutomaticParser::TriplesNodeContext>(0);
}

SparqlAutomaticParser::PropertyListContext*
SparqlAutomaticParser::TriplesSameSubjectContext::propertyList() {
  return getRuleContext<SparqlAutomaticParser::PropertyListContext>(0);
}

size_t SparqlAutomaticParser::TriplesSameSubjectContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleTriplesSameSubject;
}

void SparqlAutomaticParser::TriplesSameSubjectContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTriplesSameSubject(this);
}

void SparqlAutomaticParser::TriplesSameSubjectContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTriplesSameSubject(this);
}

std::any SparqlAutomaticParser::TriplesSameSubjectContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitTriplesSameSubject(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::TriplesSameSubjectContext*
SparqlAutomaticParser::triplesSameSubject() {
  TriplesSameSubjectContext* _localctx =
      _tracker.createInstance<TriplesSameSubjectContext>(_ctx, getState());
  enterRule(_localctx, 158, SparqlAutomaticParser::RuleTriplesSameSubject);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(939);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__27:
      case SparqlAutomaticParser::T__28:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::BLANK_NODE_LABEL:
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2:
      case SparqlAutomaticParser::PREFIX_LANGTAG:
      case SparqlAutomaticParser::INTEGER:
      case SparqlAutomaticParser::DECIMAL:
      case SparqlAutomaticParser::DOUBLE:
      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE:
      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE:
      case SparqlAutomaticParser::STRING_LITERAL1:
      case SparqlAutomaticParser::STRING_LITERAL2:
      case SparqlAutomaticParser::STRING_LITERAL_LONG1:
      case SparqlAutomaticParser::STRING_LITERAL_LONG2:
      case SparqlAutomaticParser::NIL:
      case SparqlAutomaticParser::ANON: {
        enterOuterAlt(_localctx, 1);
        setState(933);
        varOrTerm();
        setState(934);
        propertyListNotEmpty();
        break;
      }

      case SparqlAutomaticParser::T__1:
      case SparqlAutomaticParser::T__15: {
        enterOuterAlt(_localctx, 2);
        setState(936);
        triplesNode();
        setState(937);
        propertyList();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyListContext
//------------------------------------------------------------------

SparqlAutomaticParser::PropertyListContext::PropertyListContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::PropertyListNotEmptyContext*
SparqlAutomaticParser::PropertyListContext::propertyListNotEmpty() {
  return getRuleContext<SparqlAutomaticParser::PropertyListNotEmptyContext>(0);
}

size_t SparqlAutomaticParser::PropertyListContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePropertyList;
}

void SparqlAutomaticParser::PropertyListContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPropertyList(this);
}

void SparqlAutomaticParser::PropertyListContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPropertyList(this);
}

std::any SparqlAutomaticParser::PropertyListContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPropertyList(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PropertyListContext*
SparqlAutomaticParser::propertyList() {
  PropertyListContext* _localctx =
      _tracker.createInstance<PropertyListContext>(_ctx, getState());
  enterRule(_localctx, 160, SparqlAutomaticParser::RulePropertyList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(942);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::T__8 ||
        (((_la - 142) & ~0x3fULL) == 0) && ((1ULL << (_la - 142)) & 183) != 0) {
      setState(941);
      propertyListNotEmpty();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyListNotEmptyContext
//------------------------------------------------------------------

SparqlAutomaticParser::PropertyListNotEmptyContext::PropertyListNotEmptyContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::VerbContext*>
SparqlAutomaticParser::PropertyListNotEmptyContext::verb() {
  return getRuleContexts<SparqlAutomaticParser::VerbContext>();
}

SparqlAutomaticParser::VerbContext*
SparqlAutomaticParser::PropertyListNotEmptyContext::verb(size_t i) {
  return getRuleContext<SparqlAutomaticParser::VerbContext>(i);
}

std::vector<SparqlAutomaticParser::ObjectListContext*>
SparqlAutomaticParser::PropertyListNotEmptyContext::objectList() {
  return getRuleContexts<SparqlAutomaticParser::ObjectListContext>();
}

SparqlAutomaticParser::ObjectListContext*
SparqlAutomaticParser::PropertyListNotEmptyContext::objectList(size_t i) {
  return getRuleContext<SparqlAutomaticParser::ObjectListContext>(i);
}

size_t SparqlAutomaticParser::PropertyListNotEmptyContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RulePropertyListNotEmpty;
}

void SparqlAutomaticParser::PropertyListNotEmptyContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyListNotEmpty(this);
}

void SparqlAutomaticParser::PropertyListNotEmptyContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPropertyListNotEmpty(this);
}

std::any SparqlAutomaticParser::PropertyListNotEmptyContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPropertyListNotEmpty(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PropertyListNotEmptyContext*
SparqlAutomaticParser::propertyListNotEmpty() {
  PropertyListNotEmptyContext* _localctx =
      _tracker.createInstance<PropertyListNotEmptyContext>(_ctx, getState());
  enterRule(_localctx, 162, SparqlAutomaticParser::RulePropertyListNotEmpty);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(944);
    verb();
    setState(945);
    objectList();
    setState(954);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__5) {
      setState(946);
      match(SparqlAutomaticParser::T__5);
      setState(950);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SparqlAutomaticParser::T__8 ||
          (((_la - 142) & ~0x3fULL) == 0) &&
              ((1ULL << (_la - 142)) & 183) != 0) {
        setState(947);
        verb();
        setState(948);
        objectList();
      }
      setState(956);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VerbContext
//------------------------------------------------------------------

SparqlAutomaticParser::VerbContext::VerbContext(ParserRuleContext* parent,
                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VarOrIriContext*
SparqlAutomaticParser::VerbContext::varOrIri() {
  return getRuleContext<SparqlAutomaticParser::VarOrIriContext>(0);
}

size_t SparqlAutomaticParser::VerbContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleVerb;
}

void SparqlAutomaticParser::VerbContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterVerb(this);
}

void SparqlAutomaticParser::VerbContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitVerb(this);
}

std::any SparqlAutomaticParser::VerbContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitVerb(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::VerbContext* SparqlAutomaticParser::verb() {
  VerbContext* _localctx =
      _tracker.createInstance<VerbContext>(_ctx, getState());
  enterRule(_localctx, 164, SparqlAutomaticParser::RuleVerb);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(959);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 1);
        setState(957);
        varOrIri();
        break;
      }

      case SparqlAutomaticParser::T__8: {
        enterOuterAlt(_localctx, 2);
        setState(958);
        match(SparqlAutomaticParser::T__8);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectListContext
//------------------------------------------------------------------

SparqlAutomaticParser::ObjectListContext::ObjectListContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::ObjectRContext*>
SparqlAutomaticParser::ObjectListContext::objectR() {
  return getRuleContexts<SparqlAutomaticParser::ObjectRContext>();
}

SparqlAutomaticParser::ObjectRContext*
SparqlAutomaticParser::ObjectListContext::objectR(size_t i) {
  return getRuleContext<SparqlAutomaticParser::ObjectRContext>(i);
}

size_t SparqlAutomaticParser::ObjectListContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleObjectList;
}

void SparqlAutomaticParser::ObjectListContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterObjectList(this);
}

void SparqlAutomaticParser::ObjectListContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitObjectList(this);
}

std::any SparqlAutomaticParser::ObjectListContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitObjectList(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ObjectListContext* SparqlAutomaticParser::objectList() {
  ObjectListContext* _localctx =
      _tracker.createInstance<ObjectListContext>(_ctx, getState());
  enterRule(_localctx, 166, SparqlAutomaticParser::RuleObjectList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(961);
    objectR();
    setState(966);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__7) {
      setState(962);
      match(SparqlAutomaticParser::T__7);
      setState(963);
      objectR();
      setState(968);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectRContext
//------------------------------------------------------------------

SparqlAutomaticParser::ObjectRContext::ObjectRContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::GraphNodeContext*
SparqlAutomaticParser::ObjectRContext::graphNode() {
  return getRuleContext<SparqlAutomaticParser::GraphNodeContext>(0);
}

size_t SparqlAutomaticParser::ObjectRContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleObjectR;
}

void SparqlAutomaticParser::ObjectRContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterObjectR(this);
}

void SparqlAutomaticParser::ObjectRContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitObjectR(this);
}

std::any SparqlAutomaticParser::ObjectRContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitObjectR(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ObjectRContext* SparqlAutomaticParser::objectR() {
  ObjectRContext* _localctx =
      _tracker.createInstance<ObjectRContext>(_ctx, getState());
  enterRule(_localctx, 168, SparqlAutomaticParser::RuleObjectR);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(969);
    graphNode();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriplesSameSubjectPathContext
//------------------------------------------------------------------

SparqlAutomaticParser::TriplesSameSubjectPathContext::
    TriplesSameSubjectPathContext(ParserRuleContext* parent,
                                  size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VarOrTermContext*
SparqlAutomaticParser::TriplesSameSubjectPathContext::varOrTerm() {
  return getRuleContext<SparqlAutomaticParser::VarOrTermContext>(0);
}

SparqlAutomaticParser::PropertyListPathNotEmptyContext* SparqlAutomaticParser::
    TriplesSameSubjectPathContext::propertyListPathNotEmpty() {
  return getRuleContext<SparqlAutomaticParser::PropertyListPathNotEmptyContext>(
      0);
}

SparqlAutomaticParser::TriplesNodePathContext*
SparqlAutomaticParser::TriplesSameSubjectPathContext::triplesNodePath() {
  return getRuleContext<SparqlAutomaticParser::TriplesNodePathContext>(0);
}

SparqlAutomaticParser::PropertyListPathContext*
SparqlAutomaticParser::TriplesSameSubjectPathContext::propertyListPath() {
  return getRuleContext<SparqlAutomaticParser::PropertyListPathContext>(0);
}

size_t SparqlAutomaticParser::TriplesSameSubjectPathContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleTriplesSameSubjectPath;
}

void SparqlAutomaticParser::TriplesSameSubjectPathContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriplesSameSubjectPath(this);
}

void SparqlAutomaticParser::TriplesSameSubjectPathContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriplesSameSubjectPath(this);
}

std::any SparqlAutomaticParser::TriplesSameSubjectPathContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitTriplesSameSubjectPath(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::TriplesSameSubjectPathContext*
SparqlAutomaticParser::triplesSameSubjectPath() {
  TriplesSameSubjectPathContext* _localctx =
      _tracker.createInstance<TriplesSameSubjectPathContext>(_ctx, getState());
  enterRule(_localctx, 170, SparqlAutomaticParser::RuleTriplesSameSubjectPath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(977);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__27:
      case SparqlAutomaticParser::T__28:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::BLANK_NODE_LABEL:
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2:
      case SparqlAutomaticParser::PREFIX_LANGTAG:
      case SparqlAutomaticParser::INTEGER:
      case SparqlAutomaticParser::DECIMAL:
      case SparqlAutomaticParser::DOUBLE:
      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE:
      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE:
      case SparqlAutomaticParser::STRING_LITERAL1:
      case SparqlAutomaticParser::STRING_LITERAL2:
      case SparqlAutomaticParser::STRING_LITERAL_LONG1:
      case SparqlAutomaticParser::STRING_LITERAL_LONG2:
      case SparqlAutomaticParser::NIL:
      case SparqlAutomaticParser::ANON: {
        enterOuterAlt(_localctx, 1);
        setState(971);
        varOrTerm();
        setState(972);
        propertyListPathNotEmpty();
        break;
      }

      case SparqlAutomaticParser::T__1:
      case SparqlAutomaticParser::T__15: {
        enterOuterAlt(_localctx, 2);
        setState(974);
        triplesNodePath();
        setState(975);
        propertyListPath();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyListPathContext
//------------------------------------------------------------------

SparqlAutomaticParser::PropertyListPathContext::PropertyListPathContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::PropertyListPathNotEmptyContext*
SparqlAutomaticParser::PropertyListPathContext::propertyListPathNotEmpty() {
  return getRuleContext<SparqlAutomaticParser::PropertyListPathNotEmptyContext>(
      0);
}

size_t SparqlAutomaticParser::PropertyListPathContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePropertyListPath;
}

void SparqlAutomaticParser::PropertyListPathContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPropertyListPath(this);
}

void SparqlAutomaticParser::PropertyListPathContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPropertyListPath(this);
}

std::any SparqlAutomaticParser::PropertyListPathContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPropertyListPath(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PropertyListPathContext*
SparqlAutomaticParser::propertyListPath() {
  PropertyListPathContext* _localctx =
      _tracker.createInstance<PropertyListPathContext>(_ctx, getState());
  enterRule(_localctx, 172, SparqlAutomaticParser::RulePropertyListPath);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(980);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 37380) != 0 ||
        (((_la - 142) & ~0x3fULL) == 0) && ((1ULL << (_la - 142)) & 183) != 0) {
      setState(979);
      propertyListPathNotEmpty();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyListPathNotEmptyContext
//------------------------------------------------------------------

SparqlAutomaticParser::PropertyListPathNotEmptyContext::
    PropertyListPathNotEmptyContext(ParserRuleContext* parent,
                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::TupleWithPathContext*
SparqlAutomaticParser::PropertyListPathNotEmptyContext::tupleWithPath() {
  return getRuleContext<SparqlAutomaticParser::TupleWithPathContext>(0);
}

std::vector<SparqlAutomaticParser::TupleWithoutPathContext*>
SparqlAutomaticParser::PropertyListPathNotEmptyContext::tupleWithoutPath() {
  return getRuleContexts<SparqlAutomaticParser::TupleWithoutPathContext>();
}

SparqlAutomaticParser::TupleWithoutPathContext*
SparqlAutomaticParser::PropertyListPathNotEmptyContext::tupleWithoutPath(
    size_t i) {
  return getRuleContext<SparqlAutomaticParser::TupleWithoutPathContext>(i);
}

size_t SparqlAutomaticParser::PropertyListPathNotEmptyContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RulePropertyListPathNotEmpty;
}

void SparqlAutomaticParser::PropertyListPathNotEmptyContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyListPathNotEmpty(this);
}

void SparqlAutomaticParser::PropertyListPathNotEmptyContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyListPathNotEmpty(this);
}

std::any SparqlAutomaticParser::PropertyListPathNotEmptyContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPropertyListPathNotEmpty(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PropertyListPathNotEmptyContext*
SparqlAutomaticParser::propertyListPathNotEmpty() {
  PropertyListPathNotEmptyContext* _localctx =
      _tracker.createInstance<PropertyListPathNotEmptyContext>(_ctx,
                                                               getState());
  enterRule(_localctx, 174,
            SparqlAutomaticParser::RulePropertyListPathNotEmpty);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(982);
    tupleWithPath();
    setState(989);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__5) {
      setState(983);
      match(SparqlAutomaticParser::T__5);
      setState(985);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 37380) != 0 ||
          (((_la - 142) & ~0x3fULL) == 0) &&
              ((1ULL << (_la - 142)) & 183) != 0) {
        setState(984);
        tupleWithoutPath();
      }
      setState(991);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VerbPathContext
//------------------------------------------------------------------

SparqlAutomaticParser::VerbPathContext::VerbPathContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::PathContext*
SparqlAutomaticParser::VerbPathContext::path() {
  return getRuleContext<SparqlAutomaticParser::PathContext>(0);
}

size_t SparqlAutomaticParser::VerbPathContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleVerbPath;
}

void SparqlAutomaticParser::VerbPathContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterVerbPath(this);
}

void SparqlAutomaticParser::VerbPathContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitVerbPath(this);
}

std::any SparqlAutomaticParser::VerbPathContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitVerbPath(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::VerbPathContext* SparqlAutomaticParser::verbPath() {
  VerbPathContext* _localctx =
      _tracker.createInstance<VerbPathContext>(_ctx, getState());
  enterRule(_localctx, 176, SparqlAutomaticParser::RuleVerbPath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(992);
    path();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VerbSimpleContext
//------------------------------------------------------------------

SparqlAutomaticParser::VerbSimpleContext::VerbSimpleContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VarContext*
SparqlAutomaticParser::VerbSimpleContext::var() {
  return getRuleContext<SparqlAutomaticParser::VarContext>(0);
}

size_t SparqlAutomaticParser::VerbSimpleContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleVerbSimple;
}

void SparqlAutomaticParser::VerbSimpleContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterVerbSimple(this);
}

void SparqlAutomaticParser::VerbSimpleContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitVerbSimple(this);
}

std::any SparqlAutomaticParser::VerbSimpleContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitVerbSimple(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::VerbSimpleContext* SparqlAutomaticParser::verbSimple() {
  VerbSimpleContext* _localctx =
      _tracker.createInstance<VerbSimpleContext>(_ctx, getState());
  enterRule(_localctx, 178, SparqlAutomaticParser::RuleVerbSimple);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(994);
    var();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TupleWithoutPathContext
//------------------------------------------------------------------

SparqlAutomaticParser::TupleWithoutPathContext::TupleWithoutPathContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VerbPathOrSimpleContext*
SparqlAutomaticParser::TupleWithoutPathContext::verbPathOrSimple() {
  return getRuleContext<SparqlAutomaticParser::VerbPathOrSimpleContext>(0);
}

SparqlAutomaticParser::ObjectListContext*
SparqlAutomaticParser::TupleWithoutPathContext::objectList() {
  return getRuleContext<SparqlAutomaticParser::ObjectListContext>(0);
}

size_t SparqlAutomaticParser::TupleWithoutPathContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleTupleWithoutPath;
}

void SparqlAutomaticParser::TupleWithoutPathContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTupleWithoutPath(this);
}

void SparqlAutomaticParser::TupleWithoutPathContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTupleWithoutPath(this);
}

std::any SparqlAutomaticParser::TupleWithoutPathContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitTupleWithoutPath(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::TupleWithoutPathContext*
SparqlAutomaticParser::tupleWithoutPath() {
  TupleWithoutPathContext* _localctx =
      _tracker.createInstance<TupleWithoutPathContext>(_ctx, getState());
  enterRule(_localctx, 180, SparqlAutomaticParser::RuleTupleWithoutPath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(996);
    verbPathOrSimple();
    setState(997);
    objectList();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TupleWithPathContext
//------------------------------------------------------------------

SparqlAutomaticParser::TupleWithPathContext::TupleWithPathContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VerbPathOrSimpleContext*
SparqlAutomaticParser::TupleWithPathContext::verbPathOrSimple() {
  return getRuleContext<SparqlAutomaticParser::VerbPathOrSimpleContext>(0);
}

SparqlAutomaticParser::ObjectListPathContext*
SparqlAutomaticParser::TupleWithPathContext::objectListPath() {
  return getRuleContext<SparqlAutomaticParser::ObjectListPathContext>(0);
}

size_t SparqlAutomaticParser::TupleWithPathContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleTupleWithPath;
}

void SparqlAutomaticParser::TupleWithPathContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTupleWithPath(this);
}

void SparqlAutomaticParser::TupleWithPathContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTupleWithPath(this);
}

std::any SparqlAutomaticParser::TupleWithPathContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitTupleWithPath(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::TupleWithPathContext*
SparqlAutomaticParser::tupleWithPath() {
  TupleWithPathContext* _localctx =
      _tracker.createInstance<TupleWithPathContext>(_ctx, getState());
  enterRule(_localctx, 182, SparqlAutomaticParser::RuleTupleWithPath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(999);
    verbPathOrSimple();
    setState(1000);
    objectListPath();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VerbPathOrSimpleContext
//------------------------------------------------------------------

SparqlAutomaticParser::VerbPathOrSimpleContext::VerbPathOrSimpleContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VerbPathContext*
SparqlAutomaticParser::VerbPathOrSimpleContext::verbPath() {
  return getRuleContext<SparqlAutomaticParser::VerbPathContext>(0);
}

SparqlAutomaticParser::VerbSimpleContext*
SparqlAutomaticParser::VerbPathOrSimpleContext::verbSimple() {
  return getRuleContext<SparqlAutomaticParser::VerbSimpleContext>(0);
}

size_t SparqlAutomaticParser::VerbPathOrSimpleContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleVerbPathOrSimple;
}

void SparqlAutomaticParser::VerbPathOrSimpleContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterVerbPathOrSimple(this);
}

void SparqlAutomaticParser::VerbPathOrSimpleContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitVerbPathOrSimple(this);
}

std::any SparqlAutomaticParser::VerbPathOrSimpleContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitVerbPathOrSimple(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::VerbPathOrSimpleContext*
SparqlAutomaticParser::verbPathOrSimple() {
  VerbPathOrSimpleContext* _localctx =
      _tracker.createInstance<VerbPathOrSimpleContext>(_ctx, getState());
  enterRule(_localctx, 184, SparqlAutomaticParser::RuleVerbPathOrSimple);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1004);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__1:
      case SparqlAutomaticParser::T__8:
      case SparqlAutomaticParser::T__11:
      case SparqlAutomaticParser::T__14:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        setState(1002);
        verbPath();
        break;
      }

      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2: {
        setState(1003);
        verbSimple();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectListPathContext
//------------------------------------------------------------------

SparqlAutomaticParser::ObjectListPathContext::ObjectListPathContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::ObjectPathContext*>
SparqlAutomaticParser::ObjectListPathContext::objectPath() {
  return getRuleContexts<SparqlAutomaticParser::ObjectPathContext>();
}

SparqlAutomaticParser::ObjectPathContext*
SparqlAutomaticParser::ObjectListPathContext::objectPath(size_t i) {
  return getRuleContext<SparqlAutomaticParser::ObjectPathContext>(i);
}

size_t SparqlAutomaticParser::ObjectListPathContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleObjectListPath;
}

void SparqlAutomaticParser::ObjectListPathContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterObjectListPath(this);
}

void SparqlAutomaticParser::ObjectListPathContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitObjectListPath(this);
}

std::any SparqlAutomaticParser::ObjectListPathContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitObjectListPath(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ObjectListPathContext*
SparqlAutomaticParser::objectListPath() {
  ObjectListPathContext* _localctx =
      _tracker.createInstance<ObjectListPathContext>(_ctx, getState());
  enterRule(_localctx, 186, SparqlAutomaticParser::RuleObjectListPath);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1006);
    objectPath();
    setState(1011);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__7) {
      setState(1007);
      match(SparqlAutomaticParser::T__7);
      setState(1008);
      objectPath();
      setState(1013);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectPathContext
//------------------------------------------------------------------

SparqlAutomaticParser::ObjectPathContext::ObjectPathContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::GraphNodePathContext*
SparqlAutomaticParser::ObjectPathContext::graphNodePath() {
  return getRuleContext<SparqlAutomaticParser::GraphNodePathContext>(0);
}

size_t SparqlAutomaticParser::ObjectPathContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleObjectPath;
}

void SparqlAutomaticParser::ObjectPathContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterObjectPath(this);
}

void SparqlAutomaticParser::ObjectPathContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitObjectPath(this);
}

std::any SparqlAutomaticParser::ObjectPathContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitObjectPath(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ObjectPathContext* SparqlAutomaticParser::objectPath() {
  ObjectPathContext* _localctx =
      _tracker.createInstance<ObjectPathContext>(_ctx, getState());
  enterRule(_localctx, 188, SparqlAutomaticParser::RuleObjectPath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1014);
    graphNodePath();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PathContext
//------------------------------------------------------------------

SparqlAutomaticParser::PathContext::PathContext(ParserRuleContext* parent,
                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::PathAlternativeContext*
SparqlAutomaticParser::PathContext::pathAlternative() {
  return getRuleContext<SparqlAutomaticParser::PathAlternativeContext>(0);
}

size_t SparqlAutomaticParser::PathContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePath;
}

void SparqlAutomaticParser::PathContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPath(this);
}

void SparqlAutomaticParser::PathContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPath(this);
}

std::any SparqlAutomaticParser::PathContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPath(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PathContext* SparqlAutomaticParser::path() {
  PathContext* _localctx =
      _tracker.createInstance<PathContext>(_ctx, getState());
  enterRule(_localctx, 190, SparqlAutomaticParser::RulePath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1016);
    pathAlternative();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PathAlternativeContext
//------------------------------------------------------------------

SparqlAutomaticParser::PathAlternativeContext::PathAlternativeContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::PathSequenceContext*>
SparqlAutomaticParser::PathAlternativeContext::pathSequence() {
  return getRuleContexts<SparqlAutomaticParser::PathSequenceContext>();
}

SparqlAutomaticParser::PathSequenceContext*
SparqlAutomaticParser::PathAlternativeContext::pathSequence(size_t i) {
  return getRuleContext<SparqlAutomaticParser::PathSequenceContext>(i);
}

size_t SparqlAutomaticParser::PathAlternativeContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePathAlternative;
}

void SparqlAutomaticParser::PathAlternativeContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPathAlternative(this);
}

void SparqlAutomaticParser::PathAlternativeContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPathAlternative(this);
}

std::any SparqlAutomaticParser::PathAlternativeContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPathAlternative(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PathAlternativeContext*
SparqlAutomaticParser::pathAlternative() {
  PathAlternativeContext* _localctx =
      _tracker.createInstance<PathAlternativeContext>(_ctx, getState());
  enterRule(_localctx, 192, SparqlAutomaticParser::RulePathAlternative);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1018);
    pathSequence();
    setState(1023);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__9) {
      setState(1019);
      match(SparqlAutomaticParser::T__9);
      setState(1020);
      pathSequence();
      setState(1025);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PathSequenceContext
//------------------------------------------------------------------

SparqlAutomaticParser::PathSequenceContext::PathSequenceContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::PathEltOrInverseContext*>
SparqlAutomaticParser::PathSequenceContext::pathEltOrInverse() {
  return getRuleContexts<SparqlAutomaticParser::PathEltOrInverseContext>();
}

SparqlAutomaticParser::PathEltOrInverseContext*
SparqlAutomaticParser::PathSequenceContext::pathEltOrInverse(size_t i) {
  return getRuleContext<SparqlAutomaticParser::PathEltOrInverseContext>(i);
}

size_t SparqlAutomaticParser::PathSequenceContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePathSequence;
}

void SparqlAutomaticParser::PathSequenceContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPathSequence(this);
}

void SparqlAutomaticParser::PathSequenceContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPathSequence(this);
}

std::any SparqlAutomaticParser::PathSequenceContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPathSequence(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PathSequenceContext*
SparqlAutomaticParser::pathSequence() {
  PathSequenceContext* _localctx =
      _tracker.createInstance<PathSequenceContext>(_ctx, getState());
  enterRule(_localctx, 194, SparqlAutomaticParser::RulePathSequence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1026);
    pathEltOrInverse();
    setState(1031);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__10) {
      setState(1027);
      match(SparqlAutomaticParser::T__10);
      setState(1028);
      pathEltOrInverse();
      setState(1033);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PathEltContext
//------------------------------------------------------------------

SparqlAutomaticParser::PathEltContext::PathEltContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::PathPrimaryContext*
SparqlAutomaticParser::PathEltContext::pathPrimary() {
  return getRuleContext<SparqlAutomaticParser::PathPrimaryContext>(0);
}

SparqlAutomaticParser::PathModContext*
SparqlAutomaticParser::PathEltContext::pathMod() {
  return getRuleContext<SparqlAutomaticParser::PathModContext>(0);
}

size_t SparqlAutomaticParser::PathEltContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePathElt;
}

void SparqlAutomaticParser::PathEltContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPathElt(this);
}

void SparqlAutomaticParser::PathEltContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPathElt(this);
}

std::any SparqlAutomaticParser::PathEltContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPathElt(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PathEltContext* SparqlAutomaticParser::pathElt() {
  PathEltContext* _localctx =
      _tracker.createInstance<PathEltContext>(_ctx, getState());
  enterRule(_localctx, 196, SparqlAutomaticParser::RulePathElt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1034);
    pathPrimary();
    setState(1036);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 24578) != 0) {
      setState(1035);
      pathMod();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PathEltOrInverseContext
//------------------------------------------------------------------

SparqlAutomaticParser::PathEltOrInverseContext::PathEltOrInverseContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::PathEltContext*
SparqlAutomaticParser::PathEltOrInverseContext::pathElt() {
  return getRuleContext<SparqlAutomaticParser::PathEltContext>(0);
}

size_t SparqlAutomaticParser::PathEltOrInverseContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePathEltOrInverse;
}

void SparqlAutomaticParser::PathEltOrInverseContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPathEltOrInverse(this);
}

void SparqlAutomaticParser::PathEltOrInverseContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPathEltOrInverse(this);
}

std::any SparqlAutomaticParser::PathEltOrInverseContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPathEltOrInverse(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PathEltOrInverseContext*
SparqlAutomaticParser::pathEltOrInverse() {
  PathEltOrInverseContext* _localctx =
      _tracker.createInstance<PathEltOrInverseContext>(_ctx, getState());
  enterRule(_localctx, 198, SparqlAutomaticParser::RulePathEltOrInverse);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1041);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__1:
      case SparqlAutomaticParser::T__8:
      case SparqlAutomaticParser::T__14:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 1);
        setState(1038);
        pathElt();
        break;
      }

      case SparqlAutomaticParser::T__11: {
        enterOuterAlt(_localctx, 2);
        setState(1039);
        antlrcpp::downCast<PathEltOrInverseContext*>(_localctx)
            ->negationOperator = match(SparqlAutomaticParser::T__11);
        setState(1040);
        pathElt();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PathModContext
//------------------------------------------------------------------

SparqlAutomaticParser::PathModContext::PathModContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

size_t SparqlAutomaticParser::PathModContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePathMod;
}

void SparqlAutomaticParser::PathModContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPathMod(this);
}

void SparqlAutomaticParser::PathModContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPathMod(this);
}

std::any SparqlAutomaticParser::PathModContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPathMod(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PathModContext* SparqlAutomaticParser::pathMod() {
  PathModContext* _localctx =
      _tracker.createInstance<PathModContext>(_ctx, getState());
  enterRule(_localctx, 200, SparqlAutomaticParser::RulePathMod);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1043);
    _la = _input->LA(1);
    if (!(((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 24578) != 0)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PathPrimaryContext
//------------------------------------------------------------------

SparqlAutomaticParser::PathPrimaryContext::PathPrimaryContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::IriContext*
SparqlAutomaticParser::PathPrimaryContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

SparqlAutomaticParser::PathNegatedPropertySetContext*
SparqlAutomaticParser::PathPrimaryContext::pathNegatedPropertySet() {
  return getRuleContext<SparqlAutomaticParser::PathNegatedPropertySetContext>(
      0);
}

SparqlAutomaticParser::PathContext*
SparqlAutomaticParser::PathPrimaryContext::path() {
  return getRuleContext<SparqlAutomaticParser::PathContext>(0);
}

size_t SparqlAutomaticParser::PathPrimaryContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePathPrimary;
}

void SparqlAutomaticParser::PathPrimaryContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPathPrimary(this);
}

void SparqlAutomaticParser::PathPrimaryContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPathPrimary(this);
}

std::any SparqlAutomaticParser::PathPrimaryContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPathPrimary(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PathPrimaryContext*
SparqlAutomaticParser::pathPrimary() {
  PathPrimaryContext* _localctx =
      _tracker.createInstance<PathPrimaryContext>(_ctx, getState());
  enterRule(_localctx, 202, SparqlAutomaticParser::RulePathPrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1053);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 1);
        setState(1045);
        iri();
        break;
      }

      case SparqlAutomaticParser::T__8: {
        enterOuterAlt(_localctx, 2);
        setState(1046);
        match(SparqlAutomaticParser::T__8);
        break;
      }

      case SparqlAutomaticParser::T__14: {
        enterOuterAlt(_localctx, 3);
        setState(1047);
        match(SparqlAutomaticParser::T__14);
        setState(1048);
        pathNegatedPropertySet();
        break;
      }

      case SparqlAutomaticParser::T__1: {
        enterOuterAlt(_localctx, 4);
        setState(1049);
        match(SparqlAutomaticParser::T__1);
        setState(1050);
        path();
        setState(1051);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PathNegatedPropertySetContext
//------------------------------------------------------------------

SparqlAutomaticParser::PathNegatedPropertySetContext::
    PathNegatedPropertySetContext(ParserRuleContext* parent,
                                  size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::PathOneInPropertySetContext*>
SparqlAutomaticParser::PathNegatedPropertySetContext::pathOneInPropertySet() {
  return getRuleContexts<SparqlAutomaticParser::PathOneInPropertySetContext>();
}

SparqlAutomaticParser::PathOneInPropertySetContext*
SparqlAutomaticParser::PathNegatedPropertySetContext::pathOneInPropertySet(
    size_t i) {
  return getRuleContext<SparqlAutomaticParser::PathOneInPropertySetContext>(i);
}

size_t SparqlAutomaticParser::PathNegatedPropertySetContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RulePathNegatedPropertySet;
}

void SparqlAutomaticParser::PathNegatedPropertySetContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterPathNegatedPropertySet(this);
}

void SparqlAutomaticParser::PathNegatedPropertySetContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitPathNegatedPropertySet(this);
}

std::any SparqlAutomaticParser::PathNegatedPropertySetContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPathNegatedPropertySet(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PathNegatedPropertySetContext*
SparqlAutomaticParser::pathNegatedPropertySet() {
  PathNegatedPropertySetContext* _localctx =
      _tracker.createInstance<PathNegatedPropertySetContext>(_ctx, getState());
  enterRule(_localctx, 204, SparqlAutomaticParser::RulePathNegatedPropertySet);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1068);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__8:
      case SparqlAutomaticParser::T__11:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 1);
        setState(1055);
        pathOneInPropertySet();
        break;
      }

      case SparqlAutomaticParser::T__1: {
        enterOuterAlt(_localctx, 2);
        setState(1056);
        match(SparqlAutomaticParser::T__1);
        setState(1065);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::T__8

            || _la == SparqlAutomaticParser::T__11 ||
            (((_la - 142) & ~0x3fULL) == 0) &&
                ((1ULL << (_la - 142)) & 135) != 0) {
          setState(1057);
          pathOneInPropertySet();
          setState(1062);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SparqlAutomaticParser::T__9) {
            setState(1058);
            match(SparqlAutomaticParser::T__9);
            setState(1059);
            pathOneInPropertySet();
            setState(1064);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        setState(1067);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PathOneInPropertySetContext
//------------------------------------------------------------------

SparqlAutomaticParser::PathOneInPropertySetContext::PathOneInPropertySetContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::IriContext*
SparqlAutomaticParser::PathOneInPropertySetContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

size_t SparqlAutomaticParser::PathOneInPropertySetContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RulePathOneInPropertySet;
}

void SparqlAutomaticParser::PathOneInPropertySetContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterPathOneInPropertySet(this);
}

void SparqlAutomaticParser::PathOneInPropertySetContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPathOneInPropertySet(this);
}

std::any SparqlAutomaticParser::PathOneInPropertySetContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPathOneInPropertySet(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PathOneInPropertySetContext*
SparqlAutomaticParser::pathOneInPropertySet() {
  PathOneInPropertySetContext* _localctx =
      _tracker.createInstance<PathOneInPropertySetContext>(_ctx, getState());
  enterRule(_localctx, 206, SparqlAutomaticParser::RulePathOneInPropertySet);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1077);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 1);
        setState(1070);
        iri();
        break;
      }

      case SparqlAutomaticParser::T__8: {
        enterOuterAlt(_localctx, 2);
        setState(1071);
        match(SparqlAutomaticParser::T__8);
        break;
      }

      case SparqlAutomaticParser::T__11: {
        enterOuterAlt(_localctx, 3);
        setState(1072);
        match(SparqlAutomaticParser::T__11);
        setState(1075);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SparqlAutomaticParser::IRI_REF:
          case SparqlAutomaticParser::PNAME_NS:
          case SparqlAutomaticParser::PNAME_LN:
          case SparqlAutomaticParser::PREFIX_LANGTAG: {
            setState(1073);
            iri();
            break;
          }

          case SparqlAutomaticParser::T__8: {
            setState(1074);
            match(SparqlAutomaticParser::T__8);
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntegerContext
//------------------------------------------------------------------

SparqlAutomaticParser::IntegerContext::IntegerContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::IntegerContext::INTEGER() {
  return getToken(SparqlAutomaticParser::INTEGER, 0);
}

size_t SparqlAutomaticParser::IntegerContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleInteger;
}

void SparqlAutomaticParser::IntegerContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterInteger(this);
}

void SparqlAutomaticParser::IntegerContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitInteger(this);
}

std::any SparqlAutomaticParser::IntegerContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitInteger(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::IntegerContext* SparqlAutomaticParser::integer() {
  IntegerContext* _localctx =
      _tracker.createInstance<IntegerContext>(_ctx, getState());
  enterRule(_localctx, 208, SparqlAutomaticParser::RuleInteger);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1079);
    match(SparqlAutomaticParser::INTEGER);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriplesNodeContext
//------------------------------------------------------------------

SparqlAutomaticParser::TriplesNodeContext::TriplesNodeContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::CollectionContext*
SparqlAutomaticParser::TriplesNodeContext::collection() {
  return getRuleContext<SparqlAutomaticParser::CollectionContext>(0);
}

SparqlAutomaticParser::BlankNodePropertyListContext*
SparqlAutomaticParser::TriplesNodeContext::blankNodePropertyList() {
  return getRuleContext<SparqlAutomaticParser::BlankNodePropertyListContext>(0);
}

size_t SparqlAutomaticParser::TriplesNodeContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleTriplesNode;
}

void SparqlAutomaticParser::TriplesNodeContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTriplesNode(this);
}

void SparqlAutomaticParser::TriplesNodeContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTriplesNode(this);
}

std::any SparqlAutomaticParser::TriplesNodeContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitTriplesNode(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::TriplesNodeContext*
SparqlAutomaticParser::triplesNode() {
  TriplesNodeContext* _localctx =
      _tracker.createInstance<TriplesNodeContext>(_ctx, getState());
  enterRule(_localctx, 210, SparqlAutomaticParser::RuleTriplesNode);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1083);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__1: {
        enterOuterAlt(_localctx, 1);
        setState(1081);
        collection();
        break;
      }

      case SparqlAutomaticParser::T__15: {
        enterOuterAlt(_localctx, 2);
        setState(1082);
        blankNodePropertyList();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlankNodePropertyListContext
//------------------------------------------------------------------

SparqlAutomaticParser::BlankNodePropertyListContext::
    BlankNodePropertyListContext(ParserRuleContext* parent,
                                 size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::PropertyListNotEmptyContext*
SparqlAutomaticParser::BlankNodePropertyListContext::propertyListNotEmpty() {
  return getRuleContext<SparqlAutomaticParser::PropertyListNotEmptyContext>(0);
}

size_t SparqlAutomaticParser::BlankNodePropertyListContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleBlankNodePropertyList;
}

void SparqlAutomaticParser::BlankNodePropertyListContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlankNodePropertyList(this);
}

void SparqlAutomaticParser::BlankNodePropertyListContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlankNodePropertyList(this);
}

std::any SparqlAutomaticParser::BlankNodePropertyListContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitBlankNodePropertyList(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::BlankNodePropertyListContext*
SparqlAutomaticParser::blankNodePropertyList() {
  BlankNodePropertyListContext* _localctx =
      _tracker.createInstance<BlankNodePropertyListContext>(_ctx, getState());
  enterRule(_localctx, 212, SparqlAutomaticParser::RuleBlankNodePropertyList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1085);
    match(SparqlAutomaticParser::T__15);
    setState(1086);
    propertyListNotEmpty();
    setState(1087);
    match(SparqlAutomaticParser::T__16);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriplesNodePathContext
//------------------------------------------------------------------

SparqlAutomaticParser::TriplesNodePathContext::TriplesNodePathContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::CollectionPathContext*
SparqlAutomaticParser::TriplesNodePathContext::collectionPath() {
  return getRuleContext<SparqlAutomaticParser::CollectionPathContext>(0);
}

SparqlAutomaticParser::BlankNodePropertyListPathContext*
SparqlAutomaticParser::TriplesNodePathContext::blankNodePropertyListPath() {
  return getRuleContext<
      SparqlAutomaticParser::BlankNodePropertyListPathContext>(0);
}

size_t SparqlAutomaticParser::TriplesNodePathContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleTriplesNodePath;
}

void SparqlAutomaticParser::TriplesNodePathContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTriplesNodePath(this);
}

void SparqlAutomaticParser::TriplesNodePathContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTriplesNodePath(this);
}

std::any SparqlAutomaticParser::TriplesNodePathContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitTriplesNodePath(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::TriplesNodePathContext*
SparqlAutomaticParser::triplesNodePath() {
  TriplesNodePathContext* _localctx =
      _tracker.createInstance<TriplesNodePathContext>(_ctx, getState());
  enterRule(_localctx, 214, SparqlAutomaticParser::RuleTriplesNodePath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1091);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__1: {
        enterOuterAlt(_localctx, 1);
        setState(1089);
        collectionPath();
        break;
      }

      case SparqlAutomaticParser::T__15: {
        enterOuterAlt(_localctx, 2);
        setState(1090);
        blankNodePropertyListPath();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlankNodePropertyListPathContext
//------------------------------------------------------------------

SparqlAutomaticParser::BlankNodePropertyListPathContext::
    BlankNodePropertyListPathContext(ParserRuleContext* parent,
                                     size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::PropertyListPathNotEmptyContext* SparqlAutomaticParser::
    BlankNodePropertyListPathContext::propertyListPathNotEmpty() {
  return getRuleContext<SparqlAutomaticParser::PropertyListPathNotEmptyContext>(
      0);
}

size_t SparqlAutomaticParser::BlankNodePropertyListPathContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleBlankNodePropertyListPath;
}

void SparqlAutomaticParser::BlankNodePropertyListPathContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlankNodePropertyListPath(this);
}

void SparqlAutomaticParser::BlankNodePropertyListPathContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlankNodePropertyListPath(this);
}

std::any SparqlAutomaticParser::BlankNodePropertyListPathContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitBlankNodePropertyListPath(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::BlankNodePropertyListPathContext*
SparqlAutomaticParser::blankNodePropertyListPath() {
  BlankNodePropertyListPathContext* _localctx =
      _tracker.createInstance<BlankNodePropertyListPathContext>(_ctx,
                                                                getState());
  enterRule(_localctx, 216,
            SparqlAutomaticParser::RuleBlankNodePropertyListPath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1093);
    match(SparqlAutomaticParser::T__15);
    setState(1094);
    propertyListPathNotEmpty();
    setState(1095);
    match(SparqlAutomaticParser::T__16);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollectionContext
//------------------------------------------------------------------

SparqlAutomaticParser::CollectionContext::CollectionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::GraphNodeContext*>
SparqlAutomaticParser::CollectionContext::graphNode() {
  return getRuleContexts<SparqlAutomaticParser::GraphNodeContext>();
}

SparqlAutomaticParser::GraphNodeContext*
SparqlAutomaticParser::CollectionContext::graphNode(size_t i) {
  return getRuleContext<SparqlAutomaticParser::GraphNodeContext>(i);
}

size_t SparqlAutomaticParser::CollectionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleCollection;
}

void SparqlAutomaticParser::CollectionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterCollection(this);
}

void SparqlAutomaticParser::CollectionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitCollection(this);
}

std::any SparqlAutomaticParser::CollectionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitCollection(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::CollectionContext* SparqlAutomaticParser::collection() {
  CollectionContext* _localctx =
      _tracker.createInstance<CollectionContext>(_ctx, getState());
  enterRule(_localctx, 218, SparqlAutomaticParser::RuleCollection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1097);
    match(SparqlAutomaticParser::T__1);
    setState(1099);
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1098);
      graphNode();
      setState(1101);
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 805371908) != 0 ||
             (((_la - 142) & ~0x3fULL) == 0) &&
                 ((1ULL << (_la - 142)) & 29228991) != 0);
    setState(1103);
    match(SparqlAutomaticParser::T__2);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollectionPathContext
//------------------------------------------------------------------

SparqlAutomaticParser::CollectionPathContext::CollectionPathContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::GraphNodePathContext*>
SparqlAutomaticParser::CollectionPathContext::graphNodePath() {
  return getRuleContexts<SparqlAutomaticParser::GraphNodePathContext>();
}

SparqlAutomaticParser::GraphNodePathContext*
SparqlAutomaticParser::CollectionPathContext::graphNodePath(size_t i) {
  return getRuleContext<SparqlAutomaticParser::GraphNodePathContext>(i);
}

size_t SparqlAutomaticParser::CollectionPathContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleCollectionPath;
}

void SparqlAutomaticParser::CollectionPathContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterCollectionPath(this);
}

void SparqlAutomaticParser::CollectionPathContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitCollectionPath(this);
}

std::any SparqlAutomaticParser::CollectionPathContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitCollectionPath(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::CollectionPathContext*
SparqlAutomaticParser::collectionPath() {
  CollectionPathContext* _localctx =
      _tracker.createInstance<CollectionPathContext>(_ctx, getState());
  enterRule(_localctx, 220, SparqlAutomaticParser::RuleCollectionPath);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1105);
    match(SparqlAutomaticParser::T__1);
    setState(1107);
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1106);
      graphNodePath();
      setState(1109);
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 805371908) != 0 ||
             (((_la - 142) & ~0x3fULL) == 0) &&
                 ((1ULL << (_la - 142)) & 29228991) != 0);
    setState(1111);
    match(SparqlAutomaticParser::T__2);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GraphNodeContext
//------------------------------------------------------------------

SparqlAutomaticParser::GraphNodeContext::GraphNodeContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VarOrTermContext*
SparqlAutomaticParser::GraphNodeContext::varOrTerm() {
  return getRuleContext<SparqlAutomaticParser::VarOrTermContext>(0);
}

SparqlAutomaticParser::TriplesNodeContext*
SparqlAutomaticParser::GraphNodeContext::triplesNode() {
  return getRuleContext<SparqlAutomaticParser::TriplesNodeContext>(0);
}

size_t SparqlAutomaticParser::GraphNodeContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleGraphNode;
}

void SparqlAutomaticParser::GraphNodeContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterGraphNode(this);
}

void SparqlAutomaticParser::GraphNodeContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitGraphNode(this);
}

std::any SparqlAutomaticParser::GraphNodeContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGraphNode(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GraphNodeContext* SparqlAutomaticParser::graphNode() {
  GraphNodeContext* _localctx =
      _tracker.createInstance<GraphNodeContext>(_ctx, getState());
  enterRule(_localctx, 222, SparqlAutomaticParser::RuleGraphNode);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1115);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__27:
      case SparqlAutomaticParser::T__28:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::BLANK_NODE_LABEL:
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2:
      case SparqlAutomaticParser::PREFIX_LANGTAG:
      case SparqlAutomaticParser::INTEGER:
      case SparqlAutomaticParser::DECIMAL:
      case SparqlAutomaticParser::DOUBLE:
      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE:
      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE:
      case SparqlAutomaticParser::STRING_LITERAL1:
      case SparqlAutomaticParser::STRING_LITERAL2:
      case SparqlAutomaticParser::STRING_LITERAL_LONG1:
      case SparqlAutomaticParser::STRING_LITERAL_LONG2:
      case SparqlAutomaticParser::NIL:
      case SparqlAutomaticParser::ANON: {
        enterOuterAlt(_localctx, 1);
        setState(1113);
        varOrTerm();
        break;
      }

      case SparqlAutomaticParser::T__1:
      case SparqlAutomaticParser::T__15: {
        enterOuterAlt(_localctx, 2);
        setState(1114);
        triplesNode();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GraphNodePathContext
//------------------------------------------------------------------

SparqlAutomaticParser::GraphNodePathContext::GraphNodePathContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VarOrTermContext*
SparqlAutomaticParser::GraphNodePathContext::varOrTerm() {
  return getRuleContext<SparqlAutomaticParser::VarOrTermContext>(0);
}

SparqlAutomaticParser::TriplesNodePathContext*
SparqlAutomaticParser::GraphNodePathContext::triplesNodePath() {
  return getRuleContext<SparqlAutomaticParser::TriplesNodePathContext>(0);
}

size_t SparqlAutomaticParser::GraphNodePathContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleGraphNodePath;
}

void SparqlAutomaticParser::GraphNodePathContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterGraphNodePath(this);
}

void SparqlAutomaticParser::GraphNodePathContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitGraphNodePath(this);
}

std::any SparqlAutomaticParser::GraphNodePathContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGraphNodePath(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GraphNodePathContext*
SparqlAutomaticParser::graphNodePath() {
  GraphNodePathContext* _localctx =
      _tracker.createInstance<GraphNodePathContext>(_ctx, getState());
  enterRule(_localctx, 224, SparqlAutomaticParser::RuleGraphNodePath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1119);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__27:
      case SparqlAutomaticParser::T__28:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::BLANK_NODE_LABEL:
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2:
      case SparqlAutomaticParser::PREFIX_LANGTAG:
      case SparqlAutomaticParser::INTEGER:
      case SparqlAutomaticParser::DECIMAL:
      case SparqlAutomaticParser::DOUBLE:
      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE:
      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE:
      case SparqlAutomaticParser::STRING_LITERAL1:
      case SparqlAutomaticParser::STRING_LITERAL2:
      case SparqlAutomaticParser::STRING_LITERAL_LONG1:
      case SparqlAutomaticParser::STRING_LITERAL_LONG2:
      case SparqlAutomaticParser::NIL:
      case SparqlAutomaticParser::ANON: {
        enterOuterAlt(_localctx, 1);
        setState(1117);
        varOrTerm();
        break;
      }

      case SparqlAutomaticParser::T__1:
      case SparqlAutomaticParser::T__15: {
        enterOuterAlt(_localctx, 2);
        setState(1118);
        triplesNodePath();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarOrTermContext
//------------------------------------------------------------------

SparqlAutomaticParser::VarOrTermContext::VarOrTermContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VarContext*
SparqlAutomaticParser::VarOrTermContext::var() {
  return getRuleContext<SparqlAutomaticParser::VarContext>(0);
}

SparqlAutomaticParser::GraphTermContext*
SparqlAutomaticParser::VarOrTermContext::graphTerm() {
  return getRuleContext<SparqlAutomaticParser::GraphTermContext>(0);
}

size_t SparqlAutomaticParser::VarOrTermContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleVarOrTerm;
}

void SparqlAutomaticParser::VarOrTermContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterVarOrTerm(this);
}

void SparqlAutomaticParser::VarOrTermContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitVarOrTerm(this);
}

std::any SparqlAutomaticParser::VarOrTermContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitVarOrTerm(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::VarOrTermContext* SparqlAutomaticParser::varOrTerm() {
  VarOrTermContext* _localctx =
      _tracker.createInstance<VarOrTermContext>(_ctx, getState());
  enterRule(_localctx, 226, SparqlAutomaticParser::RuleVarOrTerm);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1123);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2: {
        enterOuterAlt(_localctx, 1);
        setState(1121);
        var();
        break;
      }

      case SparqlAutomaticParser::T__27:
      case SparqlAutomaticParser::T__28:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::BLANK_NODE_LABEL:
      case SparqlAutomaticParser::PREFIX_LANGTAG:
      case SparqlAutomaticParser::INTEGER:
      case SparqlAutomaticParser::DECIMAL:
      case SparqlAutomaticParser::DOUBLE:
      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE:
      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE:
      case SparqlAutomaticParser::STRING_LITERAL1:
      case SparqlAutomaticParser::STRING_LITERAL2:
      case SparqlAutomaticParser::STRING_LITERAL_LONG1:
      case SparqlAutomaticParser::STRING_LITERAL_LONG2:
      case SparqlAutomaticParser::NIL:
      case SparqlAutomaticParser::ANON: {
        enterOuterAlt(_localctx, 2);
        setState(1122);
        graphTerm();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarOrIriContext
//------------------------------------------------------------------

SparqlAutomaticParser::VarOrIriContext::VarOrIriContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::VarContext*
SparqlAutomaticParser::VarOrIriContext::var() {
  return getRuleContext<SparqlAutomaticParser::VarContext>(0);
}

SparqlAutomaticParser::IriContext*
SparqlAutomaticParser::VarOrIriContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

size_t SparqlAutomaticParser::VarOrIriContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleVarOrIri;
}

void SparqlAutomaticParser::VarOrIriContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterVarOrIri(this);
}

void SparqlAutomaticParser::VarOrIriContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitVarOrIri(this);
}

std::any SparqlAutomaticParser::VarOrIriContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitVarOrIri(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::VarOrIriContext* SparqlAutomaticParser::varOrIri() {
  VarOrIriContext* _localctx =
      _tracker.createInstance<VarOrIriContext>(_ctx, getState());
  enterRule(_localctx, 228, SparqlAutomaticParser::RuleVarOrIri);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1127);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2: {
        enterOuterAlt(_localctx, 1);
        setState(1125);
        var();
        break;
      }

      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 2);
        setState(1126);
        iri();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarContext
//------------------------------------------------------------------

SparqlAutomaticParser::VarContext::VarContext(ParserRuleContext* parent,
                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::VarContext::VAR1() {
  return getToken(SparqlAutomaticParser::VAR1, 0);
}

tree::TerminalNode* SparqlAutomaticParser::VarContext::VAR2() {
  return getToken(SparqlAutomaticParser::VAR2, 0);
}

size_t SparqlAutomaticParser::VarContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleVar;
}

void SparqlAutomaticParser::VarContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterVar(this);
}

void SparqlAutomaticParser::VarContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitVar(this);
}

std::any SparqlAutomaticParser::VarContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitVar(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::VarContext* SparqlAutomaticParser::var() {
  VarContext* _localctx = _tracker.createInstance<VarContext>(_ctx, getState());
  enterRule(_localctx, 230, SparqlAutomaticParser::RuleVar);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1129);
    _la = _input->LA(1);
    if (!(_la == SparqlAutomaticParser::VAR1

          || _la == SparqlAutomaticParser::VAR2)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GraphTermContext
//------------------------------------------------------------------

SparqlAutomaticParser::GraphTermContext::GraphTermContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::IriContext*
SparqlAutomaticParser::GraphTermContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

SparqlAutomaticParser::RdfLiteralContext*
SparqlAutomaticParser::GraphTermContext::rdfLiteral() {
  return getRuleContext<SparqlAutomaticParser::RdfLiteralContext>(0);
}

SparqlAutomaticParser::NumericLiteralContext*
SparqlAutomaticParser::GraphTermContext::numericLiteral() {
  return getRuleContext<SparqlAutomaticParser::NumericLiteralContext>(0);
}

SparqlAutomaticParser::BooleanLiteralContext*
SparqlAutomaticParser::GraphTermContext::booleanLiteral() {
  return getRuleContext<SparqlAutomaticParser::BooleanLiteralContext>(0);
}

SparqlAutomaticParser::BlankNodeContext*
SparqlAutomaticParser::GraphTermContext::blankNode() {
  return getRuleContext<SparqlAutomaticParser::BlankNodeContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::GraphTermContext::NIL() {
  return getToken(SparqlAutomaticParser::NIL, 0);
}

size_t SparqlAutomaticParser::GraphTermContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleGraphTerm;
}

void SparqlAutomaticParser::GraphTermContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterGraphTerm(this);
}

void SparqlAutomaticParser::GraphTermContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitGraphTerm(this);
}

std::any SparqlAutomaticParser::GraphTermContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitGraphTerm(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::GraphTermContext* SparqlAutomaticParser::graphTerm() {
  GraphTermContext* _localctx =
      _tracker.createInstance<GraphTermContext>(_ctx, getState());
  enterRule(_localctx, 232, SparqlAutomaticParser::RuleGraphTerm);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1137);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 1);
        setState(1131);
        iri();
        break;
      }

      case SparqlAutomaticParser::STRING_LITERAL1:
      case SparqlAutomaticParser::STRING_LITERAL2:
      case SparqlAutomaticParser::STRING_LITERAL_LONG1:
      case SparqlAutomaticParser::STRING_LITERAL_LONG2: {
        enterOuterAlt(_localctx, 2);
        setState(1132);
        rdfLiteral();
        break;
      }

      case SparqlAutomaticParser::INTEGER:
      case SparqlAutomaticParser::DECIMAL:
      case SparqlAutomaticParser::DOUBLE:
      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE:
      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE: {
        enterOuterAlt(_localctx, 3);
        setState(1133);
        numericLiteral();
        break;
      }

      case SparqlAutomaticParser::T__27:
      case SparqlAutomaticParser::T__28: {
        enterOuterAlt(_localctx, 4);
        setState(1134);
        booleanLiteral();
        break;
      }

      case SparqlAutomaticParser::BLANK_NODE_LABEL:
      case SparqlAutomaticParser::ANON: {
        enterOuterAlt(_localctx, 5);
        setState(1135);
        blankNode();
        break;
      }

      case SparqlAutomaticParser::NIL: {
        enterOuterAlt(_localctx, 6);
        setState(1136);
        match(SparqlAutomaticParser::NIL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::ExpressionContext::ExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::ConditionalOrExpressionContext*
SparqlAutomaticParser::ExpressionContext::conditionalOrExpression() {
  return getRuleContext<SparqlAutomaticParser::ConditionalOrExpressionContext>(
      0);
}

size_t SparqlAutomaticParser::ExpressionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleExpression;
}

void SparqlAutomaticParser::ExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterExpression(this);
}

void SparqlAutomaticParser::ExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitExpression(this);
}

std::any SparqlAutomaticParser::ExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ExpressionContext* SparqlAutomaticParser::expression() {
  ExpressionContext* _localctx =
      _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 234, SparqlAutomaticParser::RuleExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1139);
    conditionalOrExpression();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionalOrExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::ConditionalOrExpressionContext::
    ConditionalOrExpressionContext(ParserRuleContext* parent,
                                   size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::ConditionalAndExpressionContext*>
SparqlAutomaticParser::ConditionalOrExpressionContext::
    conditionalAndExpression() {
  return getRuleContexts<
      SparqlAutomaticParser::ConditionalAndExpressionContext>();
}

SparqlAutomaticParser::ConditionalAndExpressionContext*
SparqlAutomaticParser::ConditionalOrExpressionContext::conditionalAndExpression(
    size_t i) {
  return getRuleContext<SparqlAutomaticParser::ConditionalAndExpressionContext>(
      i);
}

size_t SparqlAutomaticParser::ConditionalOrExpressionContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleConditionalOrExpression;
}

void SparqlAutomaticParser::ConditionalOrExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionalOrExpression(this);
}

void SparqlAutomaticParser::ConditionalOrExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionalOrExpression(this);
}

std::any SparqlAutomaticParser::ConditionalOrExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitConditionalOrExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ConditionalOrExpressionContext*
SparqlAutomaticParser::conditionalOrExpression() {
  ConditionalOrExpressionContext* _localctx =
      _tracker.createInstance<ConditionalOrExpressionContext>(_ctx, getState());
  enterRule(_localctx, 236, SparqlAutomaticParser::RuleConditionalOrExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1141);
    conditionalAndExpression();
    setState(1146);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__17) {
      setState(1142);
      match(SparqlAutomaticParser::T__17);
      setState(1143);
      conditionalAndExpression();
      setState(1148);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionalAndExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::ConditionalAndExpressionContext::
    ConditionalAndExpressionContext(ParserRuleContext* parent,
                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::ValueLogicalContext*>
SparqlAutomaticParser::ConditionalAndExpressionContext::valueLogical() {
  return getRuleContexts<SparqlAutomaticParser::ValueLogicalContext>();
}

SparqlAutomaticParser::ValueLogicalContext*
SparqlAutomaticParser::ConditionalAndExpressionContext::valueLogical(size_t i) {
  return getRuleContext<SparqlAutomaticParser::ValueLogicalContext>(i);
}

size_t SparqlAutomaticParser::ConditionalAndExpressionContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleConditionalAndExpression;
}

void SparqlAutomaticParser::ConditionalAndExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionalAndExpression(this);
}

void SparqlAutomaticParser::ConditionalAndExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionalAndExpression(this);
}

std::any SparqlAutomaticParser::ConditionalAndExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitConditionalAndExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ConditionalAndExpressionContext*
SparqlAutomaticParser::conditionalAndExpression() {
  ConditionalAndExpressionContext* _localctx =
      _tracker.createInstance<ConditionalAndExpressionContext>(_ctx,
                                                               getState());
  enterRule(_localctx, 238,
            SparqlAutomaticParser::RuleConditionalAndExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1149);
    valueLogical();
    setState(1154);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__18) {
      setState(1150);
      match(SparqlAutomaticParser::T__18);
      setState(1151);
      valueLogical();
      setState(1156);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueLogicalContext
//------------------------------------------------------------------

SparqlAutomaticParser::ValueLogicalContext::ValueLogicalContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::RelationalExpressionContext*
SparqlAutomaticParser::ValueLogicalContext::relationalExpression() {
  return getRuleContext<SparqlAutomaticParser::RelationalExpressionContext>(0);
}

size_t SparqlAutomaticParser::ValueLogicalContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleValueLogical;
}

void SparqlAutomaticParser::ValueLogicalContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterValueLogical(this);
}

void SparqlAutomaticParser::ValueLogicalContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitValueLogical(this);
}

std::any SparqlAutomaticParser::ValueLogicalContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitValueLogical(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ValueLogicalContext*
SparqlAutomaticParser::valueLogical() {
  ValueLogicalContext* _localctx =
      _tracker.createInstance<ValueLogicalContext>(_ctx, getState());
  enterRule(_localctx, 240, SparqlAutomaticParser::RuleValueLogical);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1157);
    relationalExpression();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationalExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::RelationalExpressionContext::RelationalExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<SparqlAutomaticParser::NumericExpressionContext*>
SparqlAutomaticParser::RelationalExpressionContext::numericExpression() {
  return getRuleContexts<SparqlAutomaticParser::NumericExpressionContext>();
}

SparqlAutomaticParser::NumericExpressionContext*
SparqlAutomaticParser::RelationalExpressionContext::numericExpression(
    size_t i) {
  return getRuleContext<SparqlAutomaticParser::NumericExpressionContext>(i);
}

tree::TerminalNode* SparqlAutomaticParser::RelationalExpressionContext::IN() {
  return getToken(SparqlAutomaticParser::IN, 0);
}

SparqlAutomaticParser::ExpressionListContext*
SparqlAutomaticParser::RelationalExpressionContext::expressionList() {
  return getRuleContext<SparqlAutomaticParser::ExpressionListContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::RelationalExpressionContext::NOT() {
  return getToken(SparqlAutomaticParser::NOT, 0);
}

size_t SparqlAutomaticParser::RelationalExpressionContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleRelationalExpression;
}

void SparqlAutomaticParser::RelationalExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelationalExpression(this);
}

void SparqlAutomaticParser::RelationalExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitRelationalExpression(this);
}

std::any SparqlAutomaticParser::RelationalExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitRelationalExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::RelationalExpressionContext*
SparqlAutomaticParser::relationalExpression() {
  RelationalExpressionContext* _localctx =
      _tracker.createInstance<RelationalExpressionContext>(_ctx, getState());
  enterRule(_localctx, 242, SparqlAutomaticParser::RuleRelationalExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1159);
    numericExpression();
    setState(1177);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__19: {
        setState(1160);
        match(SparqlAutomaticParser::T__19);
        setState(1161);
        numericExpression();
        break;
      }

      case SparqlAutomaticParser::T__20: {
        setState(1162);
        match(SparqlAutomaticParser::T__20);
        setState(1163);
        numericExpression();
        break;
      }

      case SparqlAutomaticParser::T__21: {
        setState(1164);
        match(SparqlAutomaticParser::T__21);
        setState(1165);
        numericExpression();
        break;
      }

      case SparqlAutomaticParser::T__22: {
        setState(1166);
        match(SparqlAutomaticParser::T__22);
        setState(1167);
        numericExpression();
        break;
      }

      case SparqlAutomaticParser::T__23: {
        setState(1168);
        match(SparqlAutomaticParser::T__23);
        setState(1169);
        numericExpression();
        break;
      }

      case SparqlAutomaticParser::T__24: {
        setState(1170);
        match(SparqlAutomaticParser::T__24);
        setState(1171);
        numericExpression();
        break;
      }

      case SparqlAutomaticParser::IN: {
        setState(1172);
        match(SparqlAutomaticParser::IN);
        setState(1173);
        expressionList();
        break;
      }

      case SparqlAutomaticParser::NOT: {
        setState(1174);
        antlrcpp::downCast<RelationalExpressionContext*>(_localctx)->notToken =
            match(SparqlAutomaticParser::NOT);
        setState(1175);
        match(SparqlAutomaticParser::IN);
        setState(1176);
        expressionList();
        break;
      }

      case SparqlAutomaticParser::T__2:
      case SparqlAutomaticParser::T__5:
      case SparqlAutomaticParser::T__7:
      case SparqlAutomaticParser::T__17:
      case SparqlAutomaticParser::T__18:
      case SparqlAutomaticParser::AS: {
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::NumericExpressionContext::NumericExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::AdditiveExpressionContext*
SparqlAutomaticParser::NumericExpressionContext::additiveExpression() {
  return getRuleContext<SparqlAutomaticParser::AdditiveExpressionContext>(0);
}

size_t SparqlAutomaticParser::NumericExpressionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleNumericExpression;
}

void SparqlAutomaticParser::NumericExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterNumericExpression(this);
}

void SparqlAutomaticParser::NumericExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitNumericExpression(this);
}

std::any SparqlAutomaticParser::NumericExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitNumericExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::NumericExpressionContext*
SparqlAutomaticParser::numericExpression() {
  NumericExpressionContext* _localctx =
      _tracker.createInstance<NumericExpressionContext>(_ctx, getState());
  enterRule(_localctx, 244, SparqlAutomaticParser::RuleNumericExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1179);
    additiveExpression();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdditiveExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::AdditiveExpressionContext::AdditiveExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::MultiplicativeExpressionContext*
SparqlAutomaticParser::AdditiveExpressionContext::multiplicativeExpression() {
  return getRuleContext<SparqlAutomaticParser::MultiplicativeExpressionContext>(
      0);
}

std::vector<SparqlAutomaticParser::MultiplicativeExpressionWithSignContext*>
SparqlAutomaticParser::AdditiveExpressionContext::
    multiplicativeExpressionWithSign() {
  return getRuleContexts<
      SparqlAutomaticParser::MultiplicativeExpressionWithSignContext>();
}

SparqlAutomaticParser::MultiplicativeExpressionWithSignContext*
SparqlAutomaticParser::AdditiveExpressionContext::
    multiplicativeExpressionWithSign(size_t i) {
  return getRuleContext<
      SparqlAutomaticParser::MultiplicativeExpressionWithSignContext>(i);
}

size_t SparqlAutomaticParser::AdditiveExpressionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleAdditiveExpression;
}

void SparqlAutomaticParser::AdditiveExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterAdditiveExpression(this);
}

void SparqlAutomaticParser::AdditiveExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitAdditiveExpression(this);
}

std::any SparqlAutomaticParser::AdditiveExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitAdditiveExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::AdditiveExpressionContext*
SparqlAutomaticParser::additiveExpression() {
  AdditiveExpressionContext* _localctx =
      _tracker.createInstance<AdditiveExpressionContext>(_ctx, getState());
  enterRule(_localctx, 246, SparqlAutomaticParser::RuleAdditiveExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1181);
    multiplicativeExpression();
    setState(1185);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__12

           || _la == SparqlAutomaticParser::T__25 ||
           (((_la - 153) & ~0x3fULL) == 0) &&
               ((1ULL << (_la - 153)) & 63) != 0) {
      setState(1182);
      multiplicativeExpressionWithSign();
      setState(1187);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiplicativeExpressionWithSignContext
//------------------------------------------------------------------

SparqlAutomaticParser::MultiplicativeExpressionWithSignContext::
    MultiplicativeExpressionWithSignContext(ParserRuleContext* parent,
                                            size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::PlusSubexpressionContext* SparqlAutomaticParser::
    MultiplicativeExpressionWithSignContext::plusSubexpression() {
  return getRuleContext<SparqlAutomaticParser::PlusSubexpressionContext>(0);
}

SparqlAutomaticParser::MinusSubexpressionContext* SparqlAutomaticParser::
    MultiplicativeExpressionWithSignContext::minusSubexpression() {
  return getRuleContext<SparqlAutomaticParser::MinusSubexpressionContext>(0);
}

SparqlAutomaticParser::MultiplicativeExpressionWithLeadingSignButNoSpaceContext*
SparqlAutomaticParser::MultiplicativeExpressionWithSignContext::
    multiplicativeExpressionWithLeadingSignButNoSpace() {
  return getRuleContext<
      SparqlAutomaticParser::
          MultiplicativeExpressionWithLeadingSignButNoSpaceContext>(0);
}

size_t
SparqlAutomaticParser::MultiplicativeExpressionWithSignContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleMultiplicativeExpressionWithSign;
}

void SparqlAutomaticParser::MultiplicativeExpressionWithSignContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplicativeExpressionWithSign(this);
}

void SparqlAutomaticParser::MultiplicativeExpressionWithSignContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplicativeExpressionWithSign(this);
}

std::any SparqlAutomaticParser::MultiplicativeExpressionWithSignContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitMultiplicativeExpressionWithSign(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::MultiplicativeExpressionWithSignContext*
SparqlAutomaticParser::multiplicativeExpressionWithSign() {
  MultiplicativeExpressionWithSignContext* _localctx =
      _tracker.createInstance<MultiplicativeExpressionWithSignContext>(
          _ctx, getState());
  enterRule(_localctx, 248,
            SparqlAutomaticParser::RuleMultiplicativeExpressionWithSign);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1193);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__12: {
        enterOuterAlt(_localctx, 1);
        setState(1188);
        match(SparqlAutomaticParser::T__12);
        setState(1189);
        plusSubexpression();
        break;
      }

      case SparqlAutomaticParser::T__25: {
        enterOuterAlt(_localctx, 2);
        setState(1190);
        match(SparqlAutomaticParser::T__25);
        setState(1191);
        minusSubexpression();
        break;
      }

      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE:
      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE: {
        enterOuterAlt(_localctx, 3);
        setState(1192);
        multiplicativeExpressionWithLeadingSignButNoSpace();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PlusSubexpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::PlusSubexpressionContext::PlusSubexpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::MultiplicativeExpressionContext*
SparqlAutomaticParser::PlusSubexpressionContext::multiplicativeExpression() {
  return getRuleContext<SparqlAutomaticParser::MultiplicativeExpressionContext>(
      0);
}

size_t SparqlAutomaticParser::PlusSubexpressionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePlusSubexpression;
}

void SparqlAutomaticParser::PlusSubexpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPlusSubexpression(this);
}

void SparqlAutomaticParser::PlusSubexpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPlusSubexpression(this);
}

std::any SparqlAutomaticParser::PlusSubexpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPlusSubexpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PlusSubexpressionContext*
SparqlAutomaticParser::plusSubexpression() {
  PlusSubexpressionContext* _localctx =
      _tracker.createInstance<PlusSubexpressionContext>(_ctx, getState());
  enterRule(_localctx, 250, SparqlAutomaticParser::RulePlusSubexpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1195);
    multiplicativeExpression();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MinusSubexpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::MinusSubexpressionContext::MinusSubexpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::MultiplicativeExpressionContext*
SparqlAutomaticParser::MinusSubexpressionContext::multiplicativeExpression() {
  return getRuleContext<SparqlAutomaticParser::MultiplicativeExpressionContext>(
      0);
}

size_t SparqlAutomaticParser::MinusSubexpressionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleMinusSubexpression;
}

void SparqlAutomaticParser::MinusSubexpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterMinusSubexpression(this);
}

void SparqlAutomaticParser::MinusSubexpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitMinusSubexpression(this);
}

std::any SparqlAutomaticParser::MinusSubexpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitMinusSubexpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::MinusSubexpressionContext*
SparqlAutomaticParser::minusSubexpression() {
  MinusSubexpressionContext* _localctx =
      _tracker.createInstance<MinusSubexpressionContext>(_ctx, getState());
  enterRule(_localctx, 252, SparqlAutomaticParser::RuleMinusSubexpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1197);
    multiplicativeExpression();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiplicativeExpressionWithLeadingSignButNoSpaceContext
//------------------------------------------------------------------

SparqlAutomaticParser::
    MultiplicativeExpressionWithLeadingSignButNoSpaceContext::
        MultiplicativeExpressionWithLeadingSignButNoSpaceContext(
            ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::NumericLiteralPositiveContext* SparqlAutomaticParser::
    MultiplicativeExpressionWithLeadingSignButNoSpaceContext::
        numericLiteralPositive() {
  return getRuleContext<SparqlAutomaticParser::NumericLiteralPositiveContext>(
      0);
}

SparqlAutomaticParser::NumericLiteralNegativeContext* SparqlAutomaticParser::
    MultiplicativeExpressionWithLeadingSignButNoSpaceContext::
        numericLiteralNegative() {
  return getRuleContext<SparqlAutomaticParser::NumericLiteralNegativeContext>(
      0);
}

std::vector<SparqlAutomaticParser::MultiplyOrDivideExpressionContext*>
SparqlAutomaticParser::
    MultiplicativeExpressionWithLeadingSignButNoSpaceContext::
        multiplyOrDivideExpression() {
  return getRuleContexts<
      SparqlAutomaticParser::MultiplyOrDivideExpressionContext>();
}

SparqlAutomaticParser::MultiplyOrDivideExpressionContext*
SparqlAutomaticParser::
    MultiplicativeExpressionWithLeadingSignButNoSpaceContext::
        multiplyOrDivideExpression(size_t i) {
  return getRuleContext<
      SparqlAutomaticParser::MultiplyOrDivideExpressionContext>(i);
}

size_t SparqlAutomaticParser::
    MultiplicativeExpressionWithLeadingSignButNoSpaceContext::getRuleIndex()
        const {
  return SparqlAutomaticParser::
      RuleMultiplicativeExpressionWithLeadingSignButNoSpace;
}

void SparqlAutomaticParser::
    MultiplicativeExpressionWithLeadingSignButNoSpaceContext::enterRule(
        tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplicativeExpressionWithLeadingSignButNoSpace(
        this);
}

void SparqlAutomaticParser::
    MultiplicativeExpressionWithLeadingSignButNoSpaceContext::exitRule(
        tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplicativeExpressionWithLeadingSignButNoSpace(this);
}

std::any SparqlAutomaticParser::
    MultiplicativeExpressionWithLeadingSignButNoSpaceContext::accept(
        tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor
        ->visitMultiplicativeExpressionWithLeadingSignButNoSpace(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::MultiplicativeExpressionWithLeadingSignButNoSpaceContext*
SparqlAutomaticParser::multiplicativeExpressionWithLeadingSignButNoSpace() {
  MultiplicativeExpressionWithLeadingSignButNoSpaceContext* _localctx =
      _tracker.createInstance<
          MultiplicativeExpressionWithLeadingSignButNoSpaceContext>(_ctx,
                                                                    getState());
  enterRule(_localctx, 254,
            SparqlAutomaticParser::
                RuleMultiplicativeExpressionWithLeadingSignButNoSpace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1201);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE: {
        setState(1199);
        numericLiteralPositive();
        break;
      }

      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE: {
        setState(1200);
        numericLiteralNegative();
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(1206);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__0

           || _la == SparqlAutomaticParser::T__10) {
      setState(1203);
      multiplyOrDivideExpression();
      setState(1208);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiplicativeExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::MultiplicativeExpressionContext::
    MultiplicativeExpressionContext(ParserRuleContext* parent,
                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::UnaryExpressionContext*
SparqlAutomaticParser::MultiplicativeExpressionContext::unaryExpression() {
  return getRuleContext<SparqlAutomaticParser::UnaryExpressionContext>(0);
}

std::vector<SparqlAutomaticParser::MultiplyOrDivideExpressionContext*>
SparqlAutomaticParser::MultiplicativeExpressionContext::
    multiplyOrDivideExpression() {
  return getRuleContexts<
      SparqlAutomaticParser::MultiplyOrDivideExpressionContext>();
}

SparqlAutomaticParser::MultiplyOrDivideExpressionContext*
SparqlAutomaticParser::MultiplicativeExpressionContext::
    multiplyOrDivideExpression(size_t i) {
  return getRuleContext<
      SparqlAutomaticParser::MultiplyOrDivideExpressionContext>(i);
}

size_t SparqlAutomaticParser::MultiplicativeExpressionContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleMultiplicativeExpression;
}

void SparqlAutomaticParser::MultiplicativeExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplicativeExpression(this);
}

void SparqlAutomaticParser::MultiplicativeExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplicativeExpression(this);
}

std::any SparqlAutomaticParser::MultiplicativeExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitMultiplicativeExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::MultiplicativeExpressionContext*
SparqlAutomaticParser::multiplicativeExpression() {
  MultiplicativeExpressionContext* _localctx =
      _tracker.createInstance<MultiplicativeExpressionContext>(_ctx,
                                                               getState());
  enterRule(_localctx, 256,
            SparqlAutomaticParser::RuleMultiplicativeExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1209);
    unaryExpression();
    setState(1213);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SparqlAutomaticParser::T__0

           || _la == SparqlAutomaticParser::T__10) {
      setState(1210);
      multiplyOrDivideExpression();
      setState(1215);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiplyOrDivideExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::MultiplyOrDivideExpressionContext::
    MultiplyOrDivideExpressionContext(ParserRuleContext* parent,
                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::MultiplyExpressionContext*
SparqlAutomaticParser::MultiplyOrDivideExpressionContext::multiplyExpression() {
  return getRuleContext<SparqlAutomaticParser::MultiplyExpressionContext>(0);
}

SparqlAutomaticParser::DivideExpressionContext*
SparqlAutomaticParser::MultiplyOrDivideExpressionContext::divideExpression() {
  return getRuleContext<SparqlAutomaticParser::DivideExpressionContext>(0);
}

size_t SparqlAutomaticParser::MultiplyOrDivideExpressionContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleMultiplyOrDivideExpression;
}

void SparqlAutomaticParser::MultiplyOrDivideExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplyOrDivideExpression(this);
}

void SparqlAutomaticParser::MultiplyOrDivideExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplyOrDivideExpression(this);
}

std::any SparqlAutomaticParser::MultiplyOrDivideExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitMultiplyOrDivideExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::MultiplyOrDivideExpressionContext*
SparqlAutomaticParser::multiplyOrDivideExpression() {
  MultiplyOrDivideExpressionContext* _localctx =
      _tracker.createInstance<MultiplyOrDivideExpressionContext>(_ctx,
                                                                 getState());
  enterRule(_localctx, 258,
            SparqlAutomaticParser::RuleMultiplyOrDivideExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1218);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__0: {
        enterOuterAlt(_localctx, 1);
        setState(1216);
        multiplyExpression();
        break;
      }

      case SparqlAutomaticParser::T__10: {
        enterOuterAlt(_localctx, 2);
        setState(1217);
        divideExpression();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiplyExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::MultiplyExpressionContext::MultiplyExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::UnaryExpressionContext*
SparqlAutomaticParser::MultiplyExpressionContext::unaryExpression() {
  return getRuleContext<SparqlAutomaticParser::UnaryExpressionContext>(0);
}

size_t SparqlAutomaticParser::MultiplyExpressionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleMultiplyExpression;
}

void SparqlAutomaticParser::MultiplyExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterMultiplyExpression(this);
}

void SparqlAutomaticParser::MultiplyExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitMultiplyExpression(this);
}

std::any SparqlAutomaticParser::MultiplyExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitMultiplyExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::MultiplyExpressionContext*
SparqlAutomaticParser::multiplyExpression() {
  MultiplyExpressionContext* _localctx =
      _tracker.createInstance<MultiplyExpressionContext>(_ctx, getState());
  enterRule(_localctx, 260, SparqlAutomaticParser::RuleMultiplyExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1220);
    match(SparqlAutomaticParser::T__0);
    setState(1221);
    unaryExpression();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DivideExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::DivideExpressionContext::DivideExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::UnaryExpressionContext*
SparqlAutomaticParser::DivideExpressionContext::unaryExpression() {
  return getRuleContext<SparqlAutomaticParser::UnaryExpressionContext>(0);
}

size_t SparqlAutomaticParser::DivideExpressionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleDivideExpression;
}

void SparqlAutomaticParser::DivideExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDivideExpression(this);
}

void SparqlAutomaticParser::DivideExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDivideExpression(this);
}

std::any SparqlAutomaticParser::DivideExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitDivideExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::DivideExpressionContext*
SparqlAutomaticParser::divideExpression() {
  DivideExpressionContext* _localctx =
      _tracker.createInstance<DivideExpressionContext>(_ctx, getState());
  enterRule(_localctx, 262, SparqlAutomaticParser::RuleDivideExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1223);
    match(SparqlAutomaticParser::T__10);
    setState(1224);
    unaryExpression();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::UnaryExpressionContext::UnaryExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::PrimaryExpressionContext*
SparqlAutomaticParser::UnaryExpressionContext::primaryExpression() {
  return getRuleContext<SparqlAutomaticParser::PrimaryExpressionContext>(0);
}

size_t SparqlAutomaticParser::UnaryExpressionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleUnaryExpression;
}

void SparqlAutomaticParser::UnaryExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterUnaryExpression(this);
}

void SparqlAutomaticParser::UnaryExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitUnaryExpression(this);
}

std::any SparqlAutomaticParser::UnaryExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitUnaryExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::UnaryExpressionContext*
SparqlAutomaticParser::unaryExpression() {
  UnaryExpressionContext* _localctx =
      _tracker.createInstance<UnaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 264, SparqlAutomaticParser::RuleUnaryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1233);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__14: {
        enterOuterAlt(_localctx, 1);
        setState(1226);
        match(SparqlAutomaticParser::T__14);
        setState(1227);
        primaryExpression();
        break;
      }

      case SparqlAutomaticParser::T__12: {
        enterOuterAlt(_localctx, 2);
        setState(1228);
        match(SparqlAutomaticParser::T__12);
        setState(1229);
        primaryExpression();
        break;
      }

      case SparqlAutomaticParser::T__25: {
        enterOuterAlt(_localctx, 3);
        setState(1230);
        match(SparqlAutomaticParser::T__25);
        setState(1231);
        primaryExpression();
        break;
      }

      case SparqlAutomaticParser::T__1:
      case SparqlAutomaticParser::T__27:
      case SparqlAutomaticParser::T__28:
      case SparqlAutomaticParser::GROUP_CONCAT:
      case SparqlAutomaticParser::NOT:
      case SparqlAutomaticParser::STR:
      case SparqlAutomaticParser::LANG:
      case SparqlAutomaticParser::LANGMATCHES:
      case SparqlAutomaticParser::DATATYPE:
      case SparqlAutomaticParser::BOUND:
      case SparqlAutomaticParser::IRI:
      case SparqlAutomaticParser::URI:
      case SparqlAutomaticParser::BNODE:
      case SparqlAutomaticParser::RAND:
      case SparqlAutomaticParser::ABS:
      case SparqlAutomaticParser::CEIL:
      case SparqlAutomaticParser::FLOOR:
      case SparqlAutomaticParser::ROUND:
      case SparqlAutomaticParser::CONCAT:
      case SparqlAutomaticParser::STRLEN:
      case SparqlAutomaticParser::UCASE:
      case SparqlAutomaticParser::LCASE:
      case SparqlAutomaticParser::ENCODE_FOR_URI:
      case SparqlAutomaticParser::CONTAINS:
      case SparqlAutomaticParser::STRSTARTS:
      case SparqlAutomaticParser::STRENDS:
      case SparqlAutomaticParser::STRBEFORE:
      case SparqlAutomaticParser::STRAFTER:
      case SparqlAutomaticParser::YEAR:
      case SparqlAutomaticParser::MONTH:
      case SparqlAutomaticParser::DAY:
      case SparqlAutomaticParser::HOURS:
      case SparqlAutomaticParser::MINUTES:
      case SparqlAutomaticParser::SECONDS:
      case SparqlAutomaticParser::TIMEZONE:
      case SparqlAutomaticParser::TZ:
      case SparqlAutomaticParser::NOW:
      case SparqlAutomaticParser::UUID:
      case SparqlAutomaticParser::STRUUID:
      case SparqlAutomaticParser::SHA1:
      case SparqlAutomaticParser::SHA256:
      case SparqlAutomaticParser::SHA384:
      case SparqlAutomaticParser::SHA512:
      case SparqlAutomaticParser::MD5:
      case SparqlAutomaticParser::COALESCE:
      case SparqlAutomaticParser::IF:
      case SparqlAutomaticParser::STRLANG:
      case SparqlAutomaticParser::STRDT:
      case SparqlAutomaticParser::SAMETERM:
      case SparqlAutomaticParser::ISIRI:
      case SparqlAutomaticParser::ISURI:
      case SparqlAutomaticParser::ISBLANK:
      case SparqlAutomaticParser::ISLITERAL:
      case SparqlAutomaticParser::ISNUMERIC:
      case SparqlAutomaticParser::REGEX:
      case SparqlAutomaticParser::SUBSTR:
      case SparqlAutomaticParser::REPLACE:
      case SparqlAutomaticParser::EXISTS:
      case SparqlAutomaticParser::COUNT:
      case SparqlAutomaticParser::SUM:
      case SparqlAutomaticParser::MIN:
      case SparqlAutomaticParser::MAX:
      case SparqlAutomaticParser::AVG:
      case SparqlAutomaticParser::STDEV:
      case SparqlAutomaticParser::SAMPLE:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2:
      case SparqlAutomaticParser::PREFIX_LANGTAG:
      case SparqlAutomaticParser::INTEGER:
      case SparqlAutomaticParser::DECIMAL:
      case SparqlAutomaticParser::DOUBLE:
      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE:
      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE:
      case SparqlAutomaticParser::STRING_LITERAL1:
      case SparqlAutomaticParser::STRING_LITERAL2:
      case SparqlAutomaticParser::STRING_LITERAL_LONG1:
      case SparqlAutomaticParser::STRING_LITERAL_LONG2: {
        enterOuterAlt(_localctx, 4);
        setState(1232);
        primaryExpression();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::PrimaryExpressionContext::PrimaryExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::BrackettedExpressionContext*
SparqlAutomaticParser::PrimaryExpressionContext::brackettedExpression() {
  return getRuleContext<SparqlAutomaticParser::BrackettedExpressionContext>(0);
}

SparqlAutomaticParser::BuiltInCallContext*
SparqlAutomaticParser::PrimaryExpressionContext::builtInCall() {
  return getRuleContext<SparqlAutomaticParser::BuiltInCallContext>(0);
}

SparqlAutomaticParser::IriOrFunctionContext*
SparqlAutomaticParser::PrimaryExpressionContext::iriOrFunction() {
  return getRuleContext<SparqlAutomaticParser::IriOrFunctionContext>(0);
}

SparqlAutomaticParser::RdfLiteralContext*
SparqlAutomaticParser::PrimaryExpressionContext::rdfLiteral() {
  return getRuleContext<SparqlAutomaticParser::RdfLiteralContext>(0);
}

SparqlAutomaticParser::NumericLiteralContext*
SparqlAutomaticParser::PrimaryExpressionContext::numericLiteral() {
  return getRuleContext<SparqlAutomaticParser::NumericLiteralContext>(0);
}

SparqlAutomaticParser::BooleanLiteralContext*
SparqlAutomaticParser::PrimaryExpressionContext::booleanLiteral() {
  return getRuleContext<SparqlAutomaticParser::BooleanLiteralContext>(0);
}

SparqlAutomaticParser::VarContext*
SparqlAutomaticParser::PrimaryExpressionContext::var() {
  return getRuleContext<SparqlAutomaticParser::VarContext>(0);
}

size_t SparqlAutomaticParser::PrimaryExpressionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePrimaryExpression;
}

void SparqlAutomaticParser::PrimaryExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPrimaryExpression(this);
}

void SparqlAutomaticParser::PrimaryExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPrimaryExpression(this);
}

std::any SparqlAutomaticParser::PrimaryExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPrimaryExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PrimaryExpressionContext*
SparqlAutomaticParser::primaryExpression() {
  PrimaryExpressionContext* _localctx =
      _tracker.createInstance<PrimaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 266, SparqlAutomaticParser::RulePrimaryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1242);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::T__1: {
        enterOuterAlt(_localctx, 1);
        setState(1235);
        brackettedExpression();
        break;
      }

      case SparqlAutomaticParser::GROUP_CONCAT:
      case SparqlAutomaticParser::NOT:
      case SparqlAutomaticParser::STR:
      case SparqlAutomaticParser::LANG:
      case SparqlAutomaticParser::LANGMATCHES:
      case SparqlAutomaticParser::DATATYPE:
      case SparqlAutomaticParser::BOUND:
      case SparqlAutomaticParser::IRI:
      case SparqlAutomaticParser::URI:
      case SparqlAutomaticParser::BNODE:
      case SparqlAutomaticParser::RAND:
      case SparqlAutomaticParser::ABS:
      case SparqlAutomaticParser::CEIL:
      case SparqlAutomaticParser::FLOOR:
      case SparqlAutomaticParser::ROUND:
      case SparqlAutomaticParser::CONCAT:
      case SparqlAutomaticParser::STRLEN:
      case SparqlAutomaticParser::UCASE:
      case SparqlAutomaticParser::LCASE:
      case SparqlAutomaticParser::ENCODE_FOR_URI:
      case SparqlAutomaticParser::CONTAINS:
      case SparqlAutomaticParser::STRSTARTS:
      case SparqlAutomaticParser::STRENDS:
      case SparqlAutomaticParser::STRBEFORE:
      case SparqlAutomaticParser::STRAFTER:
      case SparqlAutomaticParser::YEAR:
      case SparqlAutomaticParser::MONTH:
      case SparqlAutomaticParser::DAY:
      case SparqlAutomaticParser::HOURS:
      case SparqlAutomaticParser::MINUTES:
      case SparqlAutomaticParser::SECONDS:
      case SparqlAutomaticParser::TIMEZONE:
      case SparqlAutomaticParser::TZ:
      case SparqlAutomaticParser::NOW:
      case SparqlAutomaticParser::UUID:
      case SparqlAutomaticParser::STRUUID:
      case SparqlAutomaticParser::SHA1:
      case SparqlAutomaticParser::SHA256:
      case SparqlAutomaticParser::SHA384:
      case SparqlAutomaticParser::SHA512:
      case SparqlAutomaticParser::MD5:
      case SparqlAutomaticParser::COALESCE:
      case SparqlAutomaticParser::IF:
      case SparqlAutomaticParser::STRLANG:
      case SparqlAutomaticParser::STRDT:
      case SparqlAutomaticParser::SAMETERM:
      case SparqlAutomaticParser::ISIRI:
      case SparqlAutomaticParser::ISURI:
      case SparqlAutomaticParser::ISBLANK:
      case SparqlAutomaticParser::ISLITERAL:
      case SparqlAutomaticParser::ISNUMERIC:
      case SparqlAutomaticParser::REGEX:
      case SparqlAutomaticParser::SUBSTR:
      case SparqlAutomaticParser::REPLACE:
      case SparqlAutomaticParser::EXISTS:
      case SparqlAutomaticParser::COUNT:
      case SparqlAutomaticParser::SUM:
      case SparqlAutomaticParser::MIN:
      case SparqlAutomaticParser::MAX:
      case SparqlAutomaticParser::AVG:
      case SparqlAutomaticParser::STDEV:
      case SparqlAutomaticParser::SAMPLE: {
        enterOuterAlt(_localctx, 2);
        setState(1236);
        builtInCall();
        break;
      }

      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::PREFIX_LANGTAG: {
        enterOuterAlt(_localctx, 3);
        setState(1237);
        iriOrFunction();
        break;
      }

      case SparqlAutomaticParser::STRING_LITERAL1:
      case SparqlAutomaticParser::STRING_LITERAL2:
      case SparqlAutomaticParser::STRING_LITERAL_LONG1:
      case SparqlAutomaticParser::STRING_LITERAL_LONG2: {
        enterOuterAlt(_localctx, 4);
        setState(1238);
        rdfLiteral();
        break;
      }

      case SparqlAutomaticParser::INTEGER:
      case SparqlAutomaticParser::DECIMAL:
      case SparqlAutomaticParser::DOUBLE:
      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE:
      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE: {
        enterOuterAlt(_localctx, 5);
        setState(1239);
        numericLiteral();
        break;
      }

      case SparqlAutomaticParser::T__27:
      case SparqlAutomaticParser::T__28: {
        enterOuterAlt(_localctx, 6);
        setState(1240);
        booleanLiteral();
        break;
      }

      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2: {
        enterOuterAlt(_localctx, 7);
        setState(1241);
        var();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BrackettedExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::BrackettedExpressionContext::BrackettedExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::ExpressionContext*
SparqlAutomaticParser::BrackettedExpressionContext::expression() {
  return getRuleContext<SparqlAutomaticParser::ExpressionContext>(0);
}

size_t SparqlAutomaticParser::BrackettedExpressionContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleBrackettedExpression;
}

void SparqlAutomaticParser::BrackettedExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterBrackettedExpression(this);
}

void SparqlAutomaticParser::BrackettedExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitBrackettedExpression(this);
}

std::any SparqlAutomaticParser::BrackettedExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitBrackettedExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::BrackettedExpressionContext*
SparqlAutomaticParser::brackettedExpression() {
  BrackettedExpressionContext* _localctx =
      _tracker.createInstance<BrackettedExpressionContext>(_ctx, getState());
  enterRule(_localctx, 268, SparqlAutomaticParser::RuleBrackettedExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1244);
    match(SparqlAutomaticParser::T__1);
    setState(1245);
    expression();
    setState(1246);
    match(SparqlAutomaticParser::T__2);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BuiltInCallContext
//------------------------------------------------------------------

SparqlAutomaticParser::BuiltInCallContext::BuiltInCallContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::AggregateContext*
SparqlAutomaticParser::BuiltInCallContext::aggregate() {
  return getRuleContext<SparqlAutomaticParser::AggregateContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::STR() {
  return getToken(SparqlAutomaticParser::STR, 0);
}

std::vector<SparqlAutomaticParser::ExpressionContext*>
SparqlAutomaticParser::BuiltInCallContext::expression() {
  return getRuleContexts<SparqlAutomaticParser::ExpressionContext>();
}

SparqlAutomaticParser::ExpressionContext*
SparqlAutomaticParser::BuiltInCallContext::expression(size_t i) {
  return getRuleContext<SparqlAutomaticParser::ExpressionContext>(i);
}

SparqlAutomaticParser::LangExpressionContext*
SparqlAutomaticParser::BuiltInCallContext::langExpression() {
  return getRuleContext<SparqlAutomaticParser::LangExpressionContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::LANGMATCHES() {
  return getToken(SparqlAutomaticParser::LANGMATCHES, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::DATATYPE() {
  return getToken(SparqlAutomaticParser::DATATYPE, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::BOUND() {
  return getToken(SparqlAutomaticParser::BOUND, 0);
}

SparqlAutomaticParser::VarContext*
SparqlAutomaticParser::BuiltInCallContext::var() {
  return getRuleContext<SparqlAutomaticParser::VarContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::IRI() {
  return getToken(SparqlAutomaticParser::IRI, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::URI() {
  return getToken(SparqlAutomaticParser::URI, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::BNODE() {
  return getToken(SparqlAutomaticParser::BNODE, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::NIL() {
  return getToken(SparqlAutomaticParser::NIL, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::RAND() {
  return getToken(SparqlAutomaticParser::RAND, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::ABS() {
  return getToken(SparqlAutomaticParser::ABS, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::CEIL() {
  return getToken(SparqlAutomaticParser::CEIL, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::FLOOR() {
  return getToken(SparqlAutomaticParser::FLOOR, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::ROUND() {
  return getToken(SparqlAutomaticParser::ROUND, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::CONCAT() {
  return getToken(SparqlAutomaticParser::CONCAT, 0);
}

SparqlAutomaticParser::ExpressionListContext*
SparqlAutomaticParser::BuiltInCallContext::expressionList() {
  return getRuleContext<SparqlAutomaticParser::ExpressionListContext>(0);
}

SparqlAutomaticParser::SubstringExpressionContext*
SparqlAutomaticParser::BuiltInCallContext::substringExpression() {
  return getRuleContext<SparqlAutomaticParser::SubstringExpressionContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::STRLEN() {
  return getToken(SparqlAutomaticParser::STRLEN, 0);
}

SparqlAutomaticParser::StrReplaceExpressionContext*
SparqlAutomaticParser::BuiltInCallContext::strReplaceExpression() {
  return getRuleContext<SparqlAutomaticParser::StrReplaceExpressionContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::UCASE() {
  return getToken(SparqlAutomaticParser::UCASE, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::LCASE() {
  return getToken(SparqlAutomaticParser::LCASE, 0);
}

tree::TerminalNode*
SparqlAutomaticParser::BuiltInCallContext::ENCODE_FOR_URI() {
  return getToken(SparqlAutomaticParser::ENCODE_FOR_URI, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::CONTAINS() {
  return getToken(SparqlAutomaticParser::CONTAINS, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::STRSTARTS() {
  return getToken(SparqlAutomaticParser::STRSTARTS, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::STRENDS() {
  return getToken(SparqlAutomaticParser::STRENDS, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::STRBEFORE() {
  return getToken(SparqlAutomaticParser::STRBEFORE, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::STRAFTER() {
  return getToken(SparqlAutomaticParser::STRAFTER, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::YEAR() {
  return getToken(SparqlAutomaticParser::YEAR, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::MONTH() {
  return getToken(SparqlAutomaticParser::MONTH, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::DAY() {
  return getToken(SparqlAutomaticParser::DAY, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::HOURS() {
  return getToken(SparqlAutomaticParser::HOURS, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::MINUTES() {
  return getToken(SparqlAutomaticParser::MINUTES, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::SECONDS() {
  return getToken(SparqlAutomaticParser::SECONDS, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::TIMEZONE() {
  return getToken(SparqlAutomaticParser::TIMEZONE, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::TZ() {
  return getToken(SparqlAutomaticParser::TZ, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::NOW() {
  return getToken(SparqlAutomaticParser::NOW, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::UUID() {
  return getToken(SparqlAutomaticParser::UUID, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::STRUUID() {
  return getToken(SparqlAutomaticParser::STRUUID, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::MD5() {
  return getToken(SparqlAutomaticParser::MD5, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::SHA1() {
  return getToken(SparqlAutomaticParser::SHA1, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::SHA256() {
  return getToken(SparqlAutomaticParser::SHA256, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::SHA384() {
  return getToken(SparqlAutomaticParser::SHA384, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::SHA512() {
  return getToken(SparqlAutomaticParser::SHA512, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::COALESCE() {
  return getToken(SparqlAutomaticParser::COALESCE, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::IF() {
  return getToken(SparqlAutomaticParser::IF, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::STRLANG() {
  return getToken(SparqlAutomaticParser::STRLANG, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::STRDT() {
  return getToken(SparqlAutomaticParser::STRDT, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::SAMETERM() {
  return getToken(SparqlAutomaticParser::SAMETERM, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::ISIRI() {
  return getToken(SparqlAutomaticParser::ISIRI, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::ISURI() {
  return getToken(SparqlAutomaticParser::ISURI, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::ISBLANK() {
  return getToken(SparqlAutomaticParser::ISBLANK, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::ISLITERAL() {
  return getToken(SparqlAutomaticParser::ISLITERAL, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BuiltInCallContext::ISNUMERIC() {
  return getToken(SparqlAutomaticParser::ISNUMERIC, 0);
}

SparqlAutomaticParser::RegexExpressionContext*
SparqlAutomaticParser::BuiltInCallContext::regexExpression() {
  return getRuleContext<SparqlAutomaticParser::RegexExpressionContext>(0);
}

SparqlAutomaticParser::ExistsFuncContext*
SparqlAutomaticParser::BuiltInCallContext::existsFunc() {
  return getRuleContext<SparqlAutomaticParser::ExistsFuncContext>(0);
}

SparqlAutomaticParser::NotExistsFuncContext*
SparqlAutomaticParser::BuiltInCallContext::notExistsFunc() {
  return getRuleContext<SparqlAutomaticParser::NotExistsFuncContext>(0);
}

size_t SparqlAutomaticParser::BuiltInCallContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleBuiltInCall;
}

void SparqlAutomaticParser::BuiltInCallContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterBuiltInCall(this);
}

void SparqlAutomaticParser::BuiltInCallContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitBuiltInCall(this);
}

std::any SparqlAutomaticParser::BuiltInCallContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitBuiltInCall(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::BuiltInCallContext*
SparqlAutomaticParser::builtInCall() {
  BuiltInCallContext* _localctx =
      _tracker.createInstance<BuiltInCallContext>(_ctx, getState());
  enterRule(_localctx, 270, SparqlAutomaticParser::RuleBuiltInCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1502);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::GROUP_CONCAT:
      case SparqlAutomaticParser::COUNT:
      case SparqlAutomaticParser::SUM:
      case SparqlAutomaticParser::MIN:
      case SparqlAutomaticParser::MAX:
      case SparqlAutomaticParser::AVG:
      case SparqlAutomaticParser::STDEV:
      case SparqlAutomaticParser::SAMPLE: {
        enterOuterAlt(_localctx, 1);
        setState(1248);
        aggregate();
        break;
      }

      case SparqlAutomaticParser::STR: {
        enterOuterAlt(_localctx, 2);
        setState(1249);
        match(SparqlAutomaticParser::STR);
        setState(1250);
        match(SparqlAutomaticParser::T__1);
        setState(1251);
        expression();
        setState(1252);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::LANG: {
        enterOuterAlt(_localctx, 3);
        setState(1254);
        langExpression();
        break;
      }

      case SparqlAutomaticParser::LANGMATCHES: {
        enterOuterAlt(_localctx, 4);
        setState(1255);
        match(SparqlAutomaticParser::LANGMATCHES);
        setState(1256);
        match(SparqlAutomaticParser::T__1);
        setState(1257);
        expression();
        setState(1258);
        match(SparqlAutomaticParser::T__7);
        setState(1259);
        expression();
        setState(1260);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::DATATYPE: {
        enterOuterAlt(_localctx, 5);
        setState(1262);
        match(SparqlAutomaticParser::DATATYPE);
        setState(1263);
        match(SparqlAutomaticParser::T__1);
        setState(1264);
        expression();
        setState(1265);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::BOUND: {
        enterOuterAlt(_localctx, 6);
        setState(1267);
        match(SparqlAutomaticParser::BOUND);
        setState(1268);
        match(SparqlAutomaticParser::T__1);
        setState(1269);
        var();
        setState(1270);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::IRI: {
        enterOuterAlt(_localctx, 7);
        setState(1272);
        match(SparqlAutomaticParser::IRI);
        setState(1273);
        match(SparqlAutomaticParser::T__1);
        setState(1274);
        expression();
        setState(1275);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::URI: {
        enterOuterAlt(_localctx, 8);
        setState(1277);
        match(SparqlAutomaticParser::URI);
        setState(1278);
        match(SparqlAutomaticParser::T__1);
        setState(1279);
        expression();
        setState(1280);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::BNODE: {
        enterOuterAlt(_localctx, 9);
        setState(1282);
        match(SparqlAutomaticParser::BNODE);
        setState(1288);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SparqlAutomaticParser::T__1: {
            setState(1283);
            match(SparqlAutomaticParser::T__1);
            setState(1284);
            expression();
            setState(1285);
            match(SparqlAutomaticParser::T__2);
            break;
          }

          case SparqlAutomaticParser::NIL: {
            setState(1287);
            match(SparqlAutomaticParser::NIL);
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      case SparqlAutomaticParser::RAND: {
        enterOuterAlt(_localctx, 10);
        setState(1290);
        match(SparqlAutomaticParser::RAND);
        setState(1291);
        match(SparqlAutomaticParser::NIL);
        break;
      }

      case SparqlAutomaticParser::ABS: {
        enterOuterAlt(_localctx, 11);
        setState(1292);
        match(SparqlAutomaticParser::ABS);
        setState(1293);
        match(SparqlAutomaticParser::T__1);
        setState(1294);
        expression();
        setState(1295);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::CEIL: {
        enterOuterAlt(_localctx, 12);
        setState(1297);
        match(SparqlAutomaticParser::CEIL);
        setState(1298);
        match(SparqlAutomaticParser::T__1);
        setState(1299);
        expression();
        setState(1300);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::FLOOR: {
        enterOuterAlt(_localctx, 13);
        setState(1302);
        match(SparqlAutomaticParser::FLOOR);
        setState(1303);
        match(SparqlAutomaticParser::T__1);
        setState(1304);
        expression();
        setState(1305);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::ROUND: {
        enterOuterAlt(_localctx, 14);
        setState(1307);
        match(SparqlAutomaticParser::ROUND);
        setState(1308);
        match(SparqlAutomaticParser::T__1);
        setState(1309);
        expression();
        setState(1310);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::CONCAT: {
        enterOuterAlt(_localctx, 15);
        setState(1312);
        match(SparqlAutomaticParser::CONCAT);
        setState(1313);
        expressionList();
        break;
      }

      case SparqlAutomaticParser::SUBSTR: {
        enterOuterAlt(_localctx, 16);
        setState(1314);
        substringExpression();
        break;
      }

      case SparqlAutomaticParser::STRLEN: {
        enterOuterAlt(_localctx, 17);
        setState(1315);
        match(SparqlAutomaticParser::STRLEN);
        setState(1316);
        match(SparqlAutomaticParser::T__1);
        setState(1317);
        expression();
        setState(1318);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::REPLACE: {
        enterOuterAlt(_localctx, 18);
        setState(1320);
        strReplaceExpression();
        break;
      }

      case SparqlAutomaticParser::UCASE: {
        enterOuterAlt(_localctx, 19);
        setState(1321);
        match(SparqlAutomaticParser::UCASE);
        setState(1322);
        match(SparqlAutomaticParser::T__1);
        setState(1323);
        expression();
        setState(1324);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::LCASE: {
        enterOuterAlt(_localctx, 20);
        setState(1326);
        match(SparqlAutomaticParser::LCASE);
        setState(1327);
        match(SparqlAutomaticParser::T__1);
        setState(1328);
        expression();
        setState(1329);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::ENCODE_FOR_URI: {
        enterOuterAlt(_localctx, 21);
        setState(1331);
        match(SparqlAutomaticParser::ENCODE_FOR_URI);
        setState(1332);
        match(SparqlAutomaticParser::T__1);
        setState(1333);
        expression();
        setState(1334);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::CONTAINS: {
        enterOuterAlt(_localctx, 22);
        setState(1336);
        match(SparqlAutomaticParser::CONTAINS);
        setState(1337);
        match(SparqlAutomaticParser::T__1);
        setState(1338);
        expression();
        setState(1339);
        match(SparqlAutomaticParser::T__7);
        setState(1340);
        expression();
        setState(1341);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::STRSTARTS: {
        enterOuterAlt(_localctx, 23);
        setState(1343);
        match(SparqlAutomaticParser::STRSTARTS);
        setState(1344);
        match(SparqlAutomaticParser::T__1);
        setState(1345);
        expression();
        setState(1346);
        match(SparqlAutomaticParser::T__7);
        setState(1347);
        expression();
        setState(1348);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::STRENDS: {
        enterOuterAlt(_localctx, 24);
        setState(1350);
        match(SparqlAutomaticParser::STRENDS);
        setState(1351);
        match(SparqlAutomaticParser::T__1);
        setState(1352);
        expression();
        setState(1353);
        match(SparqlAutomaticParser::T__7);
        setState(1354);
        expression();
        setState(1355);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::STRBEFORE: {
        enterOuterAlt(_localctx, 25);
        setState(1357);
        match(SparqlAutomaticParser::STRBEFORE);
        setState(1358);
        match(SparqlAutomaticParser::T__1);
        setState(1359);
        expression();
        setState(1360);
        match(SparqlAutomaticParser::T__7);
        setState(1361);
        expression();
        setState(1362);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::STRAFTER: {
        enterOuterAlt(_localctx, 26);
        setState(1364);
        match(SparqlAutomaticParser::STRAFTER);
        setState(1365);
        match(SparqlAutomaticParser::T__1);
        setState(1366);
        expression();
        setState(1367);
        match(SparqlAutomaticParser::T__7);
        setState(1368);
        expression();
        setState(1369);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::YEAR: {
        enterOuterAlt(_localctx, 27);
        setState(1371);
        match(SparqlAutomaticParser::YEAR);
        setState(1372);
        match(SparqlAutomaticParser::T__1);
        setState(1373);
        expression();
        setState(1374);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::MONTH: {
        enterOuterAlt(_localctx, 28);
        setState(1376);
        match(SparqlAutomaticParser::MONTH);
        setState(1377);
        match(SparqlAutomaticParser::T__1);
        setState(1378);
        expression();
        setState(1379);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::DAY: {
        enterOuterAlt(_localctx, 29);
        setState(1381);
        match(SparqlAutomaticParser::DAY);
        setState(1382);
        match(SparqlAutomaticParser::T__1);
        setState(1383);
        expression();
        setState(1384);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::HOURS: {
        enterOuterAlt(_localctx, 30);
        setState(1386);
        match(SparqlAutomaticParser::HOURS);
        setState(1387);
        match(SparqlAutomaticParser::T__1);
        setState(1388);
        expression();
        setState(1389);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::MINUTES: {
        enterOuterAlt(_localctx, 31);
        setState(1391);
        match(SparqlAutomaticParser::MINUTES);
        setState(1392);
        match(SparqlAutomaticParser::T__1);
        setState(1393);
        expression();
        setState(1394);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::SECONDS: {
        enterOuterAlt(_localctx, 32);
        setState(1396);
        match(SparqlAutomaticParser::SECONDS);
        setState(1397);
        match(SparqlAutomaticParser::T__1);
        setState(1398);
        expression();
        setState(1399);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::TIMEZONE: {
        enterOuterAlt(_localctx, 33);
        setState(1401);
        match(SparqlAutomaticParser::TIMEZONE);
        setState(1402);
        match(SparqlAutomaticParser::T__1);
        setState(1403);
        expression();
        setState(1404);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::TZ: {
        enterOuterAlt(_localctx, 34);
        setState(1406);
        match(SparqlAutomaticParser::TZ);
        setState(1407);
        match(SparqlAutomaticParser::T__1);
        setState(1408);
        expression();
        setState(1409);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::NOW: {
        enterOuterAlt(_localctx, 35);
        setState(1411);
        match(SparqlAutomaticParser::NOW);
        setState(1412);
        match(SparqlAutomaticParser::NIL);
        break;
      }

      case SparqlAutomaticParser::UUID: {
        enterOuterAlt(_localctx, 36);
        setState(1413);
        match(SparqlAutomaticParser::UUID);
        setState(1414);
        match(SparqlAutomaticParser::NIL);
        break;
      }

      case SparqlAutomaticParser::STRUUID: {
        enterOuterAlt(_localctx, 37);
        setState(1415);
        match(SparqlAutomaticParser::STRUUID);
        setState(1416);
        match(SparqlAutomaticParser::NIL);
        break;
      }

      case SparqlAutomaticParser::MD5: {
        enterOuterAlt(_localctx, 38);
        setState(1417);
        match(SparqlAutomaticParser::MD5);
        setState(1418);
        match(SparqlAutomaticParser::T__1);
        setState(1419);
        expression();
        setState(1420);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::SHA1: {
        enterOuterAlt(_localctx, 39);
        setState(1422);
        match(SparqlAutomaticParser::SHA1);
        setState(1423);
        match(SparqlAutomaticParser::T__1);
        setState(1424);
        expression();
        setState(1425);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::SHA256: {
        enterOuterAlt(_localctx, 40);
        setState(1427);
        match(SparqlAutomaticParser::SHA256);
        setState(1428);
        match(SparqlAutomaticParser::T__1);
        setState(1429);
        expression();
        setState(1430);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::SHA384: {
        enterOuterAlt(_localctx, 41);
        setState(1432);
        match(SparqlAutomaticParser::SHA384);
        setState(1433);
        match(SparqlAutomaticParser::T__1);
        setState(1434);
        expression();
        setState(1435);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::SHA512: {
        enterOuterAlt(_localctx, 42);
        setState(1437);
        match(SparqlAutomaticParser::SHA512);
        setState(1438);
        match(SparqlAutomaticParser::T__1);
        setState(1439);
        expression();
        setState(1440);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::COALESCE: {
        enterOuterAlt(_localctx, 43);
        setState(1442);
        match(SparqlAutomaticParser::COALESCE);
        setState(1443);
        expressionList();
        break;
      }

      case SparqlAutomaticParser::IF: {
        enterOuterAlt(_localctx, 44);
        setState(1444);
        match(SparqlAutomaticParser::IF);
        setState(1445);
        match(SparqlAutomaticParser::T__1);
        setState(1446);
        expression();
        setState(1447);
        match(SparqlAutomaticParser::T__7);
        setState(1448);
        expression();
        setState(1449);
        match(SparqlAutomaticParser::T__7);
        setState(1450);
        expression();
        setState(1451);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::STRLANG: {
        enterOuterAlt(_localctx, 45);
        setState(1453);
        match(SparqlAutomaticParser::STRLANG);
        setState(1454);
        match(SparqlAutomaticParser::T__1);
        setState(1455);
        expression();
        setState(1456);
        match(SparqlAutomaticParser::T__7);
        setState(1457);
        expression();
        setState(1458);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::STRDT: {
        enterOuterAlt(_localctx, 46);
        setState(1460);
        match(SparqlAutomaticParser::STRDT);
        setState(1461);
        match(SparqlAutomaticParser::T__1);
        setState(1462);
        expression();
        setState(1463);
        match(SparqlAutomaticParser::T__7);
        setState(1464);
        expression();
        setState(1465);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::SAMETERM: {
        enterOuterAlt(_localctx, 47);
        setState(1467);
        match(SparqlAutomaticParser::SAMETERM);
        setState(1468);
        match(SparqlAutomaticParser::T__1);
        setState(1469);
        expression();
        setState(1470);
        match(SparqlAutomaticParser::T__7);
        setState(1471);
        expression();
        setState(1472);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::ISIRI: {
        enterOuterAlt(_localctx, 48);
        setState(1474);
        match(SparqlAutomaticParser::ISIRI);
        setState(1475);
        match(SparqlAutomaticParser::T__1);
        setState(1476);
        expression();
        setState(1477);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::ISURI: {
        enterOuterAlt(_localctx, 49);
        setState(1479);
        match(SparqlAutomaticParser::ISURI);
        setState(1480);
        match(SparqlAutomaticParser::T__1);
        setState(1481);
        expression();
        setState(1482);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::ISBLANK: {
        enterOuterAlt(_localctx, 50);
        setState(1484);
        match(SparqlAutomaticParser::ISBLANK);
        setState(1485);
        match(SparqlAutomaticParser::T__1);
        setState(1486);
        expression();
        setState(1487);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::ISLITERAL: {
        enterOuterAlt(_localctx, 51);
        setState(1489);
        match(SparqlAutomaticParser::ISLITERAL);
        setState(1490);
        match(SparqlAutomaticParser::T__1);
        setState(1491);
        expression();
        setState(1492);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::ISNUMERIC: {
        enterOuterAlt(_localctx, 52);
        setState(1494);
        match(SparqlAutomaticParser::ISNUMERIC);
        setState(1495);
        match(SparqlAutomaticParser::T__1);
        setState(1496);
        expression();
        setState(1497);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::REGEX: {
        enterOuterAlt(_localctx, 53);
        setState(1499);
        regexExpression();
        break;
      }

      case SparqlAutomaticParser::EXISTS: {
        enterOuterAlt(_localctx, 54);
        setState(1500);
        existsFunc();
        break;
      }

      case SparqlAutomaticParser::NOT: {
        enterOuterAlt(_localctx, 55);
        setState(1501);
        notExistsFunc();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RegexExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::RegexExpressionContext::RegexExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::RegexExpressionContext::REGEX() {
  return getToken(SparqlAutomaticParser::REGEX, 0);
}

std::vector<SparqlAutomaticParser::ExpressionContext*>
SparqlAutomaticParser::RegexExpressionContext::expression() {
  return getRuleContexts<SparqlAutomaticParser::ExpressionContext>();
}

SparqlAutomaticParser::ExpressionContext*
SparqlAutomaticParser::RegexExpressionContext::expression(size_t i) {
  return getRuleContext<SparqlAutomaticParser::ExpressionContext>(i);
}

size_t SparqlAutomaticParser::RegexExpressionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleRegexExpression;
}

void SparqlAutomaticParser::RegexExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterRegexExpression(this);
}

void SparqlAutomaticParser::RegexExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitRegexExpression(this);
}

std::any SparqlAutomaticParser::RegexExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitRegexExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::RegexExpressionContext*
SparqlAutomaticParser::regexExpression() {
  RegexExpressionContext* _localctx =
      _tracker.createInstance<RegexExpressionContext>(_ctx, getState());
  enterRule(_localctx, 272, SparqlAutomaticParser::RuleRegexExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1504);
    match(SparqlAutomaticParser::REGEX);
    setState(1505);
    match(SparqlAutomaticParser::T__1);
    setState(1506);
    expression();
    setState(1507);
    match(SparqlAutomaticParser::T__7);
    setState(1508);
    expression();
    setState(1511);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::T__7) {
      setState(1509);
      match(SparqlAutomaticParser::T__7);
      setState(1510);
      expression();
    }
    setState(1513);
    match(SparqlAutomaticParser::T__2);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LangExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::LangExpressionContext::LangExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::LangExpressionContext::LANG() {
  return getToken(SparqlAutomaticParser::LANG, 0);
}

SparqlAutomaticParser::ExpressionContext*
SparqlAutomaticParser::LangExpressionContext::expression() {
  return getRuleContext<SparqlAutomaticParser::ExpressionContext>(0);
}

size_t SparqlAutomaticParser::LangExpressionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleLangExpression;
}

void SparqlAutomaticParser::LangExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterLangExpression(this);
}

void SparqlAutomaticParser::LangExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitLangExpression(this);
}

std::any SparqlAutomaticParser::LangExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitLangExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::LangExpressionContext*
SparqlAutomaticParser::langExpression() {
  LangExpressionContext* _localctx =
      _tracker.createInstance<LangExpressionContext>(_ctx, getState());
  enterRule(_localctx, 274, SparqlAutomaticParser::RuleLangExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1515);
    match(SparqlAutomaticParser::LANG);
    setState(1516);
    match(SparqlAutomaticParser::T__1);
    setState(1517);
    expression();
    setState(1518);
    match(SparqlAutomaticParser::T__2);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubstringExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::SubstringExpressionContext::SubstringExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode*
SparqlAutomaticParser::SubstringExpressionContext::SUBSTR() {
  return getToken(SparqlAutomaticParser::SUBSTR, 0);
}

std::vector<SparqlAutomaticParser::ExpressionContext*>
SparqlAutomaticParser::SubstringExpressionContext::expression() {
  return getRuleContexts<SparqlAutomaticParser::ExpressionContext>();
}

SparqlAutomaticParser::ExpressionContext*
SparqlAutomaticParser::SubstringExpressionContext::expression(size_t i) {
  return getRuleContext<SparqlAutomaticParser::ExpressionContext>(i);
}

size_t SparqlAutomaticParser::SubstringExpressionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleSubstringExpression;
}

void SparqlAutomaticParser::SubstringExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterSubstringExpression(this);
}

void SparqlAutomaticParser::SubstringExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitSubstringExpression(this);
}

std::any SparqlAutomaticParser::SubstringExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitSubstringExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::SubstringExpressionContext*
SparqlAutomaticParser::substringExpression() {
  SubstringExpressionContext* _localctx =
      _tracker.createInstance<SubstringExpressionContext>(_ctx, getState());
  enterRule(_localctx, 276, SparqlAutomaticParser::RuleSubstringExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1520);
    match(SparqlAutomaticParser::SUBSTR);
    setState(1521);
    match(SparqlAutomaticParser::T__1);
    setState(1522);
    expression();
    setState(1523);
    match(SparqlAutomaticParser::T__7);
    setState(1524);
    expression();
    setState(1527);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::T__7) {
      setState(1525);
      match(SparqlAutomaticParser::T__7);
      setState(1526);
      expression();
    }
    setState(1529);
    match(SparqlAutomaticParser::T__2);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StrReplaceExpressionContext
//------------------------------------------------------------------

SparqlAutomaticParser::StrReplaceExpressionContext::StrReplaceExpressionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode*
SparqlAutomaticParser::StrReplaceExpressionContext::REPLACE() {
  return getToken(SparqlAutomaticParser::REPLACE, 0);
}

std::vector<SparqlAutomaticParser::ExpressionContext*>
SparqlAutomaticParser::StrReplaceExpressionContext::expression() {
  return getRuleContexts<SparqlAutomaticParser::ExpressionContext>();
}

SparqlAutomaticParser::ExpressionContext*
SparqlAutomaticParser::StrReplaceExpressionContext::expression(size_t i) {
  return getRuleContext<SparqlAutomaticParser::ExpressionContext>(i);
}

size_t SparqlAutomaticParser::StrReplaceExpressionContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleStrReplaceExpression;
}

void SparqlAutomaticParser::StrReplaceExpressionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterStrReplaceExpression(this);
}

void SparqlAutomaticParser::StrReplaceExpressionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitStrReplaceExpression(this);
}

std::any SparqlAutomaticParser::StrReplaceExpressionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitStrReplaceExpression(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::StrReplaceExpressionContext*
SparqlAutomaticParser::strReplaceExpression() {
  StrReplaceExpressionContext* _localctx =
      _tracker.createInstance<StrReplaceExpressionContext>(_ctx, getState());
  enterRule(_localctx, 278, SparqlAutomaticParser::RuleStrReplaceExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1531);
    match(SparqlAutomaticParser::REPLACE);
    setState(1532);
    match(SparqlAutomaticParser::T__1);
    setState(1533);
    expression();
    setState(1534);
    match(SparqlAutomaticParser::T__7);
    setState(1535);
    expression();
    setState(1536);
    match(SparqlAutomaticParser::T__7);
    setState(1537);
    expression();
    setState(1540);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::T__7) {
      setState(1538);
      match(SparqlAutomaticParser::T__7);
      setState(1539);
      expression();
    }
    setState(1542);
    match(SparqlAutomaticParser::T__2);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExistsFuncContext
//------------------------------------------------------------------

SparqlAutomaticParser::ExistsFuncContext::ExistsFuncContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::ExistsFuncContext::EXISTS() {
  return getToken(SparqlAutomaticParser::EXISTS, 0);
}

SparqlAutomaticParser::GroupGraphPatternContext*
SparqlAutomaticParser::ExistsFuncContext::groupGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::GroupGraphPatternContext>(0);
}

size_t SparqlAutomaticParser::ExistsFuncContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleExistsFunc;
}

void SparqlAutomaticParser::ExistsFuncContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterExistsFunc(this);
}

void SparqlAutomaticParser::ExistsFuncContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitExistsFunc(this);
}

std::any SparqlAutomaticParser::ExistsFuncContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitExistsFunc(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::ExistsFuncContext* SparqlAutomaticParser::existsFunc() {
  ExistsFuncContext* _localctx =
      _tracker.createInstance<ExistsFuncContext>(_ctx, getState());
  enterRule(_localctx, 280, SparqlAutomaticParser::RuleExistsFunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1544);
    match(SparqlAutomaticParser::EXISTS);
    setState(1545);
    groupGraphPattern();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NotExistsFuncContext
//------------------------------------------------------------------

SparqlAutomaticParser::NotExistsFuncContext::NotExistsFuncContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::NotExistsFuncContext::NOT() {
  return getToken(SparqlAutomaticParser::NOT, 0);
}

tree::TerminalNode* SparqlAutomaticParser::NotExistsFuncContext::EXISTS() {
  return getToken(SparqlAutomaticParser::EXISTS, 0);
}

SparqlAutomaticParser::GroupGraphPatternContext*
SparqlAutomaticParser::NotExistsFuncContext::groupGraphPattern() {
  return getRuleContext<SparqlAutomaticParser::GroupGraphPatternContext>(0);
}

size_t SparqlAutomaticParser::NotExistsFuncContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleNotExistsFunc;
}

void SparqlAutomaticParser::NotExistsFuncContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterNotExistsFunc(this);
}

void SparqlAutomaticParser::NotExistsFuncContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitNotExistsFunc(this);
}

std::any SparqlAutomaticParser::NotExistsFuncContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitNotExistsFunc(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::NotExistsFuncContext*
SparqlAutomaticParser::notExistsFunc() {
  NotExistsFuncContext* _localctx =
      _tracker.createInstance<NotExistsFuncContext>(_ctx, getState());
  enterRule(_localctx, 282, SparqlAutomaticParser::RuleNotExistsFunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1547);
    match(SparqlAutomaticParser::NOT);
    setState(1548);
    match(SparqlAutomaticParser::EXISTS);
    setState(1549);
    groupGraphPattern();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AggregateContext
//------------------------------------------------------------------

SparqlAutomaticParser::AggregateContext::AggregateContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::AggregateContext::COUNT() {
  return getToken(SparqlAutomaticParser::COUNT, 0);
}

SparqlAutomaticParser::ExpressionContext*
SparqlAutomaticParser::AggregateContext::expression() {
  return getRuleContext<SparqlAutomaticParser::ExpressionContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::AggregateContext::DISTINCT() {
  return getToken(SparqlAutomaticParser::DISTINCT, 0);
}

tree::TerminalNode* SparqlAutomaticParser::AggregateContext::SUM() {
  return getToken(SparqlAutomaticParser::SUM, 0);
}

tree::TerminalNode* SparqlAutomaticParser::AggregateContext::MIN() {
  return getToken(SparqlAutomaticParser::MIN, 0);
}

tree::TerminalNode* SparqlAutomaticParser::AggregateContext::MAX() {
  return getToken(SparqlAutomaticParser::MAX, 0);
}

tree::TerminalNode* SparqlAutomaticParser::AggregateContext::AVG() {
  return getToken(SparqlAutomaticParser::AVG, 0);
}

tree::TerminalNode* SparqlAutomaticParser::AggregateContext::STDEV() {
  return getToken(SparqlAutomaticParser::STDEV, 0);
}

tree::TerminalNode* SparqlAutomaticParser::AggregateContext::SAMPLE() {
  return getToken(SparqlAutomaticParser::SAMPLE, 0);
}

tree::TerminalNode* SparqlAutomaticParser::AggregateContext::GROUP_CONCAT() {
  return getToken(SparqlAutomaticParser::GROUP_CONCAT, 0);
}

tree::TerminalNode* SparqlAutomaticParser::AggregateContext::SEPARATOR() {
  return getToken(SparqlAutomaticParser::SEPARATOR, 0);
}

SparqlAutomaticParser::StringContext*
SparqlAutomaticParser::AggregateContext::string() {
  return getRuleContext<SparqlAutomaticParser::StringContext>(0);
}

size_t SparqlAutomaticParser::AggregateContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleAggregate;
}

void SparqlAutomaticParser::AggregateContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterAggregate(this);
}

void SparqlAutomaticParser::AggregateContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitAggregate(this);
}

std::any SparqlAutomaticParser::AggregateContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitAggregate(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::AggregateContext* SparqlAutomaticParser::aggregate() {
  AggregateContext* _localctx =
      _tracker.createInstance<AggregateContext>(_ctx, getState());
  enterRule(_localctx, 284, SparqlAutomaticParser::RuleAggregate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1623);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::COUNT: {
        enterOuterAlt(_localctx, 1);
        setState(1551);
        match(SparqlAutomaticParser::COUNT);
        setState(1552);
        match(SparqlAutomaticParser::T__1);
        setState(1554);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::DISTINCT) {
          setState(1553);
          match(SparqlAutomaticParser::DISTINCT);
        }
        setState(1558);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SparqlAutomaticParser::T__0: {
            setState(1556);
            match(SparqlAutomaticParser::T__0);
            break;
          }

          case SparqlAutomaticParser::T__1:
          case SparqlAutomaticParser::T__12:
          case SparqlAutomaticParser::T__14:
          case SparqlAutomaticParser::T__25:
          case SparqlAutomaticParser::T__27:
          case SparqlAutomaticParser::T__28:
          case SparqlAutomaticParser::GROUP_CONCAT:
          case SparqlAutomaticParser::NOT:
          case SparqlAutomaticParser::STR:
          case SparqlAutomaticParser::LANG:
          case SparqlAutomaticParser::LANGMATCHES:
          case SparqlAutomaticParser::DATATYPE:
          case SparqlAutomaticParser::BOUND:
          case SparqlAutomaticParser::IRI:
          case SparqlAutomaticParser::URI:
          case SparqlAutomaticParser::BNODE:
          case SparqlAutomaticParser::RAND:
          case SparqlAutomaticParser::ABS:
          case SparqlAutomaticParser::CEIL:
          case SparqlAutomaticParser::FLOOR:
          case SparqlAutomaticParser::ROUND:
          case SparqlAutomaticParser::CONCAT:
          case SparqlAutomaticParser::STRLEN:
          case SparqlAutomaticParser::UCASE:
          case SparqlAutomaticParser::LCASE:
          case SparqlAutomaticParser::ENCODE_FOR_URI:
          case SparqlAutomaticParser::CONTAINS:
          case SparqlAutomaticParser::STRSTARTS:
          case SparqlAutomaticParser::STRENDS:
          case SparqlAutomaticParser::STRBEFORE:
          case SparqlAutomaticParser::STRAFTER:
          case SparqlAutomaticParser::YEAR:
          case SparqlAutomaticParser::MONTH:
          case SparqlAutomaticParser::DAY:
          case SparqlAutomaticParser::HOURS:
          case SparqlAutomaticParser::MINUTES:
          case SparqlAutomaticParser::SECONDS:
          case SparqlAutomaticParser::TIMEZONE:
          case SparqlAutomaticParser::TZ:
          case SparqlAutomaticParser::NOW:
          case SparqlAutomaticParser::UUID:
          case SparqlAutomaticParser::STRUUID:
          case SparqlAutomaticParser::SHA1:
          case SparqlAutomaticParser::SHA256:
          case SparqlAutomaticParser::SHA384:
          case SparqlAutomaticParser::SHA512:
          case SparqlAutomaticParser::MD5:
          case SparqlAutomaticParser::COALESCE:
          case SparqlAutomaticParser::IF:
          case SparqlAutomaticParser::STRLANG:
          case SparqlAutomaticParser::STRDT:
          case SparqlAutomaticParser::SAMETERM:
          case SparqlAutomaticParser::ISIRI:
          case SparqlAutomaticParser::ISURI:
          case SparqlAutomaticParser::ISBLANK:
          case SparqlAutomaticParser::ISLITERAL:
          case SparqlAutomaticParser::ISNUMERIC:
          case SparqlAutomaticParser::REGEX:
          case SparqlAutomaticParser::SUBSTR:
          case SparqlAutomaticParser::REPLACE:
          case SparqlAutomaticParser::EXISTS:
          case SparqlAutomaticParser::COUNT:
          case SparqlAutomaticParser::SUM:
          case SparqlAutomaticParser::MIN:
          case SparqlAutomaticParser::MAX:
          case SparqlAutomaticParser::AVG:
          case SparqlAutomaticParser::STDEV:
          case SparqlAutomaticParser::SAMPLE:
          case SparqlAutomaticParser::IRI_REF:
          case SparqlAutomaticParser::PNAME_NS:
          case SparqlAutomaticParser::PNAME_LN:
          case SparqlAutomaticParser::VAR1:
          case SparqlAutomaticParser::VAR2:
          case SparqlAutomaticParser::PREFIX_LANGTAG:
          case SparqlAutomaticParser::INTEGER:
          case SparqlAutomaticParser::DECIMAL:
          case SparqlAutomaticParser::DOUBLE:
          case SparqlAutomaticParser::INTEGER_POSITIVE:
          case SparqlAutomaticParser::DECIMAL_POSITIVE:
          case SparqlAutomaticParser::DOUBLE_POSITIVE:
          case SparqlAutomaticParser::INTEGER_NEGATIVE:
          case SparqlAutomaticParser::DECIMAL_NEGATIVE:
          case SparqlAutomaticParser::DOUBLE_NEGATIVE:
          case SparqlAutomaticParser::STRING_LITERAL1:
          case SparqlAutomaticParser::STRING_LITERAL2:
          case SparqlAutomaticParser::STRING_LITERAL_LONG1:
          case SparqlAutomaticParser::STRING_LITERAL_LONG2: {
            setState(1557);
            expression();
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        setState(1560);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::SUM: {
        enterOuterAlt(_localctx, 2);
        setState(1561);
        match(SparqlAutomaticParser::SUM);
        setState(1562);
        match(SparqlAutomaticParser::T__1);
        setState(1564);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::DISTINCT) {
          setState(1563);
          match(SparqlAutomaticParser::DISTINCT);
        }
        setState(1566);
        expression();
        setState(1567);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::MIN: {
        enterOuterAlt(_localctx, 3);
        setState(1569);
        match(SparqlAutomaticParser::MIN);
        setState(1570);
        match(SparqlAutomaticParser::T__1);
        setState(1572);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::DISTINCT) {
          setState(1571);
          match(SparqlAutomaticParser::DISTINCT);
        }
        setState(1574);
        expression();
        setState(1575);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::MAX: {
        enterOuterAlt(_localctx, 4);
        setState(1577);
        match(SparqlAutomaticParser::MAX);
        setState(1578);
        match(SparqlAutomaticParser::T__1);
        setState(1580);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::DISTINCT) {
          setState(1579);
          match(SparqlAutomaticParser::DISTINCT);
        }
        setState(1582);
        expression();
        setState(1583);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::AVG: {
        enterOuterAlt(_localctx, 5);
        setState(1585);
        match(SparqlAutomaticParser::AVG);
        setState(1586);
        match(SparqlAutomaticParser::T__1);
        setState(1588);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::DISTINCT) {
          setState(1587);
          match(SparqlAutomaticParser::DISTINCT);
        }
        setState(1590);
        expression();
        setState(1591);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::STDEV: {
        enterOuterAlt(_localctx, 6);
        setState(1593);
        match(SparqlAutomaticParser::STDEV);
        setState(1594);
        match(SparqlAutomaticParser::T__1);
        setState(1596);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::DISTINCT) {
          setState(1595);
          match(SparqlAutomaticParser::DISTINCT);
        }
        setState(1598);
        expression();
        setState(1599);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::SAMPLE: {
        enterOuterAlt(_localctx, 7);
        setState(1601);
        match(SparqlAutomaticParser::SAMPLE);
        setState(1602);
        match(SparqlAutomaticParser::T__1);
        setState(1604);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::DISTINCT) {
          setState(1603);
          match(SparqlAutomaticParser::DISTINCT);
        }
        setState(1606);
        expression();
        setState(1607);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      case SparqlAutomaticParser::GROUP_CONCAT: {
        enterOuterAlt(_localctx, 8);
        setState(1609);
        match(SparqlAutomaticParser::GROUP_CONCAT);
        setState(1610);
        match(SparqlAutomaticParser::T__1);
        setState(1612);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::DISTINCT) {
          setState(1611);
          match(SparqlAutomaticParser::DISTINCT);
        }
        setState(1614);
        expression();
        setState(1619);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SparqlAutomaticParser::T__5) {
          setState(1615);
          match(SparqlAutomaticParser::T__5);
          setState(1616);
          match(SparqlAutomaticParser::SEPARATOR);
          setState(1617);
          match(SparqlAutomaticParser::T__19);
          setState(1618);
          string();
        }
        setState(1621);
        match(SparqlAutomaticParser::T__2);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IriOrFunctionContext
//------------------------------------------------------------------

SparqlAutomaticParser::IriOrFunctionContext::IriOrFunctionContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::IriContext*
SparqlAutomaticParser::IriOrFunctionContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

SparqlAutomaticParser::ArgListContext*
SparqlAutomaticParser::IriOrFunctionContext::argList() {
  return getRuleContext<SparqlAutomaticParser::ArgListContext>(0);
}

size_t SparqlAutomaticParser::IriOrFunctionContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleIriOrFunction;
}

void SparqlAutomaticParser::IriOrFunctionContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterIriOrFunction(this);
}

void SparqlAutomaticParser::IriOrFunctionContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitIriOrFunction(this);
}

std::any SparqlAutomaticParser::IriOrFunctionContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitIriOrFunction(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::IriOrFunctionContext*
SparqlAutomaticParser::iriOrFunction() {
  IriOrFunctionContext* _localctx =
      _tracker.createInstance<IriOrFunctionContext>(_ctx, getState());
  enterRule(_localctx, 286, SparqlAutomaticParser::RuleIriOrFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1625);
    iri();
    setState(1627);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::T__1 ||
        _la == SparqlAutomaticParser::NIL) {
      setState(1626);
      argList();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RdfLiteralContext
//------------------------------------------------------------------

SparqlAutomaticParser::RdfLiteralContext::RdfLiteralContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::StringContext*
SparqlAutomaticParser::RdfLiteralContext::string() {
  return getRuleContext<SparqlAutomaticParser::StringContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::RdfLiteralContext::LANGTAG() {
  return getToken(SparqlAutomaticParser::LANGTAG, 0);
}

SparqlAutomaticParser::IriContext*
SparqlAutomaticParser::RdfLiteralContext::iri() {
  return getRuleContext<SparqlAutomaticParser::IriContext>(0);
}

size_t SparqlAutomaticParser::RdfLiteralContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleRdfLiteral;
}

void SparqlAutomaticParser::RdfLiteralContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterRdfLiteral(this);
}

void SparqlAutomaticParser::RdfLiteralContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitRdfLiteral(this);
}

std::any SparqlAutomaticParser::RdfLiteralContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitRdfLiteral(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::RdfLiteralContext* SparqlAutomaticParser::rdfLiteral() {
  RdfLiteralContext* _localctx =
      _tracker.createInstance<RdfLiteralContext>(_ctx, getState());
  enterRule(_localctx, 288, SparqlAutomaticParser::RuleRdfLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1629);
    string();
    setState(1633);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::LANGTAG: {
        setState(1630);
        match(SparqlAutomaticParser::LANGTAG);
        break;
      }

      case SparqlAutomaticParser::T__26: {
        setState(1631);
        match(SparqlAutomaticParser::T__26);
        setState(1632);
        iri();
        break;
      }

      case SparqlAutomaticParser::T__0:
      case SparqlAutomaticParser::T__1:
      case SparqlAutomaticParser::T__2:
      case SparqlAutomaticParser::T__3:
      case SparqlAutomaticParser::T__4:
      case SparqlAutomaticParser::T__5:
      case SparqlAutomaticParser::T__6:
      case SparqlAutomaticParser::T__7:
      case SparqlAutomaticParser::T__8:
      case SparqlAutomaticParser::T__10:
      case SparqlAutomaticParser::T__11:
      case SparqlAutomaticParser::T__12:
      case SparqlAutomaticParser::T__14:
      case SparqlAutomaticParser::T__15:
      case SparqlAutomaticParser::T__16:
      case SparqlAutomaticParser::T__17:
      case SparqlAutomaticParser::T__18:
      case SparqlAutomaticParser::T__19:
      case SparqlAutomaticParser::T__20:
      case SparqlAutomaticParser::T__21:
      case SparqlAutomaticParser::T__22:
      case SparqlAutomaticParser::T__23:
      case SparqlAutomaticParser::T__24:
      case SparqlAutomaticParser::T__25:
      case SparqlAutomaticParser::T__27:
      case SparqlAutomaticParser::T__28:
      case SparqlAutomaticParser::AS:
      case SparqlAutomaticParser::VALUES:
      case SparqlAutomaticParser::GRAPH:
      case SparqlAutomaticParser::OPTIONAL:
      case SparqlAutomaticParser::SERVICE:
      case SparqlAutomaticParser::BIND:
      case SparqlAutomaticParser::UNDEF:
      case SparqlAutomaticParser::MINUS:
      case SparqlAutomaticParser::FILTER:
      case SparqlAutomaticParser::NOT:
      case SparqlAutomaticParser::IN:
      case SparqlAutomaticParser::IRI_REF:
      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN:
      case SparqlAutomaticParser::BLANK_NODE_LABEL:
      case SparqlAutomaticParser::VAR1:
      case SparqlAutomaticParser::VAR2:
      case SparqlAutomaticParser::PREFIX_LANGTAG:
      case SparqlAutomaticParser::INTEGER:
      case SparqlAutomaticParser::DECIMAL:
      case SparqlAutomaticParser::DOUBLE:
      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE:
      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE:
      case SparqlAutomaticParser::STRING_LITERAL1:
      case SparqlAutomaticParser::STRING_LITERAL2:
      case SparqlAutomaticParser::STRING_LITERAL_LONG1:
      case SparqlAutomaticParser::STRING_LITERAL_LONG2:
      case SparqlAutomaticParser::NIL:
      case SparqlAutomaticParser::ANON: {
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericLiteralContext
//------------------------------------------------------------------

SparqlAutomaticParser::NumericLiteralContext::NumericLiteralContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::NumericLiteralUnsignedContext*
SparqlAutomaticParser::NumericLiteralContext::numericLiteralUnsigned() {
  return getRuleContext<SparqlAutomaticParser::NumericLiteralUnsignedContext>(
      0);
}

SparqlAutomaticParser::NumericLiteralPositiveContext*
SparqlAutomaticParser::NumericLiteralContext::numericLiteralPositive() {
  return getRuleContext<SparqlAutomaticParser::NumericLiteralPositiveContext>(
      0);
}

SparqlAutomaticParser::NumericLiteralNegativeContext*
SparqlAutomaticParser::NumericLiteralContext::numericLiteralNegative() {
  return getRuleContext<SparqlAutomaticParser::NumericLiteralNegativeContext>(
      0);
}

size_t SparqlAutomaticParser::NumericLiteralContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleNumericLiteral;
}

void SparqlAutomaticParser::NumericLiteralContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterNumericLiteral(this);
}

void SparqlAutomaticParser::NumericLiteralContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitNumericLiteral(this);
}

std::any SparqlAutomaticParser::NumericLiteralContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitNumericLiteral(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::NumericLiteralContext*
SparqlAutomaticParser::numericLiteral() {
  NumericLiteralContext* _localctx =
      _tracker.createInstance<NumericLiteralContext>(_ctx, getState());
  enterRule(_localctx, 290, SparqlAutomaticParser::RuleNumericLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1638);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::INTEGER:
      case SparqlAutomaticParser::DECIMAL:
      case SparqlAutomaticParser::DOUBLE: {
        enterOuterAlt(_localctx, 1);
        setState(1635);
        numericLiteralUnsigned();
        break;
      }

      case SparqlAutomaticParser::INTEGER_POSITIVE:
      case SparqlAutomaticParser::DECIMAL_POSITIVE:
      case SparqlAutomaticParser::DOUBLE_POSITIVE: {
        enterOuterAlt(_localctx, 2);
        setState(1636);
        numericLiteralPositive();
        break;
      }

      case SparqlAutomaticParser::INTEGER_NEGATIVE:
      case SparqlAutomaticParser::DECIMAL_NEGATIVE:
      case SparqlAutomaticParser::DOUBLE_NEGATIVE: {
        enterOuterAlt(_localctx, 3);
        setState(1637);
        numericLiteralNegative();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericLiteralUnsignedContext
//------------------------------------------------------------------

SparqlAutomaticParser::NumericLiteralUnsignedContext::
    NumericLiteralUnsignedContext(ParserRuleContext* parent,
                                  size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode*
SparqlAutomaticParser::NumericLiteralUnsignedContext::INTEGER() {
  return getToken(SparqlAutomaticParser::INTEGER, 0);
}

tree::TerminalNode*
SparqlAutomaticParser::NumericLiteralUnsignedContext::DECIMAL() {
  return getToken(SparqlAutomaticParser::DECIMAL, 0);
}

tree::TerminalNode*
SparqlAutomaticParser::NumericLiteralUnsignedContext::DOUBLE() {
  return getToken(SparqlAutomaticParser::DOUBLE, 0);
}

size_t SparqlAutomaticParser::NumericLiteralUnsignedContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleNumericLiteralUnsigned;
}

void SparqlAutomaticParser::NumericLiteralUnsignedContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericLiteralUnsigned(this);
}

void SparqlAutomaticParser::NumericLiteralUnsignedContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericLiteralUnsigned(this);
}

std::any SparqlAutomaticParser::NumericLiteralUnsignedContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitNumericLiteralUnsigned(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::NumericLiteralUnsignedContext*
SparqlAutomaticParser::numericLiteralUnsigned() {
  NumericLiteralUnsignedContext* _localctx =
      _tracker.createInstance<NumericLiteralUnsignedContext>(_ctx, getState());
  enterRule(_localctx, 292, SparqlAutomaticParser::RuleNumericLiteralUnsigned);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1640);
    _la = _input->LA(1);
    if (!((((_la - 150) & ~0x3fULL) == 0) &&
          ((1ULL << (_la - 150)) & 7) != 0)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericLiteralPositiveContext
//------------------------------------------------------------------

SparqlAutomaticParser::NumericLiteralPositiveContext::
    NumericLiteralPositiveContext(ParserRuleContext* parent,
                                  size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode*
SparqlAutomaticParser::NumericLiteralPositiveContext::INTEGER_POSITIVE() {
  return getToken(SparqlAutomaticParser::INTEGER_POSITIVE, 0);
}

tree::TerminalNode*
SparqlAutomaticParser::NumericLiteralPositiveContext::DECIMAL_POSITIVE() {
  return getToken(SparqlAutomaticParser::DECIMAL_POSITIVE, 0);
}

tree::TerminalNode*
SparqlAutomaticParser::NumericLiteralPositiveContext::DOUBLE_POSITIVE() {
  return getToken(SparqlAutomaticParser::DOUBLE_POSITIVE, 0);
}

size_t SparqlAutomaticParser::NumericLiteralPositiveContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleNumericLiteralPositive;
}

void SparqlAutomaticParser::NumericLiteralPositiveContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericLiteralPositive(this);
}

void SparqlAutomaticParser::NumericLiteralPositiveContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericLiteralPositive(this);
}

std::any SparqlAutomaticParser::NumericLiteralPositiveContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitNumericLiteralPositive(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::NumericLiteralPositiveContext*
SparqlAutomaticParser::numericLiteralPositive() {
  NumericLiteralPositiveContext* _localctx =
      _tracker.createInstance<NumericLiteralPositiveContext>(_ctx, getState());
  enterRule(_localctx, 294, SparqlAutomaticParser::RuleNumericLiteralPositive);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1642);
    _la = _input->LA(1);
    if (!((((_la - 153) & ~0x3fULL) == 0) &&
          ((1ULL << (_la - 153)) & 7) != 0)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericLiteralNegativeContext
//------------------------------------------------------------------

SparqlAutomaticParser::NumericLiteralNegativeContext::
    NumericLiteralNegativeContext(ParserRuleContext* parent,
                                  size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode*
SparqlAutomaticParser::NumericLiteralNegativeContext::INTEGER_NEGATIVE() {
  return getToken(SparqlAutomaticParser::INTEGER_NEGATIVE, 0);
}

tree::TerminalNode*
SparqlAutomaticParser::NumericLiteralNegativeContext::DECIMAL_NEGATIVE() {
  return getToken(SparqlAutomaticParser::DECIMAL_NEGATIVE, 0);
}

tree::TerminalNode*
SparqlAutomaticParser::NumericLiteralNegativeContext::DOUBLE_NEGATIVE() {
  return getToken(SparqlAutomaticParser::DOUBLE_NEGATIVE, 0);
}

size_t SparqlAutomaticParser::NumericLiteralNegativeContext::getRuleIndex()
    const {
  return SparqlAutomaticParser::RuleNumericLiteralNegative;
}

void SparqlAutomaticParser::NumericLiteralNegativeContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericLiteralNegative(this);
}

void SparqlAutomaticParser::NumericLiteralNegativeContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericLiteralNegative(this);
}

std::any SparqlAutomaticParser::NumericLiteralNegativeContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitNumericLiteralNegative(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::NumericLiteralNegativeContext*
SparqlAutomaticParser::numericLiteralNegative() {
  NumericLiteralNegativeContext* _localctx =
      _tracker.createInstance<NumericLiteralNegativeContext>(_ctx, getState());
  enterRule(_localctx, 296, SparqlAutomaticParser::RuleNumericLiteralNegative);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1644);
    _la = _input->LA(1);
    if (!((((_la - 156) & ~0x3fULL) == 0) &&
          ((1ULL << (_la - 156)) & 7) != 0)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanLiteralContext
//------------------------------------------------------------------

SparqlAutomaticParser::BooleanLiteralContext::BooleanLiteralContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

size_t SparqlAutomaticParser::BooleanLiteralContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleBooleanLiteral;
}

void SparqlAutomaticParser::BooleanLiteralContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterBooleanLiteral(this);
}

void SparqlAutomaticParser::BooleanLiteralContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitBooleanLiteral(this);
}

std::any SparqlAutomaticParser::BooleanLiteralContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitBooleanLiteral(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::BooleanLiteralContext*
SparqlAutomaticParser::booleanLiteral() {
  BooleanLiteralContext* _localctx =
      _tracker.createInstance<BooleanLiteralContext>(_ctx, getState());
  enterRule(_localctx, 298, SparqlAutomaticParser::RuleBooleanLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1646);
    _la = _input->LA(1);
    if (!(_la == SparqlAutomaticParser::T__27

          || _la == SparqlAutomaticParser::T__28)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringContext
//------------------------------------------------------------------

SparqlAutomaticParser::StringContext::StringContext(ParserRuleContext* parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::StringContext::STRING_LITERAL1() {
  return getToken(SparqlAutomaticParser::STRING_LITERAL1, 0);
}

tree::TerminalNode* SparqlAutomaticParser::StringContext::STRING_LITERAL2() {
  return getToken(SparqlAutomaticParser::STRING_LITERAL2, 0);
}

tree::TerminalNode*
SparqlAutomaticParser::StringContext::STRING_LITERAL_LONG1() {
  return getToken(SparqlAutomaticParser::STRING_LITERAL_LONG1, 0);
}

tree::TerminalNode*
SparqlAutomaticParser::StringContext::STRING_LITERAL_LONG2() {
  return getToken(SparqlAutomaticParser::STRING_LITERAL_LONG2, 0);
}

size_t SparqlAutomaticParser::StringContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleString;
}

void SparqlAutomaticParser::StringContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterString(this);
}

void SparqlAutomaticParser::StringContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitString(this);
}

std::any SparqlAutomaticParser::StringContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitString(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::StringContext* SparqlAutomaticParser::string() {
  StringContext* _localctx =
      _tracker.createInstance<StringContext>(_ctx, getState());
  enterRule(_localctx, 300, SparqlAutomaticParser::RuleString);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1648);
    _la = _input->LA(1);
    if (!((((_la - 160) & ~0x3fULL) == 0) &&
          ((1ULL << (_la - 160)) & 15) != 0)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IriContext
//------------------------------------------------------------------

SparqlAutomaticParser::IriContext::IriContext(ParserRuleContext* parent,
                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::IrirefContext*
SparqlAutomaticParser::IriContext::iriref() {
  return getRuleContext<SparqlAutomaticParser::IrirefContext>(0);
}

SparqlAutomaticParser::PrefixedNameContext*
SparqlAutomaticParser::IriContext::prefixedName() {
  return getRuleContext<SparqlAutomaticParser::PrefixedNameContext>(0);
}

tree::TerminalNode* SparqlAutomaticParser::IriContext::PREFIX_LANGTAG() {
  return getToken(SparqlAutomaticParser::PREFIX_LANGTAG, 0);
}

size_t SparqlAutomaticParser::IriContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleIri;
}

void SparqlAutomaticParser::IriContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterIri(this);
}

void SparqlAutomaticParser::IriContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitIri(this);
}

std::any SparqlAutomaticParser::IriContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitIri(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::IriContext* SparqlAutomaticParser::iri() {
  IriContext* _localctx = _tracker.createInstance<IriContext>(_ctx, getState());
  enterRule(_localctx, 302, SparqlAutomaticParser::RuleIri);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1651);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SparqlAutomaticParser::PREFIX_LANGTAG) {
      setState(1650);
      match(SparqlAutomaticParser::PREFIX_LANGTAG);
    }
    setState(1655);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::IRI_REF: {
        setState(1653);
        iriref();
        break;
      }

      case SparqlAutomaticParser::PNAME_NS:
      case SparqlAutomaticParser::PNAME_LN: {
        setState(1654);
        prefixedName();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrefixedNameContext
//------------------------------------------------------------------

SparqlAutomaticParser::PrefixedNameContext::PrefixedNameContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

SparqlAutomaticParser::PnameLnContext*
SparqlAutomaticParser::PrefixedNameContext::pnameLn() {
  return getRuleContext<SparqlAutomaticParser::PnameLnContext>(0);
}

SparqlAutomaticParser::PnameNsContext*
SparqlAutomaticParser::PrefixedNameContext::pnameNs() {
  return getRuleContext<SparqlAutomaticParser::PnameNsContext>(0);
}

size_t SparqlAutomaticParser::PrefixedNameContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePrefixedName;
}

void SparqlAutomaticParser::PrefixedNameContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPrefixedName(this);
}

void SparqlAutomaticParser::PrefixedNameContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPrefixedName(this);
}

std::any SparqlAutomaticParser::PrefixedNameContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPrefixedName(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PrefixedNameContext*
SparqlAutomaticParser::prefixedName() {
  PrefixedNameContext* _localctx =
      _tracker.createInstance<PrefixedNameContext>(_ctx, getState());
  enterRule(_localctx, 304, SparqlAutomaticParser::RulePrefixedName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1659);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SparqlAutomaticParser::PNAME_LN: {
        enterOuterAlt(_localctx, 1);
        setState(1657);
        pnameLn();
        break;
      }

      case SparqlAutomaticParser::PNAME_NS: {
        enterOuterAlt(_localctx, 2);
        setState(1658);
        pnameNs();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlankNodeContext
//------------------------------------------------------------------

SparqlAutomaticParser::BlankNodeContext::BlankNodeContext(
    ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode*
SparqlAutomaticParser::BlankNodeContext::BLANK_NODE_LABEL() {
  return getToken(SparqlAutomaticParser::BLANK_NODE_LABEL, 0);
}

tree::TerminalNode* SparqlAutomaticParser::BlankNodeContext::ANON() {
  return getToken(SparqlAutomaticParser::ANON, 0);
}

size_t SparqlAutomaticParser::BlankNodeContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleBlankNode;
}

void SparqlAutomaticParser::BlankNodeContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterBlankNode(this);
}

void SparqlAutomaticParser::BlankNodeContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitBlankNode(this);
}

std::any SparqlAutomaticParser::BlankNodeContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitBlankNode(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::BlankNodeContext* SparqlAutomaticParser::blankNode() {
  BlankNodeContext* _localctx =
      _tracker.createInstance<BlankNodeContext>(_ctx, getState());
  enterRule(_localctx, 306, SparqlAutomaticParser::RuleBlankNode);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1661);
    _la = _input->LA(1);
    if (!(_la == SparqlAutomaticParser::BLANK_NODE_LABEL

          || _la == SparqlAutomaticParser::ANON)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IrirefContext
//------------------------------------------------------------------

SparqlAutomaticParser::IrirefContext::IrirefContext(ParserRuleContext* parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::IrirefContext::IRI_REF() {
  return getToken(SparqlAutomaticParser::IRI_REF, 0);
}

size_t SparqlAutomaticParser::IrirefContext::getRuleIndex() const {
  return SparqlAutomaticParser::RuleIriref;
}

void SparqlAutomaticParser::IrirefContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterIriref(this);
}

void SparqlAutomaticParser::IrirefContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitIriref(this);
}

std::any SparqlAutomaticParser::IrirefContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitIriref(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::IrirefContext* SparqlAutomaticParser::iriref() {
  IrirefContext* _localctx =
      _tracker.createInstance<IrirefContext>(_ctx, getState());
  enterRule(_localctx, 308, SparqlAutomaticParser::RuleIriref);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1663);
    match(SparqlAutomaticParser::IRI_REF);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PnameLnContext
//------------------------------------------------------------------

SparqlAutomaticParser::PnameLnContext::PnameLnContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::PnameLnContext::PNAME_LN() {
  return getToken(SparqlAutomaticParser::PNAME_LN, 0);
}

size_t SparqlAutomaticParser::PnameLnContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePnameLn;
}

void SparqlAutomaticParser::PnameLnContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPnameLn(this);
}

void SparqlAutomaticParser::PnameLnContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPnameLn(this);
}

std::any SparqlAutomaticParser::PnameLnContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPnameLn(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PnameLnContext* SparqlAutomaticParser::pnameLn() {
  PnameLnContext* _localctx =
      _tracker.createInstance<PnameLnContext>(_ctx, getState());
  enterRule(_localctx, 310, SparqlAutomaticParser::RulePnameLn);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1665);
    match(SparqlAutomaticParser::PNAME_LN);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PnameNsContext
//------------------------------------------------------------------

SparqlAutomaticParser::PnameNsContext::PnameNsContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* SparqlAutomaticParser::PnameNsContext::PNAME_NS() {
  return getToken(SparqlAutomaticParser::PNAME_NS, 0);
}

size_t SparqlAutomaticParser::PnameNsContext::getRuleIndex() const {
  return SparqlAutomaticParser::RulePnameNs;
}

void SparqlAutomaticParser::PnameNsContext::enterRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPnameNs(this);
}

void SparqlAutomaticParser::PnameNsContext::exitRule(
    tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<SparqlAutomaticListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPnameNs(this);
}

std::any SparqlAutomaticParser::PnameNsContext::accept(
    tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<SparqlAutomaticVisitor*>(visitor))
    return parserVisitor->visitPnameNs(this);
  else
    return visitor->visitChildren(this);
}

SparqlAutomaticParser::PnameNsContext* SparqlAutomaticParser::pnameNs() {
  PnameNsContext* _localctx =
      _tracker.createInstance<PnameNsContext>(_ctx, getState());
  enterRule(_localctx, 312, SparqlAutomaticParser::RulePnameNs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1667);
    match(SparqlAutomaticParser::PNAME_NS);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void SparqlAutomaticParser::initialize() {
  ::antlr4::internal::call_once(sparqlautomaticParserOnceFlag,
                                sparqlautomaticParserInitialize);
}
