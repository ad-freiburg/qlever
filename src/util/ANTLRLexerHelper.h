// Copyright 2023, University of Freiburg,
// Chair of Algorithms and Data Structures.
// Author: Andre Schlegel (March of 2023, schlegea@informatik.uni-freiburg.de)

#pragma once

#include <ANTLRInputStream.h>
#include <Lexer.h>

#include <concepts>
#include <string_view>

#include "util/Algorithm.h"
#include "util/json.h"

/*
@brief Check, if the given string, interpreted with the given lexer, only
contains tokens with same token indexes and in the same order, as the given
indexes.

@tparam lexer A lexer created by antlr4. Warning: It WILL be reset.

@param str A string, which content will be transformed into tokens with the
given lexer.
@param tokenTypeIds In `anltr4` every token type has it's own unique index for
identfication. You should find yours as an enum inside your lexer class.

IMPORTANT: Remember, the highest possible lexer rule will always be used by the
lexer to generate a token. That INCLUDES rules, that are just `or` collections
of other lexer rules.
For example: Let's say, those are all of your lexer rules:
```
LITERAL : BOOL | INTEGER;
BOOL : 'true' | 'false';
INTEGER : '-'?[0-9]+;
```
With this grammar, you will NEVER get a token of type `BOOL`, or `INTEGER`,
because `LITERAL` has higher priority and includes all the cases of the other
two.
Input example:
Given the input `true -48`, the lexer would start with trying to find matches
for lexer rule with the highest priority, generate the tokens, and then repeat,
following the order from the lexer rule with the highest priority, to the lexer
rule with the lowes priority.
Priority of the lexer rules is dicated by the order, there are written in the
grammar. In our example that order would be `LITERAL`, `BOOL`, and then
`INTEGER`.
Now, `true -48` could be seen as the tokens `BOOL INTEGER`, but, because the
lexer first looks at `LITERAL`, which is a superset of the two other lexer
rules, they are seen as `LITERAL LITERAL`. After that, it looks for matches for
`BOOL`, but only finds two tokens of `LITERAL`. No `BOOL` tokens are generated.
Same for `INTEGER` after him.
*/
template <std::derived_from<antlr4::Lexer> Lexer>
bool stringOnlyContainsSpecifiedTokens(
    std::string_view str, const std::same_as<size_t> auto&... tokenTypeIds)
    requires(sizeof...(tokenTypeIds) > 0) {
  // Create the lexer.
  antlr4::ANTLRInputStream inputStream(str);
  Lexer lexer(&inputStream);

  // Get the type of ALL the tokens, that are generated by the lexer.
  const std::vector<size_t>& allTokenTypeIndexes = ad_utility::transform(
      lexer.getAllTokens(), [](const std::unique_ptr<antlr4::Token>& token) {
        return token->getType();
      });

  /*
  Checks, if the i-th token has the same type index, as what the user wants and
  then raises `i` by one.
  */
  auto checkToken = [i = size_t{0}, &allTokenTypeIndexes](
                        const size_t& tokenTypeIndex) mutable {
    i += 1;
    return tokenTypeIndex == allTokenTypeIndexes.at(i - 1);
  };

  return (allTokenTypeIndexes.size() == sizeof...(tokenTypeIds)) &&
         (checkToken(tokenTypeIds) && ...);
}
