// Copyright 2023, University of Freiburg,
// Chair of Algorithms and Data Structures.
// Author: Andre Schlegel (March of 2023, schlegea@informatik.uni-freiburg.de)

#pragma once

#include <ANTLRInputStream.h>
#include <Lexer.h>

#include <concepts>
#include <string_view>

#include "util/Algorithm.h"
#include "util/json.h"

/*
@brief Check, if the given string, interpreted with the given lexer, only
contains tokens with same token indexes and in the same order, as the given
indexes.

@tparam lexer A lexer created by antlr4. Warning: It WILL be reset.

@param str A string, which content will be transformed into tokens with the
given lexer.
@param tokenTypeIds In `anltr4` every token type has it's own unique index for
identfication. You should find yours as an enum inside your lexer class.
IMPORTANT: Remember, the highest possible lexer rule will always be used by the
lexer to generate a token. That INCLUDES rules, that are just `or` collections
of other lexer rules. For example:
```
LITERAL : BOOL | INTEGER;
BOOL : 'true' | 'false';
INTEGER : '-'?[0-9]+;
```
With this grammar, you will NEVER get a token of type `BOOL`, or `INTEGER`,
because `LITERAL` has higher priority and includes all the cases of the other
two.
*/
template <std::derived_from<antlr4::Lexer> Lexer>
bool stringOnlyContainsSpecifiedTokens(
    const std::string_view& str,
    const std::same_as<size_t> auto&... tokenTypeIds)
    requires(sizeof...(tokenTypeIds) > 0) {
  // Create the lexer.
  auto inputStream{antlr4::ANTLRInputStream(str)};
  Lexer lexer(&inputStream);

  // Get the type of ALL the tokens, that are generated by the lexer.
  const std::vector<size_t>& allTokenTypeIndexes = ad_utility::transform(
      lexer.getAllTokens(), [](const std::unique_ptr<antlr4::Token>& token) {
        return token->getType();
      });

  /*
  Checks, if the i-th token has the same type index, as what the user wants and
  then raises `i` by one.
  */
  auto checkToken = [i = size_t{0}, &allTokenTypeIndexes](
                        const size_t& tokenTypeIndex) mutable {
    i += 1;
    return tokenTypeIndex == allTokenTypeIndexes.at(i - 1);
  };

  return (allTokenTypeIndexes.size() == sizeof...(tokenTypeIds)) &&
         (checkToken(tokenTypeIds) && ...);
}
